<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术笔记</title>
  
  <subtitle>有输入,有输出</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muxiaobai.github.io/"/>
  <updated>2020-05-06T06:42:24.142Z</updated>
  <id>https://muxiaobai.github.io/</id>
  
  <author>
    <name>Mu Xiaobai(慕小白)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java线上代码监控-linux分析线上问题</title>
    <link href="https://muxiaobai.github.io/2020/04/29/java%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81%E7%9B%91%E6%8E%A7-linux%E5%88%86%E6%9E%90%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    <id>https://muxiaobai.github.io/2020/04/29/java线上代码监控-linux分析线上问题/</id>
    <published>2020-04-29T08:41:41.000Z</published>
    <updated>2020-05-06T06:42:24.142Z</updated>
    
    <content type="html"><![CDATA[<p>jps(Java Virtual Machine Process Status Tool)<br>jstack(查看线程)、jmap(查看内存)和jstat(性能分析)</p><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>jps 找到对应的进程ID</p><p><code>jps -m -l</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure><h2 id="未重启的话，分析现在的时候"><a href="#未重启的话，分析现在的时候" class="headerlink" title="未重启的话，分析现在的时候:"></a>未重启的话，分析现在的时候:</h2><h3 id="jstack-线程问题"><a href="#jstack-线程问题" class="headerlink" title="jstack 线程问题"></a>jstack 线程问题</h3><p>ps -mp [pid] -o THREAD,tid,time |sort -rn 打印CPU最高的线程<br>top -Hp [pid] </p><p>printf “%x\n” 22338 把线程ID转换成16进制<br>5742</p><p>jstack [pid] | grep 5742 -A 30 打印堆栈信息</p><p>-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况<br>-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</p><p>-F  to force a thread dump. Use when jstack <pid> does not respond (process is hung)<br>-m  to print both java and native frames (mixed mode)<br>-l  long listing. Prints additional information about locks<br>-h or -help to print this help message</pid></p><p><a href="https://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">jstack Dump 日志文件中的线程状态</a></p><p>线程死锁：<br>jstack –l pid | grep -i –E ‘BLOCKED | deadlock’</p><h3 id="jmap-堆问题"><a href="#jmap-堆问题" class="headerlink" title="jmap 堆问题"></a>jmap 堆问题</h3><p>jmap -heap [pid] 先查看堆栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./jmap -heap 22327</span><br><span class="line">Attaching to process ID 22327, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.201-b09</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 89128960 (85.0MB)</span><br><span class="line">   MaxNewSize               = 715653120 (682.5MB)</span><br><span class="line">   OldSize                  = 179306496 (171.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 671612928 (640.5MB)</span><br><span class="line">   used     = 349908376 (333.6986312866211MB)</span><br><span class="line">   free     = 321704552 (306.8013687133789MB)</span><br><span class="line">   52.0997082414709% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 12582912 (12.0MB)</span><br><span class="line">   used     = 12566640 (11.984481811523438MB)</span><br><span class="line">   free     = 16272 (0.0155181884765625MB)</span><br><span class="line">   99.87068176269531% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 22020096 (21.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 236978176 (226.0MB)</span><br><span class="line">   used     = 45630600 (43.51673126220703MB)</span><br><span class="line">   free     = 191347576 (182.48326873779297MB)</span><br><span class="line">   19.255190823985412% used</span><br><span class="line"></span><br><span class="line">38073 interned Strings occupying 3725472 bytes.</span><br></pre></td></tr></table></figure><p>查看对象</p><p>用jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象，如下：</p><p>数量和容量</p><p>实例数量前十的类：jmap -histo pid | sort -n -r -k 2 | head -10</p><p>实例容量前十的类：jmap -histo pid | sort -n -r -k 3 | head -10</p><h4 id="生成hprof文件（hprof（Heap-CPU-Profiling-Tool））"><a href="#生成hprof文件（hprof（Heap-CPU-Profiling-Tool））" class="headerlink" title="生成hprof文件（hprof（Heap/CPU Profiling Tool））"></a>生成hprof文件（hprof（Heap/CPU Profiling Tool））</h4><p><code>./jmap -dump:live,format=b,file=dump.dump [pid]</code></p><p>可以用：<code>./jhat -port 9998 dump.dump</code>  <code>./jhat -J-Xmx512m -port 9998 dump.dump</code><br>jhat -port 7401 -J-Xmx4G dump.dump</p><p>或者dump文件修改为dump.hprof,可以加到jprofiler</p><p>作用：主要分析内部当时的对象。</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat（JVM统计监测工具）</p><p>每隔250ms采集4次<code>./jstat -gc 30359 250 4</code><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>区容量（Capacity）和使用量（Used）<br>S0 S1 Survivor E O Eden Old M MetaspaceSize CCS CompressedClassSpaceSize  YG young gc FG  full gc T time FCT full gc time</p><p><code>./jstat -options</code> 参数 -gc  </p><p>250ms调用4次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./jstat -gc 22327  250 4</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU            MC     MU     CCSC   CCSU      YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br></pre></td></tr></table></figure><h2 id="准备重启复现的话："><a href="#准备重启复现的话：" class="headerlink" title="准备重启复现的话："></a>准备重启复现的话：</h2><p>第一步 加参数 ：</p><p>gc日志 配置Catalina.bat JAVA_OPTS</p><p><code>-Xloggc:..\logs\gc.log -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintHeapAtGC</code></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247495546&amp;idx=1&amp;sn=f435f56c3b92802ef649cd14bb60711b&amp;chksm=e92ad275de5d5b63b9fc1e48463044ea1b234a4f28d0ad8d7964c42516f1cf7cae47c60162dc&amp;scene=0&amp;xtrack=1&amp;exportkey=AeNCSm6QS4EwNcRCTNfXDUs%3D&amp;pass_ticket=sHf4d8XsExleK1yRet7Gq5oJd6I%2FDOYRgopyFK8gH%2B81%2FhlGHzeiSrSlgR9oXDlk#rd" target="_blank" rel="noopener">步骤:线上问题定位，重启大法好！线上常见问题排查手册</a></li><li><a href="https://blog.csdn.net/muyimo/article/details/52837323?utm_source=distribute.pc_relevant.none-task-blog-baidujs-8" target="_blank" rel="noopener">VM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解</a></li></ul><p>一  线上常见问题定位</p><p>常见问题 1：CPU 利用率高</p><p>CPU 使用率是衡量系统繁忙程度的重要指标，一般情况下单纯的 CPU 高并没有问题，它代表系统正在不断的处理我们的任务，但是如果 CPU 过高，导致任务处理不过来，从而引起 load 高，这个是非常危险需要关注的。 CPU 使用率的安全值没有一个标准值，取决于你的系统是计算密集型还是 IO 密集型，一般计算密集型应用 CPU 使用率偏高 load 偏低，IO 密集型相反。</p><p>问题原因及定位：</p><p>1  频繁 FullGC/YongGC</p><p>2  代码消耗，如死循环，md5 等内存态操作</p><p>常见问题 2：load 高</p><p>load 指单位时间内活跃进程数，包含运行态（runnable 和 running）和不可中断态（ IO、内核态锁）。关键字是运行态和不可中断态，运行态可以联想到 Java 线程的 6 种状态，如下，线程 new 之后处于 NEW 状态，执行 start 进入 runnable 等待 CPU 调度，因此如果 CPU 很忙会导致 runnable 进程数增加；不可中断态主要包含网络 IO、磁盘 IO 以及内核态的锁，如 synchronized 等。</p><p>问题原因及定位：</p><p>1  CPU 利用率高，可运行态进程数多</p><p>2  iowait，等待 IO</p><p>3  等待内核态锁，如 synchronized</p><p>常见问题 3：持续 FullGC</p><p>问题原因及定位：</p><p>1  prommotion failed</p><p>从S区晋升的对象在老年代也放不下导致 FullGC（fgc 回收无效则抛 OOM）。</p><p>1）survivor 区太小，对象过早进入老年代。</p><p>2）大对象分配，没有足够的内存。</p><p>日志查找关键字 “allocating large”；</p><p>2  concurrent mode failed</p><p>在 CMS GC 过程中业务线程将对象放入老年代（并发收集的特点）内存不足。详细原因：</p><p>1）fgc 触发比例过大，导致老年代占用过多，并发收集时用户线程持续产生对象导致达到触发 FGC 比例。</p><p>jinfo  查看 CMSInitiatingOccupancyFraction 参数，一般 70~80 即可</p><p>2）老年代存在内存碎片。</p><p>jinfo  查看 UseCMSCompactAtFullCollection 参数，在 FullGC 后整理内存</p><p>常见问题 4：线程池满</p><p>Java 线程池以有界队列的线程池为例，当新任务提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求。如果正在运行的线程数等于 corePoolSize 时，则新任务被添加到队列中，直到队列满。当队列满了后，会继续开辟新线程来处理任务，但不超过 maximumPoolSize。当任务队列满了并且已开辟了最大线程数，此时又来了新任务，ThreadPoolExecutor 会拒绝服务。</p><p>问题原因及定位：</p><p>2  数据库慢 sql 或者数据库死锁</p><p>日志关键字 “Deadlock found when trying to get lock”</p><p>Jstack 或 zprofiler 查看阻塞态线程</p><p>3  Java 代码死锁</p><p>jstack –l pid | grep -i –E ‘BLOCKED | deadlock’</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jps(Java Virtual Machine Process Status Tool)&lt;br&gt;jstack(查看线程)、jmap(查看内存)和jstat(性能分析)&lt;/p&gt;
&lt;h3 id=&quot;jps&quot;&gt;&lt;a href=&quot;#jps&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019年个人总结</title>
    <link href="https://muxiaobai.github.io/2020/01/13/2019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://muxiaobai.github.io/2020/01/13/2019年个人总结/</id>
    <published>2020-01-13T11:59:49.000Z</published>
    <updated>2020-04-21T03:22:57.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作-技能"><a href="#工作-技能" class="headerlink" title="工作 技能"></a>工作 技能</h2><h4 id="认清自己的位置"><a href="#认清自己的位置" class="headerlink" title="认清自己的位置"></a>认清自己的位置</h4><p>微服务可以落地，持续集成可以试验。这点和公司的形势有关，至少是自己愿意做的内容。</p><h4 id="找到和工作结合的内容"><a href="#找到和工作结合的内容" class="headerlink" title="找到和工作结合的内容"></a>找到和工作结合的内容</h4><p>去年写了今年的思维导图，今年的工作大概3个季度都是在做搜索，那就把这个东西，做好，附件搜，图片搜，优化，不断，提高。</p><h4 id="沉淀"><a href="#沉淀" class="headerlink" title="沉淀"></a>沉淀</h4><p>工作上处于沉淀状态，感觉前两年，已经把之前的优势全都散光了，让时间把我逐渐磨平，这两年又没有什么特别大的发展，一直是在缝缝补补，而且又没有专业性，也没有深入探索，还是流于表面，因<br>此现在再不向前，之后又该拿什么家底来败呢？已经一穷二白了。想想大学时候，基本上都是到十点，然后还有身体锻炼，还年少，真的都是财富，都是优势，现在反而不如以前了。</p><h4 id="大小公司"><a href="#大小公司" class="headerlink" title="大小公司"></a>大小公司</h4><p>小公司，人家都重视你，因为你是全栈，都会，人家都会问你，也看得起你，但你会有一种无力感，没什么可以请教的。大公司，虽然你都会，但你会的每一样公司都有比你更好的，你就显得普通，平庸，实际上本来就是平庸，因为你不够耀眼，你做的内容，不会一下子显现出来，需要用心做，用力深挖，潜心研究，才能有所作为。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>来到bilibili，真的是奇奇怪怪的知识点又增加了，有太多厉害的人物，UP主，只需潜心学习，</p><p>生产资料，和消费品，一定要分的清楚，比如网络，在你学习的时候就是生产资料，在你打游戏的时候，大可能是消费品，比如手机，该换就要早换，不能让这些影响到自己，人家都能在远程办公，咱自己还要去找，找电脑，找网络，找桌椅，这些设备，本应提前备好，以免在用的时候反而约束你。</p><h2 id="去过的地方"><a href="#去过的地方" class="headerlink" title="去过的地方"></a>去过的地方</h2><h4 id="渭南-华山"><a href="#渭南-华山" class="headerlink" title="渭南-华山"></a>渭南-华山</h4><p>太多可以写，认识彼此，冲突产生，今年看去哪里看一看，想去看大熊猫，不知可以不可以？</p><h4 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h4><p>第二次来北京看升国旗，上一次还是大学，顺带来北京看一下，就走了，还看了圆明园和颐和园，以及去了中关村，历史的痕迹和现代化的气息交融在这座城市，</p><p>故宫博物馆，有太多精美的物件，上层人的玩物，你是想都想不到的，镶金，珠光宝石。现在，也是，只不过换了物件而已，但你也是从未有所想象，只能是人家摆在你面前吗，你还在疑问，这是啥？好高级。</p><h4 id="郑州"><a href="#郑州" class="headerlink" title="郑州"></a>郑州</h4><p>虽然是来这里，但是观感不好，郑州大学还是河南的211学校，我虽然是河南的，但河南的高校太少了。<br>河南建业-广州富力，现场看足球，据说看建业的大都是情怀，河南建业足球是是赔钱的，但建业老板还是在支持，怎么说也是中超级别的俱乐部。</p><h4 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h4><p>工作，收入来源的重要性，停工停产，待岗降薪，有太多的不确定性。<br>身体，健康无比重要，活得久，也能说是一种幸福呢？<br>家人，有时候，陪伴在他们身边，也感觉没有那么多害怕，要说来工作的路上，还是有些心惊胆战，<br>意外，啥时候都不会也不可能全部如你所愿，做好准备，plan B，既是现在失去一切，也要有所打算，不要抱怨，不要忧虑，只需正视前方，勇往直前，无悔。</p><p>虽然晚来上班，不过还是按正常时间开工了，只不是换了一种方式而已，</p><p>今年的疫情，会让网课也来越来越普及，有自己喜欢的圈子，看自己感兴趣的直播，找到自己的生活方式。</p><h4 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h4><p>逐渐处于稳定状态，除了工作已经不愿走动，也无法走动，生活已经快将我禁锢到了这里。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><h4 id="2019年计划完成情况"><a href="#2019年计划完成情况" class="headerlink" title="2019年计划完成情况"></a>2019年计划完成情况</h4><ul><li>听讲座，参加技术，文化，社会论坛等，扩展知识广度。</li><li>心理学知识，受益匪浅，需要继续学习。</li><li>研究服务器性能、部署等问题，分析出自己的一套配置。</li></ul><p>通过去年的预习，复习，工作要求，找工作的知识补充，现在对高级知识总算有了一点了解，越来越感觉个人的能力提升到了瓶颈期，因为后面的知识，更加陡峭，而自己已经没有了当初的那股韧劲和毅力。要付出，才有可能有收获，既是这收获不及一二。否则只会后退，因为你的工作时间赶不上你的能力提升。</p><h4 id="2020年计划"><a href="#2020年计划" class="headerlink" title="2020年计划"></a>2020年计划</h4><ul><li></li><li>挣点小钱，现实需求。</li><li>今年既然有工作在做搜索，图像文件优化，那就索性将它做好一点吧，用上之前了解的知识。ヾ(◍°∇°◍)ﾉﾞ</li><li></li></ul><p>2020.03.20 慕小白 于陕西西安</p>]]></content>
    
    <summary type="html">
    
      2019年已经过去，总结一下。
    
    </summary>
    
      <category term="总结" scheme="https://muxiaobai.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2019" scheme="https://muxiaobai.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之https请求</title>
    <link href="https://muxiaobai.github.io/2020/01/02/SpringBoot%E4%B9%8Bhttps%E8%AF%B7%E6%B1%82/"/>
    <id>https://muxiaobai.github.io/2020/01/02/SpringBoot之https请求/</id>
    <published>2020-01-02T06:26:33.000Z</published>
    <updated>2020-01-02T07:04:58.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias spring -keypass 123456 -keyalg RSA -keysize 1024 -validity 365 -keystore E:/spring.keystore -storepass 123456</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-genkey      在用户主目录中创建一个默认文件&quot;.keystore&quot;,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书</span><br><span class="line">(在没有指定生成位置的情况下,keystore会存在用户系统默认目录，如：对于window xp系统，会生成在系统的C:/Documents and Settings/UserName/文件名为“.keystore”)</span><br><span class="line">-alias       产生别名</span><br><span class="line">-keystore    指定密钥库的名称(产生的各类信息将不在.keystore文件中)</span><br><span class="line">-keyalg      指定密钥的算法 (如 RSA  DSA（如果不指定默认采用DSA）)</span><br><span class="line">-validity    指定创建的证书有效期多少天</span><br><span class="line">-keysize     指定密钥长度</span><br><span class="line">-storepass   指定密钥库的密码(获取keystore信息所需的密码)</span><br><span class="line">-keypass     指定别名条目的密码(私钥的密码)</span><br><span class="line">-dname       指定证书拥有者信息 例如：  &quot;CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名称,ST=州或省份名称,C=单位的两字母国家代码&quot;</span><br><span class="line">-list        显示密钥库中的证书信息      keytool -list -v -keystore 指定keystore -storepass 密码</span><br><span class="line">-v           显示密钥库中的证书详细信息</span><br><span class="line">-export      将别名指定的证书导出到文件  keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码</span><br><span class="line">-file        参数指定导出到文件的文件名</span><br><span class="line">-delete      删除密钥库中某条目          keytool -delete -alias 指定需删除的别  -keystore 指定keystore  -storepass 密码</span><br><span class="line">-printcert   查看导出的证书信息          keytool -printcert -file yushan.crt</span><br><span class="line">-keypasswd   修改密钥库中指定条目口令    keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new  新密码  -storepass keystore密码  -keystore sage</span><br><span class="line">-storepasswd 修改keystore口令      keytool -storepasswd -keystore e:/yushan.keystore(需修改口令的keystore) -storepass 123456(原始密码) -new yushan(新密码)</span><br><span class="line">-import      将已签名数字证书导入密钥库  keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书</span><br></pre></td></tr></table></figure><p>默认参数：</p><p>下面是各选项的缺省值。<br>-alias “mykey”</p><p>-keyalg “DSA”</p><p>-keysize 1024</p><p>-validity 90</p><p>-keystore 用户宿主目录中名为 .keystore 的文件</p><p>-file 读时为标准输入，写时为标准输</p><h2 id="修改yaml配置文件"><a href="#修改yaml配置文件" class="headerlink" title="修改yaml配置文件"></a>修改yaml配置文件</h2><p>把E盘下的spring.keystore证书文件拷贝到项目中的resources目录中 , 然后在application.yml中配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  ssl:</span><br><span class="line">    key-alias: spring</span><br><span class="line">    key-password: 123456</span><br><span class="line">    key-store: classpath:spring.keystore</span><br></pre></td></tr></table></figure></p><p>和生成的证书的参数对应，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8443</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /</span><br><span class="line">  ssl:</span><br><span class="line">    key-store: classpath:spring.keystore</span><br><span class="line">    key-password: 123456</span><br><span class="line">    key-alias: spring</span><br><span class="line">    key-store-type:</span><br><span class="line">    key-store-password:</span><br><span class="line">    key-store-provider:</span><br><span class="line">http:</span><br><span class="line">  port: 8080</span><br></pre></td></tr></table></figure><h2 id="添加http和https同时监听"><a href="#添加http和https同时监听" class="headerlink" title="添加http和https同时监听"></a>添加http和https同时监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.catalina.Context;</span><br><span class="line">import org.apache.catalina.connector.Connector;</span><br><span class="line">import org.apache.tomcat.util.descriptor.web.SecurityCollection;</span><br><span class="line">import org.apache.tomcat.util.descriptor.web.SecurityConstraint;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @date 2020/1/2/002 13:52</span><br><span class="line"> * @TODO Http支持</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class TomcatConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    TomcatServletWebServerFactory tomcatServletWebServerFactory() &#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void postProcessContext(Context context) &#123;</span><br><span class="line">                SecurityConstraint constraint = new SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(&quot;CONFIDENTIAL&quot;);</span><br><span class="line">                SecurityCollection collection = new SecurityCollection();</span><br><span class="line">                collection.addPattern(&quot;/*&quot;);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">    private Connector createTomcatConnector() &#123;</span><br><span class="line">        // 默认协议为 TomcatServletWebServerFactory.DEFAULT_PROTOCOL=org.apache.coyote.http11.Http11NioProtocol</span><br><span class="line">        Connector connector = new</span><br><span class="line">                Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);</span><br><span class="line">        connector.setScheme(&quot;http&quot;);</span><br><span class="line">        connector.setPort(port);</span><br><span class="line">        connector.setSecure(false);</span><br><span class="line">        connector.setRedirectPort(httpsPort);//请求8080转到8443端口</span><br><span class="line">        return connector;</span><br><span class="line">    &#125;</span><br><span class="line">    //8080 请求8080转到8443端口</span><br><span class="line">    @Value(&quot;$&#123;http.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">    </span><br><span class="line">    //8443</span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private Integer httpsPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2020-01-02 14:17:43.303  INFO 10076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine local hostname</span><br><span class="line">2020-01-02 14:17:44.394  INFO 10076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine local hostname</span><br><span class="line">2020-01-02 14:17:44.629  INFO 10076 --- [           main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING</span><br><span class="line">2020-01-02 14:17:44.667  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka in region us-east-1</span><br><span class="line">2020-01-02 14:17:44.719  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON encoding codec LegacyJacksonJson</span><br><span class="line">2020-01-02 14:17:44.720  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON decoding codec LegacyJacksonJson</span><br><span class="line">2020-01-02 14:17:44.873  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML encoding codec XStreamXml</span><br><span class="line">2020-01-02 14:17:44.874  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML decoding codec XStreamXml</span><br><span class="line">2020-01-02 14:17:45.066  INFO 10076 --- [           main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2020-01-02 14:17:45.122  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Disable delta property : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : true</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: true</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br><span class="line">2020-01-02 14:17:45.316  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : The response status is 200</span><br><span class="line">2020-01-02 14:17:45.319  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 10</span><br><span class="line">2020-01-02 14:17:45.322  INFO 10076 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2020-01-02 14:17:45.327  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1577945865325 with initial instances count: 5</span><br><span class="line">2020-01-02 14:17:45.330  INFO 10076 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application APP-SEARCH with eureka with status UP</span><br><span class="line">2020-01-02 14:17:45.330  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1577945865330, current=UP, previous=STARTING]</span><br><span class="line">2020-01-02 14:17:45.333  INFO 10076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APP-SEARCH/192.168.170.1:8443: registering service...</span><br><span class="line">2020-01-02 14:17:45.375  INFO 10076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APP-SEARCH/192.168.170.1:8443 - registration status: 204</span><br><span class="line">2020-01-02 14:17:45.398  INFO 10076 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8443 (https) 8080 (http) with context path &apos;&apos;</span><br></pre></td></tr></table></figure></p><p>最终日志启动监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-01-02 14:17:45.398  INFO 10076 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8443 (https) 8080 (http) with context path &apos;&apos;</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/Smile__1/article/details/99848578" target="_blank" rel="noopener">证书生成</a></li><li><a href="https://blog.csdn.net/qq_36699423/article/details/93481187" target="_blank" rel="noopener">SpringBoot配置同时支持http和https</a></li><li><a href="https://segmentfault.com/a/1190000020052375" target="_blank" rel="noopener">SpringBoot支持https</a></li></ul>]]></content>
    
    <summary type="html">
    
      https和http，实际上和之前我们配置tomcat 的https一个道理
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>tools-需要开启自启动的应用配置</title>
    <link href="https://muxiaobai.github.io/2019/12/26/tools-%E9%9C%80%E8%A6%81%E5%BC%80%E5%90%AF%E8%87%AA%E5%90%AF%E5%8A%A8%E7%9A%84%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://muxiaobai.github.io/2019/12/26/tools-需要开启自启动的应用配置/</id>
    <published>2019-12-26T06:58:37.000Z</published>
    <updated>2019-12-26T07:16:28.208Z</updated>
    
    <content type="html"><![CDATA[<p><code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>每个人对应的目录可能不一致，<br>可以用 win +r  <code>shell:startup</code><br>把需要启动的bat文件创建快捷方式，到此文件夹下<br><img src="/2019/12/26/tools-需要开启自启动的应用配置/自启动目录.png" alt="自启动目录"><br>一开机就启动必须的应用 IDEA VS Code  Chrome CloudMusic,自己写的脚本必须启动的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">echo start </span><br><span class="line"></span><br><span class="line">echo idea START</span><br><span class="line">start /d &quot;E:\Program Files\JetBrains\IntelliJ IDEA 2019.1.2\bin&quot; idea64.exe</span><br><span class="line"></span><br><span class="line">echo VS CODE START</span><br><span class="line">start /d &quot;E:\tools\Microsoft VS Code&quot; code.exe</span><br><span class="line"></span><br><span class="line">echo Chrome START</span><br><span class="line">start /d &quot;C:\Program Files (x86)\Google\Chrome\Application&quot; chrome.exe</span><br><span class="line"></span><br><span class="line">echo cloudmusic START</span><br><span class="line">start /d &quot;C:\Program Files (x86)\Netease\CloudMusic&quot; cloudmusic.exe</span><br><span class="line"></span><br><span class="line">echo javaw START</span><br><span class="line">start /d  &quot;E:\workspace\idea\cloud\&quot; taskrunjavaw.bat</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>切换到对应目录然后执行exe</p><p>taskrunjavaw.bat 中是需要启动的平台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">start javaw -jar ./app-core/app-register/target/app-register-0.0.1.jar   &amp;</span><br><span class="line">ping -n 8 127.0.0.1 1&gt;null</span><br><span class="line">rem 等待8秒</span><br><span class="line">echo &quot;app-register&quot;</span><br><span class="line">start javaw -jar ./app-core/app-config/target/app-config-0.0.1.jar &amp;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p><p>对于一些不经常变动的，定式启动内容可以如此处理。</p>]]></content>
    
    <summary type="html">
    
      每一次开机都要开启很多软件，在这里就找到解决办法，晚上可以关机，早上可以开机，然后就可以去接开水喝了，静待启动。
    
    </summary>
    
      <category term="工具" scheme="https://muxiaobai.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>devops之jenkins持续集成</title>
    <link href="https://muxiaobai.github.io/2019/12/21/devops%E4%B9%8Bjenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://muxiaobai.github.io/2019/12/21/devops之jenkins持续集成/</id>
    <published>2019-12-21T05:28:29.000Z</published>
    <updated>2019-12-23T05:12:50.045Z</updated>
    
    <content type="html"><![CDATA[<p>分两步走，第一安装，第二配置</p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000 /root/jenkins_home</span><br><span class="line">chmod 777 /var/run/docker.sock</span><br></pre></td></tr></table></figure><h2 id="docker-创建jenkins工具持续集成"><a href="#docker-创建jenkins工具持续集成" class="headerlink" title="docker 创建jenkins工具持续集成"></a>docker 创建jenkins工具持续集成</h2><p>拉取镜像 <code>docker pulljenkins/jenkins</code></p><p>8080映射到16000 5000映射到16001端口<br>创建容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name jenkins -p 16000:8080 -p 16001:50000 \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v $(which docker):/bin/docker \</span><br><span class="line">    -v /root/jenkins_home:/var/jenkins_home \</span><br><span class="line">    -d jenkins/jenkins</span><br></pre></td></tr></table></figure><ul><li>/root/jenkins_home 为jenkins工作空间，包括插件maven，git工具等</li><li>需要在shell中使用宿主机的docker命令</li></ul><p>删除容器：<code>docker rm -f jenkins</code></p><p>下面的创建，添加了本地执行shell挂载卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -d -p 16000:8080 -p 16001:50000 \</span><br><span class="line">    -v /opt/demo/:/opt/demo \</span><br><span class="line">    -v /root/jenkins_home/:/var/jenkins_home \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v $(which docker):/usr/bin/docker \</span><br><span class="line">    -v $(which git):/usr/bin/git \</span><br><span class="line">    -v ~/.ssh:/var/jenkins_home/.ssh \</span><br><span class="line">    --name=jenkins jenkins/jenkins</span><br></pre></td></tr></table></figure><p>挂载：其中/opt/demo 为命令执行空间</p><p>访问 <a href="http://ip:16000" target="_blank" rel="noopener">http://ip:16000</a></p><p>以上 安装完成</p><p>参考<a href="https://www.cnblogs.com/stulzq/p/8627360.html" target="_blank" rel="noopener">jenkins安装</a></p><h2 id="构建集成配置"><a href="#构建集成配置" class="headerlink" title="构建集成配置"></a>构建集成配置</h2><p>需要以下工具     </p><ul><li>Git plugin 源码地址</li><li>Maven Integration plugin   构建工具</li><li>Publish Over SSH 远程发布</li></ul><p><code>/root/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation</code>在这个文件夹下会有maven工具支持构建</p><p>新建项目选择maven,需要安装maven 工具<br><img src="/2019/12/21/devops之jenkins持续集成/pom.png" alt="maven"></p><h3 id="配置源码仓库"><a href="#配置源码仓库" class="headerlink" title="配置源码仓库"></a>配置源码仓库</h3><p>配置git地址，分支<code>refs/heads/dev</code></p><p><img src="/2019/12/21/devops之jenkins持续集成/gitsource.png" alt="源码配置"></p><h3 id="配置触发器"><a href="#配置触发器" class="headerlink" title="配置触发器"></a>配置触发器</h3><h4 id="github-hook"><a href="#github-hook" class="headerlink" title="github hook"></a>github hook</h4><p><img src="/2019/12/21/devops之jenkins持续集成/githubhook.png" alt="github hook"><br>只用把github勾选<br><img src="/2019/12/21/devops之jenkins持续集成/配置触发器.png" alt="配置触发器"></p><h4 id="gitlab配置"><a href="#gitlab配置" class="headerlink" title="gitlab配置"></a>gitlab配置</h4><p>Accepted Merge Requests Events 接受合并分支时，触发<br><img src="/2019/12/21/devops之jenkins持续集成/webhook.png" alt="配置jenkins合并触发"><br>出现<code>Url is blocked: Requests to the local network are not allowed</code> 问题，需要在系统管理员处配置：<br><img src="/2019/12/21/devops之jenkins持续集成/gitlab配置1.png" alt="配置gitlabwebhook"><br>合并分支时候调用hook地址<br><img src="/2019/12/21/devops之jenkins持续集成/gitlab配置2.png" alt="配置gitlab"></p><h3 id="配置-Build"><a href="#配置-Build" class="headerlink" title="配置 Build"></a>配置 Build</h3><p>pom.xml<br>clean package<br><img src="/2019/12/21/devops之jenkins持续集成/bulid.png" alt="build"></p><h3 id="配置Post-Steps"><a href="#配置Post-Steps" class="headerlink" title="配置Post Steps"></a>配置Post Steps</h3><h4 id="本机发布执行shell"><a href="#本机发布执行shell" class="headerlink" title="本机发布执行shell"></a>本机发布执行shell</h4><p>shell脚本</p><p><img src="/2019/12/21/devops之jenkins持续集成/shell.png" alt="本地shell"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">WORK_DIR=/opt/demo/package</span><br><span class="line">PROJECT_NAME=app-demo</span><br><span class="line">PROJECT_VERSION=0.0.1</span><br><span class="line">echo `pwd`</span><br><span class="line">docker ps -a </span><br><span class="line">#  判断工作目录是否存在</span><br><span class="line">if [ ! -e $&#123;WORK_DIR&#125; ] &amp;&amp; [ ! -d $&#123;WORK_DIR&#125; ]; then</span><br><span class="line">    mkdir -p $&#123;WORK_DIR&#125;</span><br><span class="line">    echo &quot;Create Dir: $&#123;WORK_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Dockerfile存在 删除</span><br><span class="line">if [ -e $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile ]; then</span><br><span class="line">    rm -rf $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile</span><br><span class="line">    echo &quot;Remove File: $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile&quot;</span><br><span class="line">fi</span><br><span class="line"># 如果容器已经启动，移除</span><br><span class="line">if docker ps -a | grep $&#123;PROJECT_NAME&#125;; then</span><br><span class="line">    docker rm -f $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;</span><br><span class="line">    docker rmi -f $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;</span><br><span class="line">    echo &quot;Remove Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 拷贝jar包到工作目录 jar是通过maven pom.xml 生成的</span><br><span class="line">cp ./target/*.jar $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/ </span><br><span class="line"># 拷贝Dockerfile到工作目录 是提前编写在git项目内</span><br><span class="line">cp ./Dockerfile $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/</span><br><span class="line"></span><br><span class="line"># 开始构建镜像</span><br><span class="line"># 进入工作目录</span><br><span class="line">cd $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/</span><br><span class="line"># 构建镜像 在个工作目录，依据当前目录创建镜像</span><br><span class="line"># docker build -t $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125; .</span><br><span class="line"># 推送镜像</span><br><span class="line"># docker push $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125;</span><br><span class="line"></span><br><span class="line">#  启动容器</span><br><span class="line"># docker run -d -p 18000:8761 --name $&#123;PROJECT_NAME&#125; $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125;</span><br><span class="line"></span><br><span class="line">#dockerstart.sh 为便捷构建容器启动容器脚本</span><br><span class="line">#cd $&#123;WORK_DIR&#125;</span><br><span class="line">#sh ../shell/dockerstart.sh $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; /opt/demo/package/ 18000</span><br><span class="line"></span><br><span class="line">#判断容器启动成功</span><br><span class="line">if docker ps  | grep $&#123;PROJECT_NAME&#125;; then</span><br><span class="line">    echo &quot;Start Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; Success&quot;</span><br><span class="line">else </span><br><span class="line">    echo &quot;Start Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; Error&quot;</span><br><span class="line">    return 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="远程发布SSH-Publishers"><a href="#远程发布SSH-Publishers" class="headerlink" title="远程发布SSH Publishers"></a>远程发布SSH Publishers</h4><p>配置插件如果要进行远程发布，需要插件</p><p>先在系统全局配置中配置以下ssh<br><img src="/2019/12/21/devops之jenkins持续集成/配置ssh.png" alt="配置"><br><img src="/2019/12/21/devops之jenkins持续集成/SSHpublisher.png" alt="远程发布"></p><p><a href="https://blog.csdn.net/Denny2333/article/details/88037413" target="_blank" rel="noopener">配置构建项目</a></p>]]></content>
    
    <summary type="html">
    
      通过docker安装jenkins，发布springboot项目
    
    </summary>
    
      <category term="devops" scheme="https://muxiaobai.github.io/categories/devops/"/>
    
    
      <category term="devops" scheme="https://muxiaobai.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之AQS和应用</title>
    <link href="https://muxiaobai.github.io/2019/10/31/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8BAQS%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <id>https://muxiaobai.github.io/2019/10/31/Thinking-in-java-基础之AQS和应用/</id>
    <published>2019-10-31T05:12:44.000Z</published>
    <updated>2019-11-07T01:48:20.595Z</updated>
    
    <content type="html"><![CDATA[<p>使用锁的时候我们直接<code>ReentrantLock lock = new ReentrantLock();lock.lock();</code>,这中间究竟有什么内容,<br>lock的时候，其它线程为什么不能执行，unlook()的时候其它的线程究竟从哪个线程能执行？本文主要分析lock的各种情况。</p><h2 id="j-u-c-locks-AbstractQueuedSynchronizer"><a href="#j-u-c-locks-AbstractQueuedSynchronizer" class="headerlink" title="j.u.c.locks.AbstractQueuedSynchronizer"></a>j.u.c.locks.AbstractQueuedSynchronizer</h2><p>有共享和独占两种状态，SHARE，EXCLUSIVE 这两个在AQS中对应两个Node节点{state:1,thread:Thread.CurrentThread()},节点里面的内容。<br>从名字里面就能知道，共享锁，每一个线程来都可以拿到锁，简单的来说，就是可以运行lock和unlock内的代码，独占锁，一个线程lock，其它线程必须等到unlock之后，再去抢占锁。</p><blockquote><p>排队接水喝，我的杯子放在这里，当前这个饮水机就我能用。其它人来了，不好意思，排队。</p></blockquote><p>至于怎么抢占，又分为公平锁，和非公平锁，公平锁：先来后到，非公平：随机获取。</p><blockquote><p>排队接水喝， 先后顺序，公平，来了个领导，他先接水，不公平，但合理。</p></blockquote><p>AbstractOwnableSynchronizer</p><p><img src="/2019/10/31/Thinking-in-java-基础之AQS和应用/state.png" alt="图"><br>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p><p>资源state使用volatile标识，保证所有的线程来的时候都是确定的值。详细查看<a href>volatile</a>，其它线程在队列里。</p><p>protected boolean tryAcquire(int arg) : 独占式获取同步状态，试着获取，成功返回true，反之为false<br>protected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；<br>protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；<br>protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为false<br>protected boolean isHeldExclusively() ： 是否在独占模式下被线程占用。</p><h2 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch 倒计时器"></a>CountDownLatch 倒计时器</h2><p>它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行</p><p>CountDownLatch，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h2><p>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. (CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源,可以指定多个线程同时访问某个资源</p><h2 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock 重入锁"></a>ReentrantLock 重入锁</h2><blockquote><p>排队接水喝，水杯太大，杯子放着接，我先干别的事，干完了回来，直接就能拿杯子，重入。</p></blockquote><p>ReentrantLock，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><h2 id="tomcat的-LimitLatch"><a href="#tomcat的-LimitLatch" class="headerlink" title="tomcat的 LimitLatch"></a>tomcat的 LimitLatch</h2><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">Java并发包基石-AQS详解</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md#41-countdownlatch-%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">JavaGuide</a></li></ul>]]></content>
    
    <summary type="html">
    
      jdk的juc中的AQS和应用，各种锁的比较
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
      <category term="Thread" scheme="https://muxiaobai.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之类加载顺序&amp;初始化</title>
    <link href="https://muxiaobai.github.io/2019/10/21/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://muxiaobai.github.io/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/</id>
    <published>2019-10-21T07:25:42.000Z</published>
    <updated>2019-10-22T02:06:04.356Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先来一个题"><a href="#先来一个题" class="headerlink" title="先来一个题"></a>先来一个题</h4><p>FatherClass:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class FatherClass &#123;</span><br><span class="line">    public  static  int F_NUM = 1111;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    FatherClass()&#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">        F_NUM = 5555;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SonClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SonClass  extends  FatherClass&#123;</span><br><span class="line">    public  static  int S_NUM = 2222;</span><br><span class="line">    static &#123;</span><br><span class="line">        F_NUM = 3333;</span><br><span class="line">        System.out.println(S_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        S_NUM = 4444;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里是一个大坑，没有无参的构造方法，所以newInstance的时候会报错</span><br><span class="line">    SonClass(int inNUM)&#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LoaderOrder &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">//        testClassLoad();</span><br><span class="line">        testClassForName();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void testClassLoad() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class clazz =LoaderOrder.class.getClassLoader().loadClass(&quot;io.github.muxiaobai.spring_my_demo.loadClass.SonClass&quot;);</span><br><span class="line">        System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">        System.out.println(&quot;===========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void testClassForName() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class clazz =Class.forName(&quot;io.github.muxiaobai.spring_my_demo.loadClass.SonClass&quot;);</span><br><span class="line">        System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">        System.out.println(&quot;===========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ClassLoad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InstantiationException: io.github.muxiaobai.spring_my_demo.loadClass.SonClass</span><br><span class="line">at java.lang.Class.newInstance(Class.java:427)</span><br></pre></td></tr></table></figure></p><p>使用Class.forName();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">---------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InstantiationException: io.github.muxiaobai.spring_my_demo.loadClass.SonClass</span><br></pre></td></tr></table></figure><p>链接：static成员变量，附初始值。0,null,false,</p><p>初始化做了那些事情？显性的：static语句块，执行到实例化的时候没有无参的构造函数，因此父类和子类都没有实例化。</p><p>没有完成类的初始化，无法访问类成员</p><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/Class初始化.png" alt="初始化"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="java对象，获取"><a href="#java对象，获取" class="headerlink" title="java对象，获取"></a>java对象，获取</h5><ul><li>new </li><li>反射</li><li>反序列化</li><li>克隆</li></ul><h5 id="Class对象获取"><a href="#Class对象获取" class="headerlink" title="Class对象获取"></a>Class对象获取</h5><ul><li>类名.class</li><li>实例.getClass()</li><li>classloader.loadClass(“包.类”)</li><li>Class.forName(“包.类”);</li></ul><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/获取Class四种方式.PNG" alt="初始化"></p><p>jvm加载步骤：加载——链接（验证，准备，解析）———–初始化</p><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/Class初始化时机.png" alt="初始化"></p><p>两种，实际上是识别到字节码指令:new，putstatic,getstatic,invokestatic,<br>反射</p><p>根据Java虚拟机的规范，只有5中情况属于主动引用：</p><ul><li><p>遇到new（使用new 关键字实例化一个对象）、getstatic（读取一个类的静态字段）、putstatic或者invokestatic（设置一个类的静态字段）这4条指令的时候，如果累没有进行过初始化。则需要先触发其初始化。</p></li><li><p>使用反射进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果其父类没有初始化，则需要先触发其父类的初始化</p></li><li><p>程序启动需要触发main方法的时候，虚拟机会先触发这个类的初始化</p></li><li><p>当使用jdk1.7的动态语言支持的时候，如果一个java.lang.invoke.MethodHandler实例最后的解析结果为REF_getStatic、REF_pusStatic、REF_invokeStatic的方法句柄（句柄中包含了对象的实例数据和类型数据，句柄是访问对象的一种方法。句柄存储在堆中），并且句柄对应的类没有被初始化，那么需要先触发这个类的初始化。</p></li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><a href="https://www.cnblogs.com/shyroke/p/9161603.html" target="_blank" rel="noopener">类加载机制和类的加载、连接（验证、准备、解析）和初始化</a></li></ul>]]></content>
    
    <summary type="html">
    
      类加载过程
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之HashMap</title>
    <link href="https://muxiaobai.github.io/2019/10/17/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8BHashMap/"/>
    <id>https://muxiaobai.github.io/2019/10/17/Thinking-in-java-基础之HashMap/</id>
    <published>2019-10-17T13:13:12.000Z</published>
    <updated>2019-10-18T06:08:58.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的put引发的惨案"><a href="#一个简单的put引发的惨案" class="headerlink" title="一个简单的put引发的惨案"></a>一个简单的put引发的惨案</h2><pre><code>版本 jdk1.8Map hashMap = new HashMap&lt;String,String&gt;();hashMap.put(&quot;abc&quot;,&quot;1&quot;);一个简单的put</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Associates the specified value with the specified key in this map.</span><br><span class="line"> * If the map previously contained a mapping for the key, the old</span><br><span class="line"> * value is replaced.</span><br><span class="line"> *</span><br><span class="line"> * @param key key with which the specified value is to be associated</span><br><span class="line"> * @param value value to be associated with the specified key</span><br><span class="line"> * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="line"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><br><span class="line"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><br><span class="line"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><br><span class="line"> */</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="怎么进行hash"><a href="#怎么进行hash" class="headerlink" title="怎么进行hash"></a>怎么进行hash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Computes key.hashCode() and spreads (XORs) higher bits of hash</span><br><span class="line">    * to lower.  Because the table uses power-of-two masking, sets of</span><br><span class="line">    * hashes that vary only in bits above the current mask will</span><br><span class="line">    * always collide. (Among known examples are sets of Float keys</span><br><span class="line">    * holding consecutive whole numbers in small tables.)  So we</span><br><span class="line">    * apply a transform that spreads the impact of higher bits</span><br><span class="line">    * downward. There is a tradeoff between speed, utility, and</span><br><span class="line">    * quality of bit-spreading. Because many common sets of hashes</span><br><span class="line">    * are already reasonably distributed (so don&apos;t benefit from</span><br><span class="line">    * spreading), and because we use trees to handle large sets of</span><br><span class="line">    * collisions in bins, we just XOR some shifted bits in the</span><br><span class="line">    * cheapest possible way to reduce systematic lossage, as well as</span><br><span class="line">    * to incorporate impact of the highest bits that would otherwise</span><br><span class="line">    * never be used in index calculations because of table bounds.</span><br><span class="line">    */</span><br><span class="line">   static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>key可以为null ，返回0，直接落在第一个坑位上。</p><blockquote><p>解释了key可以为null<br>Object.hashCode();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure></p></blockquote><p>以String举例<br>String.hashCode();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns a hash code for this string. The hash code for a</span><br><span class="line">    * &#123;@code String&#125; object is computed as</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br><span class="line">    * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    * using &#123;@code int&#125; arithmetic, where &#123;@code s[i]&#125; is the</span><br><span class="line">    * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;@code n&#125; is the length of</span><br><span class="line">    * the string, and &#123;@code ^&#125; indicates exponentiation.</span><br><span class="line">    * (The hash value of the empty string is zero.)</span><br><span class="line">    *</span><br><span class="line">    * @return  a hash code value for this object.</span><br><span class="line">    */</span><br><span class="line">   public int hashCode() &#123;</span><br><span class="line">       int h = hash;</span><br><span class="line">       if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">           char val[] = value;</span><br><span class="line"></span><br><span class="line">           for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">               h = 31 * h + val[i];</span><br><span class="line">           &#125;</span><br><span class="line">           hash = h;</span><br><span class="line">       &#125;</span><br><span class="line">       return h;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;abc&quot;.hashCode());//96354</span><br><span class="line">System.out.println(97*31*31 + 98*31+99);//96354</span><br></pre></td></tr></table></figure></p><blockquote><p>s[0]<em>31^(n-1) + s[1]</em>31^(n-2) + … + s[n-1]</p></blockquote><p>String的hash算法,那么HashMap中的hash(),<br><code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code><br>“abc”进行转hashCode()之后就是96354，然后变成二进制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h&gt;&gt;&gt;16   h^(h&gt;&gt;&gt;16)</span><br><span class="line">那么就是（前面补0）</span><br><span class="line">96354       0000 0000 0000 0001 0111 1000 0110 0010  低16位</span><br><span class="line">h&gt;&gt;&gt;16      0000 0000 0000 0000 0000 0000 0000 0001  高16位</span><br><span class="line">^--------------------------------------------------</span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011  </span><br><span class="line"></span><br><span class="line">最终得到96355</span><br></pre></td></tr></table></figure></p><p>高16位与低16位</p><p>结果验证<br><img src="/2019/10/17/Thinking-in-java-基础之HashMap/hash.png" alt="hash运行时"></p><p>然后下一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Implements Map.put and related methods</span><br><span class="line">     *</span><br><span class="line">     * @param hash hash for key</span><br><span class="line">     * @param key the key</span><br><span class="line">     * @param value the value to put</span><br><span class="line">     * @param onlyIfAbsent if true, don&apos;t change existing value</span><br><span class="line">     * @param evict if false, the table is in creation mode.</span><br><span class="line">     * @return previous value, or null if none</span><br><span class="line">     */</span><br><span class="line">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="没有数组"><a href="#没有数组" class="headerlink" title="没有数组"></a>没有数组</h4><p>看内部的如果table是空的创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">           n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></p><p>resize()把table创建好了，同时把tab.length赋给n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Initializes or doubles table size.  If null, allocates in</span><br><span class="line">   * accord with initial capacity target held in field threshold.</span><br><span class="line">   * Otherwise, because we are using power-of-two expansion, the</span><br><span class="line">   * elements from each bin must either stay at same index, or move</span><br><span class="line">   * with a power of two offset in the new table.</span><br><span class="line">   *</span><br><span class="line">   * @return the table</span><br><span class="line">   */</span><br><span class="line">  final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int oldThr = threshold;</span><br><span class="line">      int newCap, newThr = 0;</span><br><span class="line">      if (oldCap &gt; 0) &#123;</span><br><span class="line">          if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              return oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">      &#125;</span><br><span class="line">      else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      else &#123;               // zero initial threshold signifies using defaults 这里是初始化的时候，放容量Cap=16和最多放几个开始扩容负载因子Thr = 0.75*16 = 12，</span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (newThr == 0) &#123;</span><br><span class="line">          float ft = (float)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">      //创建一个newCap容量大小的数组，然后赋给table</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      //以下内容为把原来的Node放到新的Node中，先放一下，后面在扩容判定位置的时候再研究</span><br><span class="line">      if (oldTab != null) &#123;</span><br><span class="line">          ...</span><br><span class="line">          ...</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      return newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>先看新建的，不看扩容的。知道table是个newCap大小的数组</p><p><img src="/2019/10/17/Thinking-in-java-基础之HashMap/resize.png" alt="hash运行时"></p><h4 id="数组对应的位置为空"><a href="#数组对应的位置为空" class="headerlink" title="数组对应的位置为空"></a>数组对应的位置为空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">           tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure><p>有了数组，怎么计算放在哪一个数组上，<code>(n - 1) &amp; hash]</code>,这个位置上如果为空，那么tab的i上就放当前的Node&lt;K,V&gt;;当前的n就是tab.length = 16<br>算一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">刚才abc的hash值是96355</span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011   96355</span><br><span class="line">16-1        0000 0000 0000 0000 0000 0000 0000 1111   15</span><br><span class="line">&amp;-------------------------------------------------- 保证所有的值都落在tab之内</span><br><span class="line">(n-1)hash   0000 0000 0000 0000 0000 0000 0000 0011   3</span><br><span class="line"></span><br><span class="line">然后看tab[3]上是否为null,为空直接赋值在这里</span><br><span class="line">然后tab[3] =  Node&lt;&gt;(hash, key, value, next);//Node&lt;&gt;(96355，&quot;abc&quot;,&quot;1&quot;,null)</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/17/Thinking-in-java-基础之HashMap/tab[i].png" alt="hash运行时"></p><h4 id="数组对应的位置不为空，跟链表，超过TREEIFY-THRESHOLD时，当前hash对应的位置转为treeifyBin"><a href="#数组对应的位置不为空，跟链表，超过TREEIFY-THRESHOLD时，当前hash对应的位置转为treeifyBin" class="headerlink" title="数组对应的位置不为空，跟链表，超过TREEIFY_THRESHOLD时，当前hash对应的位置转为treeifyBin"></a>数组对应的位置不为空，跟链表，超过TREEIFY_THRESHOLD时，当前hash对应的位置转为treeifyBin</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line">if (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure><p>判断key是不是一样的，如果是一样的，直接替换前面的Node，</p><blockquote><p>解释了 为什么key可以为null，但key一样的话不能重复</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    //没有条件的一直循环，在内部break，</span><br><span class="line">    for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        if ((e = p.next) == null) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, null);</span><br><span class="line">            //当前容量大于8-1 = 7 的时候进行转为红黑树</span><br><span class="line">            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            break;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前hash对应的位置转TreeNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="line">     * table is too small, in which case resizes instead.</span><br><span class="line">     */</span><br><span class="line">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        //如果tab数组小于MIN_TREEIFY_CAPACITY=64重新调整大小</span><br><span class="line">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">                if (tl == null)</span><br><span class="line">                    hd = p;</span><br><span class="line">                else &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">            if ((tab[index] = hd) != null)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="数组对应的位置不为空，跟红黑树"><a href="#数组对应的位置不为空，跟红黑树" class="headerlink" title="数组对应的位置不为空，跟红黑树"></a>数组对应的位置不为空，跟红黑树</h4><p>直接调用TreeNode的putTreeVal()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></pre></td></tr></table></figure></p><p>里面对应的旋转啊，啥子的，一堆。</p><h4 id="超过最大值，要进行扩容"><a href="#超过最大值，要进行扩容" class="headerlink" title="超过最大值，要进行扩容"></a>超过最大值，要进行扩容</h4><p>当大小超过threshold=DEFAULT_LOAD_FACTOR <em> DEFAULT_INITIAL_CAPACITY= 0.75</em>16=12重新resize()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br></pre></td></tr></table></figure></p><p>resize(),扩容的时候MAXIMUM_CAPACITY=1&lt;&lt;30<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    threshold = Integer.MAX_VALUE;//最大值</span><br><span class="line">    return oldTab;</span><br><span class="line">&#125;</span><br><span class="line">//不到最大值，新的容量newCap为原来的左移一位 oldThr&lt;&lt;1, 两倍的容量</span><br><span class="line">else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">            oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    //newThr 为12&lt;&lt;1 为 24</span><br></pre></td></tr></table></figure></p><h4 id="扩容怎么判定原来的位置，怎么移动"><a href="#扩容怎么判定原来的位置，怎么移动" class="headerlink" title="扩容怎么判定原来的位置，怎么移动"></a>扩容怎么判定原来的位置，怎么移动</h4><p>上面扩容省略的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">            oldTab[j] = null;</span><br><span class="line">            //没有next 说明只有一个Node直接在table数组中直接移动</span><br><span class="line">            if (e.next == null)</span><br><span class="line">                newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">            //是树的情况</span><br><span class="line">            else if (e instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">            else &#123; // preserve order 顺序的模式链表</span><br><span class="line">                Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                do &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    //hash与oldCap容量如果等于0 则还在原来的坑位，</span><br><span class="line">                    if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                        if (loTail == null)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        else</span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //在新的坑位</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (hiTail == null)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        else</span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while ((e = next) != null);</span><br><span class="line">                if (loTail != null) &#123;</span><br><span class="line">                    loTail.next = null;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                if (hiTail != null) &#123;</span><br><span class="line">                    hiTail.next = null;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</code>中有一段，当小于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">    tab[index] = loHead.untreeify(map);</span><br><span class="line">else &#123;</span><br><span class="line">    tab[index] = loHead;</span><br><span class="line">    if (hiHead != null) // (else is already treeified)</span><br><span class="line">        loHead.treeify(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经把原来各个节点Node移动到新的数组中，当小于UNTREEIFY_THRESHOLD=6时，转为链表</p><p>链表的情况<code>(e.hash &amp; oldCap) == 0</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">刚才abc的hash值是96355</span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011   96355</span><br><span class="line">16=oldCap   0000 0000 0000 0000 0000 0000 0001 0000   16</span><br><span class="line">&amp;-------------------------------------------------- 保证所有的值都落在tab之内</span><br><span class="line">hash&amp;oldCap 0000 0000 0000 0000 0000 0000 0000 0000   0</span><br><span class="line"></span><br><span class="line">等于0 还在原来的位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011</span><br><span class="line">16扩32      0000 0000 0000 0000 0000 0000 0001 1111</span><br><span class="line">&amp;-------------------------------------------------- 保证所有的值都落在tab之内</span><br><span class="line">hash&amp;oldCap 0000 0000 0000 0000 0000 0000 0000 0011   3</span><br><span class="line"></span><br><span class="line">如果不是0的话则在 16+3的位置</span><br></pre></td></tr></table></figure></p><p>线程不安全</p><h4 id="ConCurrentHashMap是怎么加锁的"><a href="#ConCurrentHashMap是怎么加锁的" class="headerlink" title="ConCurrentHashMap是怎么加锁的"></a>ConCurrentHashMap是怎么加锁的</h4><p>ConcurrentHashMap 中的key和value都不能为空，会抛出NullPointerException<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">           //初始化要考虑多线程</span><br><span class="line">               tab = initTable();</span><br><span class="line">               //tabAt,getObjectVolatile native线程安全</span><br><span class="line">           else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">               //使用cas，为空的时候U.compareAndSwapObject,比较交换，使用native 线程安全</span><br><span class="line">               if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                   break;                   // no lock when adding to empty bin</span><br><span class="line">           &#125;</span><br><span class="line">           else if ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           else &#123;</span><br><span class="line">               V oldVal = null;</span><br><span class="line">               //直接锁数组上的Node</span><br><span class="line">               //put数据的时候，在同一个数组下标下，锁，保证安全</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      ...</span><br><span class="line">                      ...</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (binCount != 0) &#123;</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   if (oldVal != null)</span><br><span class="line">                       return oldVal;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //扩容要考虑其它线程</span><br><span class="line">       addCount(1L, binCount);</span><br><span class="line">       return null;</span><br></pre></td></tr></table></figure></p><h4 id="对比HashTable直接在方法上进行加锁，锁this"><a href="#对比HashTable直接在方法上进行加锁，锁this" class="headerlink" title="对比HashTable直接在方法上进行加锁，锁this"></a>对比HashTable直接在方法上进行加锁，锁this</h4><p>Hashtable上的put<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null 不能为空</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">        // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();//不能为空</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br></pre></td></tr></table></figure></p><blockquote><p>Hashtable中的value不能为空，抛出异常NullPointerException；key不能为空，因为null不能获取hashcode();</p></blockquote><p>这种特性，在分析源码的时候就直接出来的，不用背的，不用背的。</p>]]></content>
    
    <summary type="html">
    
      从map.put()说起，所有的相关内容
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之volatile</title>
    <link href="https://muxiaobai.github.io/2019/10/12/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8Bvolatile/"/>
    <id>https://muxiaobai.github.io/2019/10/12/Thinking-in-java-基础之volatile/</id>
    <published>2019-10-12T02:41:58.000Z</published>
    <updated>2019-10-21T08:34:22.720Z</updated>
    
    <content type="html"><![CDATA[<p>显性的作用就是： 这个变量在修改之后，可以及时更新到另外一个线程。</p><h3 id="两个代码"><a href="#两个代码" class="headerlink" title="两个代码"></a>两个代码</h3><p>无volatile<br><img src="/2019/10/12/Thinking-in-java-基础之volatile/1.png" alt="无volatile"></p><p>有volatile<br><img src="/2019/10/12/Thinking-in-java-基础之volatile/1.png" alt="有volatile"></p><p>看一下汇编是啥样子的</p><p><a href="https://sourceforge.net/projects/fcml/files/fcml-1.1.1/hsdis-1.1.1-win32-amd64.zip/download" target="_blank" rel="noopener">下载</a><br>hsdis-1.1.1-win32-amd64.zip放到${JAVA_HOME}\jdk1.8.0_171\jre\bin\server下,先<code>javac xxx.java</code> 编译成xxx.class<br><code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly  xxx.class &gt;a.txt</code><br>生成汇编文件<br>给jvm添加参数<br><code>-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*Test.getInstance</code></p><p><img src="/2019/10/12/Thinking-in-java-基础之volatile/3.png" alt="汇编"><br>在修改有volatile修饰的属性，加有lock add第八行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static volatile boolean stop = false ;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(()-&gt;&#123;</span><br><span class="line">            int i=0;</span><br><span class="line">            while (!stop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(&quot;begin start thread&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁提供了原子性和可见性<br>volatile具有锁的可见性，</p><p>指令重排序（本是为了优化代码，对最终的结果无影响）</p><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;              </span><br><span class="line">boolean flag = false;</span><br><span class="line">i = 1;                //语句1  </span><br><span class="line">flag = true;          //语句2</span><br></pre></td></tr></table></figure></p><p>从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序:"></a>指令重排序:</h2><p>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？靠的是数据依赖性：</p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。</p><p>内存屏障有两个作用：</p><ul><li>1.阻止屏障两侧的指令重排序；</li><li>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li></ul><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；<br>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。<br>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><p>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</p><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</li></ul><p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p><p><img src="/2019/10/12/Thinking-in-java-基础之volatile/L0.png" alt="CPU三级缓存架构图"></p><p>因为CPU高速运转，直接读内存会很慢，又开辟一级二级三级缓存，多核CPU下每一个有独立的一级二级缓存；如果现在来了一个数据存在三级缓存中，第一个Thread读取之后，并修改了值，但没有同步到三级缓存中；这时候第二个线程要读值，他还是只从三级缓存中读取内容，；但有了内存屏障，在第三个读的时候，</p><p>从.java———–&gt;.class编译完成，然后.class 在不同的平台上，对于volatile来说，JVM有不同的实现，一次编写，到处运行<code>Write once, run anywhere</code>,JVM屏蔽各种架构的指令集，例如x86 MMX，SSE等，在window系统上使用window指令，在linux上使用linux指令，最终Java实现了，程序员不用关系各个平台的差异。<br>但对于.net ，需要安装其他的中间件等，才能在非window系统运行。</p><p><img src="/2019/10/12/Thinking-in-java-基础之volatile/CPU.PNG" alt="总结适配器模式"></p><p><a href="https://mrbird.cc/Java-Memory-model.html#more" target="_blank" rel="noopener">参考Java 内存模型</a></p>]]></content>
    
    <summary type="html">
    
      从volatile到内存屏障
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java-常用代码2-future等</title>
    <link href="https://muxiaobai.github.io/2019/09/29/java-%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812-future%E7%AD%89/"/>
    <id>https://muxiaobai.github.io/2019/09/29/java-常用代码2-future等/</id>
    <published>2019-09-29T12:33:32.000Z</published>
    <updated>2019-09-30T05:44:46.600Z</updated>
    
    <content type="html"><![CDATA[<p>远程调用可以合并 10ms执行一次。阻塞队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class DemoMoreService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RemoteServiceCall remoteCall;</span><br><span class="line">    //阻塞队列</span><br><span class="line">    LinkedBlockingQueue&lt;Request&gt; queue = new LinkedBlockingQueue&lt;Request&gt;();</span><br><span class="line">    </span><br><span class="line">    public Map&lt;String, Object&gt; doRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">        </span><br><span class="line">        Request request = new Request();</span><br><span class="line">        request.orderCode = orderCode;</span><br><span class="line">        //jdk1.8</span><br><span class="line">        CompletableFuture&lt;Map&lt;String, Object&gt;&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class="line">        request.future = future;</span><br><span class="line">        //队列中</span><br><span class="line">        queue.add(request);</span><br><span class="line">        return future.get();//阻塞状态</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 定时任务 初始化执行</span><br><span class="line">     * init:(). servlet init方法之前调用这个注解的方法，只会被调用一次</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        //定时任务两个线程数</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService =Executors.newScheduledThreadPool(2);</span><br><span class="line">       </span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">           </span><br><span class="line">            //run</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            if(size == 0)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //弹出Request</span><br><span class="line">            List&lt;Request&gt; requests = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=0; i&lt;size;i++)&#123;</span><br><span class="line">                Request request = queue.poll();//出队列</span><br><span class="line">                requests.add(request);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            System.out.println(&quot;10ms 取到的本地请求数：&quot;+size);</span><br><span class="line">            </span><br><span class="line">            //循环requests分离orderCode和future</span><br><span class="line">            List&lt;String&gt; orderCodes = new ArrayList&lt;&gt;();</span><br><span class="line">            for(Request request :requests)&#123;</span><br><span class="line">                orderCodes.add(request.orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //查询返回结果</span><br><span class="line">            List&lt;Map&lt;String,Object&gt;&gt; responses=remoteCall.getMore(orderCodes);</span><br><span class="line">            System.out.println(responses);</span><br><span class="line">            //分离返回内容</span><br><span class="line">            Map&lt;String,Map&lt;String,Object&gt;&gt;  responseMap = new HashMap&lt;&gt;(); </span><br><span class="line">            for(Map&lt;String,Object&gt; response:responses)&#123;</span><br><span class="line">                String orderCode = response.get(&quot;orderCode&quot;).toString();</span><br><span class="line">                responseMap.put(orderCode, response);</span><br><span class="line">            &#125;</span><br><span class="line">            //结果转发到request</span><br><span class="line">            for(Request request:requests)&#123;</span><br><span class="line">                Map&lt;String, Object&gt; result = responseMap.get(request.orderCode);</span><br><span class="line">                request.future.complete(result);//转发到对应的线程</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;, 0, 10, TimeUnit.MILLISECONDS); //10ms执行</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class Request&#123;</span><br><span class="line">        String orderCode;</span><br><span class="line">        CompletableFuture&lt;Map&lt;String, Object&gt;&gt; future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Project Name:spring-boot</span><br><span class="line"> * File Name:remoteServiceCall.java</span><br><span class="line"> * Package Name:io.github.muxiaobai.spring_boot.remoteService</span><br><span class="line"> * Date:2019年3月22日上午10:37:05</span><br><span class="line"> * Copyright (c) 2019, All Rights Reserved.</span><br><span class="line"> *</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package io.github.muxiaobai.spring_boot.remoteService;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ClassName:remoteServiceCall </span><br><span class="line"> * Function: TODO </span><br><span class="line"> * Reason: TODO </span><br><span class="line"> * Date:     2019年3月22日 上午10:37:05 </span><br><span class="line"> * @author   Mu Xiaobai</span><br><span class="line"> * @version  </span><br><span class="line"> * @since    JDK 1.8 </span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class RemoteServiceCall &#123;</span><br><span class="line">    public Map&lt;String,Object&gt; getOne(String orderCode)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        map.put(&quot;orderCode&quot;, orderCode);</span><br><span class="line">        map.put(&quot;hello&quot;, &quot;hello&quot;);</span><br><span class="line">        return map ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public Map&lt;String,Object&gt; getTwo(String orderCode)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        map.put(&quot;orderCode2&quot;, orderCode);</span><br><span class="line">        map.put(&quot;hello2&quot;, &quot;hello2&quot;);</span><br><span class="line">        return map ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Map&lt;String,Object&gt;&gt; getMore(List&lt;String&gt; orderCodes)&#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line">        for(String orderCode: orderCodes)&#123;</span><br><span class="line">            Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            map.put(&quot;code&quot;, orderCode);</span><br><span class="line">            map.put(&quot;hello&quot;, &quot;hello&quot;);</span><br><span class="line">            list.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        return list ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多线程-串行，并行futuretask-线程池并行"><a href="#多线程-串行，并行futuretask-线程池并行" class="headerlink" title="多线程  串行，并行futuretask  线程池并行"></a>多线程  串行，并行futuretask  线程池并行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Project Name:spring-boot</span><br><span class="line"> * File Name:DemoService.java</span><br><span class="line"> * Package Name:io.github.muxiaobai.spring_boot.service</span><br><span class="line"> * Date:2019年3月21日下午7:31:58</span><br><span class="line"> * Copyright (c) 2019, All Rights Reserved.</span><br><span class="line"> *</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package io.github.muxiaobai.spring_boot.service;</span><br><span class="line"></span><br><span class="line">import io.github.muxiaobai.spring_boot.remoteService.RemoteServiceCall;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Propagation;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ClassName:DemoService </span><br><span class="line"> * Function: TODO </span><br><span class="line"> * Reason: TODO </span><br><span class="line"> * Date:     2019年3月21日 下午7:31:58 </span><br><span class="line"> * @author   Mu Xiaobai</span><br><span class="line"> * @version  </span><br><span class="line"> * @since    JDK 1.8 </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class DemoMoreThreadService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RemoteServiceCall remoteCall;</span><br><span class="line">    </span><br><span class="line">    protected static ExecutorService threads = Executors.newFixedThreadPool(10);</span><br><span class="line">    /**</span><br><span class="line">     * 使用线程池并行</span><br><span class="line">     * doExecPoolRemote:().</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @param orderCode</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public Map&lt;String, Object&gt; doExecPoolRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">        System.out.println(&quot;sssss&quot;);</span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getOne(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">      </span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable1 =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getTwo(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask = new FutureTask&lt;&gt;(callable);</span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask1 = new FutureTask&lt;&gt;(callable1);</span><br><span class="line">        </span><br><span class="line">        threads.submit(futureTask);</span><br><span class="line">        threads.submit(futureTask1);</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.putAll(futureTask.get());</span><br><span class="line">        result.putAll(futureTask1.get());</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br><span class="line">    /**</span><br><span class="line">     * 使用线程并行</span><br><span class="line">     * doThreadRemote:().</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @param orderCode</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, Object&gt; doThreadRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">        </span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getOne(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        </span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable1 =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getTwo(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask = new FutureTask&lt;&gt;(callable);</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask1 = new FutureTask&lt;&gt;(callable1);</span><br><span class="line">        new Thread(futureTask1).start();</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.putAll(futureTask.get());</span><br><span class="line">        result.putAll(futureTask1.get());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 串行</span><br><span class="line">     * doEachRemote:().</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @param orderCode</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, Object&gt; doEachRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">       </span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.putAll(remoteCall.getOne(orderCode));</span><br><span class="line">        result.putAll(remoteCall.getTwo(orderCode));</span><br><span class="line">       </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      java常用代码汇总，读futuretask,callable,使用
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java线上代码监控-工具-jprofiler</title>
    <link href="https://muxiaobai.github.io/2019/09/26/java%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81%E7%9B%91%E6%8E%A7-%E5%B7%A5%E5%85%B7-jprofiler/"/>
    <id>https://muxiaobai.github.io/2019/09/26/java线上代码监控-工具-jprofiler/</id>
    <published>2019-09-26T01:45:43.000Z</published>
    <updated>2020-05-06T05:58:29.711Z</updated>
    
    <content type="html"><![CDATA[<p>启动一个jvm进程</p><p>java -jar xxx.0.0.1.jar</p><p>服务器解压<a href="https://download-gcdn.ej-technologies.com/jprofiler/jprofiler_linux_11_0_2.tar.gz" target="_blank" rel="noopener">服务器端</a><br><a href="https://download-gcdn.ej-technologies.com/jprofiler/jprofiler_windows-x64_11_0_2.zip" target="_blank" rel="noopener">window客户端</a></p><p>服务器</p><ul><li>解压服务器</li><li>启动./jprofiler11.0.2/bin.jpenable</li><li>选择要监控功能的jvm</li><li>选择使用远程GUI监控</li><li>设置端口</li></ul><p>客户端</p><p>新建一个remote Session</p><h3 id="分析-dump—-gt-hprof"><a href="#分析-dump—-gt-hprof" class="headerlink" title="分析 dump—-&gt;hprof"></a>分析 dump—-&gt;hprof</h3><p><img src="/2019/09/26/java线上代码监控-工具-jprofiler/filter.png" alt><br><img src="/2019/09/26/java线上代码监控-工具-jprofiler/java.util.png" alt><br><img src="/2019/09/26/java线上代码监控-工具-jprofiler/class.png" alt></p><p>主要筛选自 java.util集合包中或者java.lang或者自己写的包.类</p><p>class 按类寻找，Biggest Objects 大对象</p><p>1、打开hprof文件:进入classes视图，根据（instance count和Size）基本可以确定哪个类的对象出现问题。比如(java.util.LinkedList$Entry类有2731062个实例)。<br>2、根据常识，应该java.util.LinkedList类有个对象的Size应该很大。<br>3、查看java.util.LinkedList，右键 use Selected Instance<br>4、选择Outgoing reference 视图(可以查看对象拥有的其他对象句柄,也就是对象属性)。看Retained size列（或者size属性）（有的时候Retained size不灵光），看大小就能确定是哪个对象内存溢出了。<br>5、找到对应的对象，右键use Selected Instance<br>6、选择Incoming refrences视图（该视图显示哪些对象拥有本对象的句柄），在这个视图下有个show Paths To GC Root的按钮，点击，基本能确定我们哪开代码有问题了。</p><p>最终找到大对象的或者多对象的类，优化类的代码</p>]]></content>
    
    <summary type="html">
    
      代码线上检测,快速查找bug
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>devops之docker</title>
    <link href="https://muxiaobai.github.io/2019/08/31/devops%E4%B9%8Bdocker/"/>
    <id>https://muxiaobai.github.io/2019/08/31/devops之docker/</id>
    <published>2019-08-31T08:45:53.000Z</published>
    <updated>2019-12-26T07:15:33.086Z</updated>
    
    <content type="html"><![CDATA[<hr><p>官网 hub.docker.com</p><p>docker login/logout</p><h4 id="远程镜像"><a href="#远程镜像" class="headerlink" title="远程镜像"></a>远程镜像</h4><p>docker pull mysql<br>docker push<br>docker search </p><h3 id="本地镜像-image"><a href="#本地镜像-image" class="headerlink" title="本地镜像 image"></a>本地镜像 image</h3><p>docker images<br>docker rmi</p><h3 id="网络-network"><a href="#网络-network" class="headerlink" title="网络 network"></a>网络 network</h3><p>172.17.0.1/16 以下都可以是使用</p><p>docker network ls<br>docker network inspect mysql-net<br>docker network create –subnet=172.19.0.0/24 mysql-net</p><h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><p>docker volume create –name v1<br>docker volumn inspect</p><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器 container"></a>容器 container</h3><p>docker run -d --name mmmysql -p 3300:3306 -m 500M<br>-v v1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --privileged --net=mysql-net –ip 172.19.0.2 mysql:latest</p><p>mvn clean clean package docker:build -Dmaven.test.skip=true</p><p>docker run -d --name tomcat1 -p 3300:3306 --net mysql-net --ip 172.19.0.2 -v v1:/var/lib/mysql mytomcat:latest</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>docker ps -a<br>docker ps<br>docker exec -it mmmysql /bin/bash<br>docker logs -f –tail=100 mmmysql  最新的100行<br>docker inspect mmmysql</p><hr><p>docker-compose.yml docker 编排</p><p><img src="/2019/08/31/devops之docker/docker.PNG" alt="docker请求"></p><p>K8s</p><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>Pod  (container-mysql1,container-mysql2,container-mysql3)<br>一个Pod包含一类的container</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node一台机器多个Pod<br>Kubelet操作Pod<br>docker<br><img src="/2019/08/31/devops之docker/Node.PNG" alt="Node Pod"></p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>label:不同的Node内部的Pod，同一个label 叫Service<br>mysql1  mysql2<br><img src="/2019/08/31/devops之docker/Service.PNG" alt="Service label"></p><p>####<br>master Node Worker Node 调度算法：Scheduler APIServer ControllerManager<br><img src="/2019/08/31/devops之docker/kub.PNG" alt="kub结构"><br>ReplicaSet 对Pod进行扩缩容</p><p>对Pod滚动更新：Deployment</p><p>分布式ETCD数据存储</p><p>使用者通过Kubectl操作K8s和docker<br><img src="/2019/08/31/devops之docker/useropera.PNG" alt="Node Pod"></p><hr>]]></content>
    
    <summary type="html">
    
      docker
    
    </summary>
    
      <category term="devops" scheme="https://muxiaobai.github.io/categories/devops/"/>
    
    
      <category term="devops" scheme="https://muxiaobai.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>java线上代码监控-工具-arthas</title>
    <link href="https://muxiaobai.github.io/2019/08/16/java%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81%E7%9B%91%E6%8E%A7-%E5%B7%A5%E5%85%B7-arthas/"/>
    <id>https://muxiaobai.github.io/2019/08/16/java线上代码监控-工具-arthas/</id>
    <published>2019-08-16T05:32:13.000Z</published>
    <updated>2020-05-06T06:12:19.239Z</updated>
    
    <content type="html"><![CDATA[<p>强力推荐alibaba的arthas</p><h2 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h2><p>官网<a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">https://alibaba.github.io/arthas</a></p><p>教程<a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-basics" target="_blank" rel="noopener">Arthas 基础教程</a></p><p>教程<a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced" target="_blank" rel="noopener">Arthas 进阶教程</a></p><p>   参数：–tunnel-server ‘ws://47.75.156.201:7777/ws’<br>默认的是<br>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar --target-ip 0.0.0.0</span><br></pre></td></tr></table></figure><p>选择对应的main</p><p>通用命令</p><ul><li>keymap 快捷键</li><li>help</li><li>Q ctrl+c 退出当前命令</li></ul><p>常用命令</p><ul><li>dashboard 实时看板</li><li>thread 查线程</li><li>jvm 当前jvm信息</li><li>sysprop(sysenv) 系统参数(System Property)(System Environment Variables)</li><li>jad 反编译</li><li>sc (search class)查jvm加载的类 -d 加载的信息 classLoaderHash 哪一个ClassLoader加载的类</li><li>sm (search method) 查class方法</li><li>mc (Memory Compiler) 使用指定的ClassLoader编译java</li><li>redefine 热更新代码</li><li>watch 方法执行数据观测（实时调用）</li><li>ognl 动态执行代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">反编译 修改 编译 热更新</span><br><span class="line">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br><span class="line">vim /tmp/UserController.java</span><br><span class="line">mc /tmp/UserController.java -d /tmp </span><br><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure><h3 id="暂存运行状态文件hpof"><a href="#暂存运行状态文件hpof" class="headerlink" title="暂存运行状态文件hpof"></a>暂存运行状态文件hpof</h3><p>类似jmap命令的heap dump功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapdump /tmp/dump.hprof</span><br></pre></td></tr></table></figure><p>只dump live对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[arthas@58205]$ heapdump --live /tmp/dump.hprof</span><br><span class="line">Dumping heap to /tmp/dump.hprof...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p>分析hprof文件工具</p><ul><li>使用eclipse的MAT (Memory Analyzer Tools)</li><li>或者IDEA 的jprofiler插件 <a href="https://blog.csdn.net/wytocsdn/article/details/79258247" target="_blank" rel="noopener">IDEA 配置执行器</a> 需要装jprofiler执行器<a href="https://www.ej-technologies.com/download/jprofiler/version_92" target="_blank" rel="noopener">jprofiler下载</a> <a href="https://www.cnblogs.com/jifeng/p/3336408.html" target="_blank" rel="noopener">license</a>  <a href="https://blog.csdn.net/vicky_pyh/article/details/88797514" target="_blank" rel="noopener">jprofiler 使用</a></li><li>IMB 的heapAnalyzer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">按默认选择“Single or evaluation license”</span><br><span class="line">Name 和 Company 随意</span><br><span class="line">-----------------------忧郁的分割线---------------------------</span><br><span class="line">L-Larry_Lau@163.com#23874-hrwpdp1sh1wrn#0620</span><br><span class="line">L-Larry_Lau@163.com#36573-fdkscp15axjj6#25257</span><br><span class="line">L-Larry_Lau@163.com#5481-ucjn4a16rvd98#6038</span><br><span class="line">L-Larry_Lau@163.com#99016-hli5ay1ylizjj#27215</span><br><span class="line">L-Larry_Lau@163.com#40775-3wle0g1uin5c1#0674</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">L-Larry_Lau@163.com#7009-14frku31ynzpfr#20176</span><br><span class="line">L-Larry_Lau@163.com#49604-1jfe58we9gyb6#5814</span><br><span class="line">L-Larry_Lau@163.com#25531-1qcev4yintqkj#23927</span><br><span class="line">L-Larry_Lau@163.com#96496-1qsu1lb1jz7g8w#23479</span><br><span class="line">L-Larry_Lau@163.com#20948-11amlvg181cw0p#171159</span><br></pre></td></tr></table></figure><p>JRebel和JProfiler同时运行</p><p>如果IDEA中配置了JRebel热部署，要想JRebel和JProfiler同时运行，就要改手动管理JProfiler session了。<br>在 Run–Debug Configurations窗口JRebel Debug tab页中配置Environment Variables属性 CATALINA_OPTS：<br>使用springboot不成功，<br>CATALINA_OPTS=-agentpath:E:\tools\jprofiler_windows-x64_9_2_1\jprofiler9\bin\windows-x64\jprofilerti.dll=port=8849,nowait,id=81,config=C:\Users\Administrator.jprofiler9\config.xml</p><p>调用请求: curl -w “@curl-time.txt” <a href="http://127.0.0.1:8080/hello" target="_blank" rel="noopener">http://127.0.0.1:8080/hello</a></p><p>###常用</p><p>thread -n 5<br>2）查看某个函数的调用堆栈 打印前五名最消耗CPU的线程，可以及时找到CPU过高的代码位置</p><p>stack &lt;类全包名&gt; &lt;函数名&gt;<br>3）查看某个函数的哪个子调用最慢，耗时最久的调用会标红显示，可以方便找出某个功能中最耗时的操作</p><p>trace &lt;类全包名&gt; &lt;函数名&gt;<br>4）监控某个函数的调用统计数据，包括总调用次数，平均运行时间，成功率等信息</p><p>monitor &lt;类全包名&gt; &lt;函数名&gt;</p><h3 id="热更新代码"><a href="#热更新代码" class="headerlink" title="热更新代码"></a>热更新代码</h3><p><a href="https://mp.weixin.qq.com/s/um6XQVv1JvHM3n7NslzB0Q" target="_blank" rel="noopener">热更新</a></p><h2 id="常用和spring有关的"><a href="#常用和spring有关的" class="headerlink" title="常用和spring有关的"></a>常用和spring有关的</h2><p>从spring-mvc入手</p><h3 id="内部："><a href="#内部：" class="headerlink" title="内部："></a>内部：</h3><p>trace 方法内部调用路径，并输出方法路径上的每个节点上耗时 -j跳过jdkclass<br>Servlet Filter 转发 哪一个Controller</p><p>trace javax.servlet.Servlet <em><br>trace javax.servlet.Filter </em><br>trace org.springframework.web.servlet.DispatcherServlet *</p><p>watch org.springframework.web.servlet.DispatcherServlet getHandler returnObj<br>是哪一个controller调用</p><p>外部：<br>stack org.springframework.web.servlet.DispatcherServlet *<br>stack 输出当前方法被调用的调用路径<br>很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。</p><h2 id="其它监控"><a href="#其它监控" class="headerlink" title="其它监控"></a>其它监控</h2><p>Druid连接池 数据库监控 参考 <a href="https://muxiaobai.github.io/2018/11/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%91%E6%8E%A7-Druid%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE/">数据库监控-Druid监控配置</a><br>Javamelody 传统应用 参考 <a href="https://muxiaobai.github.io/2017/08/02/Javamelody-%E5%B7%A5%E5%85%B7/">Javamelody 工具</a><br>jre自带的工具 jconsole jvisualvm参考 <a href="https://muxiaobai.github.io/2018/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7/">深入理解JVM之远程监控</a></p>]]></content>
    
    <summary type="html">
    
      代码线上检测,快速查找bug
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>git的一些其它操作</title>
    <link href="https://muxiaobai.github.io/2019/07/29/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C/"/>
    <id>https://muxiaobai.github.io/2019/07/29/git的一些其它操作/</id>
    <published>2019-07-29T11:21:25.000Z</published>
    <updated>2020-01-04T06:18:13.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="git-拉取代码失败"><a href="#git-拉取代码失败" class="headerlink" title="git 拉取代码失败"></a>git 拉取代码失败</h4><p>解决方法很简单，在git clone时加上–depth=1即可解决</p><blockquote><p>depth用于指定克隆深度，为1即表示只克隆最近一次commit.</p></blockquote><p>这种方法克隆的项目只包含最近的一次commit的一个分支，体积很小，即可解决文章开头提到的项目过大导致Timeout的问题，但会产生另外一个问题，他只会把默认分支clone下来，其他远程分支并不在本地，所以这种情况下，需要用如下方法拉取其他分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git clone --depth 1 https://github.com/dogescript/xxxxxxx.git</span><br><span class="line">$ git remote set-branches origin &apos;remote_branch_name&apos;</span><br><span class="line">$ git fetch --depth 1 origin remote_branch_name</span><br><span class="line">$ git checkout remote_branch_name</span><br></pre></td></tr></table></figure></p><p>压缩代码<br><code>git config  --add  core.compression -1</code><br>或者<br><code>git config  --global  core.compression -1</code></p><p>compression 是压缩的意思，从 clone 的终端输出就知道，服务器会压缩目标文件，然后传输到客户端，客户端再解压。取值为 [-1, 9]，-1 以 zlib 为默认压缩库，0 表示不进行压缩，1..9 是压缩速度与最终获得文件大小的不同程度的权衡，数字越大，压缩越慢，当然得到的文件会越小。</p><h4 id="或者使用git-clone"><a href="#或者使用git-clone" class="headerlink" title="或者使用git@  clone"></a>或者使用git@  clone</h4><p>-t 指定密钥类型，默认是 rsa ，可以省略。<br>-C 设置注释文字，比如邮箱。<br>-f 指定密钥文件存储文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen.exe -t rsa -C &quot;xxxx@gmail.com&quot;</span><br><span class="line">Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">输入密码，push 的时候的密码</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx@xxx MINGW64 ~/.ssh</span><br><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>再使用 <code>git clone git@github.com:xxxx/xxxx.git</code></p><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>先把vscode作为git默认编辑器</p><p>git config –global core.editor “code –wait”</p><p>用vscode 打开 .gitconfig文件</p><p>git config –global -e</p><p>在里面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[diff]</span><br><span class="line">    tool = default-difftool</span><br><span class="line">[difftool &quot;default-difftool&quot;]</span><br><span class="line">    cmd = code --wait --diff $LOCAL $REMOTE</span><br></pre></td></tr></table></figure><p>这时候运行git difftool，vscode 就作为默认difftool打开了</p><h4 id="git-add-回退"><a href="#git-add-回退" class="headerlink" title="git add 回退"></a>git add 回退</h4><p>git status 先看一下add 中的文件<br>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了<br>git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了</p><h4 id="git-commit-回退"><a href="#git-commit-回退" class="headerlink" title="git commit 回退"></a>git commit 回退</h4><p><code>git reset --soft HEAD^</code>这样就成功的撤销了你的commit<br>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><p>–soft<br>不删除工作空间改动代码，撤销commit，不撤销git add . </p><h4 id="修改远程仓库-origin，更换地址"><a href="#修改远程仓库-origin，更换地址" class="headerlink" title="修改远程仓库 origin，更换地址"></a>修改远程仓库 origin，更换地址</h4><p>查看远程地址</p><p>git remote -v  </p><p>移除origin远程地址</p><p>git remote rm origin</p><p>添加origin 远程地址</p><p>git remote add origin <a href="https://github.com/muxiaobai/xxx" target="_blank" rel="noopener">https://github.com/muxiaobai/xxx</a></p><p>拉取origin下的代码</p><p>git fetch origin</p><h3 id="已存在的git仓库更换地址"><a href="#已存在的git仓库更换地址" class="headerlink" title="已存在的git仓库更换地址"></a>已存在的git仓库更换地址</h3><p>cd existing_repo<br>git remote rename origin old-origin<br>git remote add origin <a href="http://192.168.120.63/xxx/xxx.git" target="_blank" rel="noopener">http://192.168.120.63/xxx/xxx.git</a><br>git push -u origin –all<br>git push -u origin –tags</p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>查看远程和本地分支<br>git branch -a</p><p>创建并切换dev 分支<br>git checkout -b dev</p><p>切换到dev分支<br>git checkout dev</p><p>删除远程xxx分支<br>git remote rm xxx</p><p>#### </p><p>首先，git fetch –all  取回远程库的所有修改；<br>然后，git reset –hard origin/master<br>指向远程库origin的master</p><h4 id="回滚上次提交"><a href="#回滚上次提交" class="headerlink" title="回滚上次提交"></a>回滚上次提交</h4><p>git reset --hard HEAD^<br>git log<br>git reset commit_id</p><h3 id="每个人的数据库连接信息不一样，可以选择忽略"><a href="#每个人的数据库连接信息不一样，可以选择忽略" class="headerlink" title="每个人的数据库连接信息不一样，可以选择忽略"></a>每个人的数据库连接信息不一样，可以选择忽略</h3><p>具体操作如下：</p><p>在命令行中输入</p><p>git update-index –assume-unchanged [file-path]<br>命令中的file-path 就是需要忽略提价的文件的路径</p><p>如果需要恢复提交，使用：</p><p>git update-index –no-assume-unchanged [file-path]</p>]]></content>
    
    <summary type="html">
    
      git常见操作
    
    </summary>
    
      <category term="工具" scheme="https://muxiaobai.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="常用命令" scheme="https://muxiaobai.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>tools-ide快捷操作</title>
    <link href="https://muxiaobai.github.io/2019/06/27/tools-ide%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"/>
    <id>https://muxiaobai.github.io/2019/06/27/tools-ide快捷操作/</id>
    <published>2019-06-27T11:28:57.000Z</published>
    <updated>2019-11-06T09:19:33.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vs-Code"><a href="#vs-Code" class="headerlink" title="vs Code"></a>vs Code</h2><p>GitLens git 操作<br>vscode-icons 文件图标<br>Beautify 美化代码<br>CSS Peek 从html的class跳转到css文件对应的位置<br>IntelliSense for CSS class names in HTML 自动提示CSS的class<br>Markdown Preview markdown 预览</p><p><img src="/2019/06/27/tools-ide快捷操作/vscodeplugins.png" alt="vscode 插件"></p><h2 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h2><p>sublime 工具插件<br>package control<br>ConvertToUTF8</p><p>激活sublime</p><p>C:\Windows\System32\drivers\etc  host</p><p>127.0.0.1 <a href="http://www.sublimetext.com" target="_blank" rel="noopener">www.sublimetext.com</a><br>127.0.0.1 license.sublimehq.com<br>127.0.0.1 45.55.255.55<br>127.0.0.1 45.55.41.223</p><p>—– BEGIN LICENSE —–<br>sgbteam<br>Single User License<br>EA7E-1153259<br>8891CBB9 F1513E4F 1A3405C1 A865D53F<br>115F202E 7B91AB2D 0D2A40ED 352B269B<br>76E84F0B CD69BFC7 59F2DFEF E267328F<br>215652A3 E88F9D8F 4C38E3BA 5B2DAAE4<br>969624E7 DC9CD4D5 717FB40C 1B9738CF<br>20B3C4F1 E917B5B3 87C38D9C ACCE7DD8<br>5F7EF854 86B9743C FADC04AA FB0DA5C0<br>F913BE58 42FEA319 F954EFDD AE881E0B<br>—— END LICENSE ——</p><p>ZYNGA INC.<br>50 User License<br>EA7E-811825<br>927BA117 84C9300F 4A0CCBC4 34A56B44<br>985E4562 59F2B63B CCCFF92F 0E646B83<br>0FD6487D 1507AE29 9CC4F9F5 0A6F32E3<br>0343D868 C18E2CD5 27641A71 25475648<br>309705B3 E468DDC4 1B766A18 7952D28C<br>E627DDBA 960A2153 69A2D98A C87C0607<br>45DC6049 8C04EC29 D18DFA40 442C680B<br>1342224D 44D90641 33A3B9F2 46AADB8F</p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>###默认配置</p><h4 id="滚轮字体大小"><a href="#滚轮字体大小" class="headerlink" title="滚轮字体大小"></a>滚轮字体大小</h4><p>Editor—–&gt; General—–&gt; Change font size(Zoom) with Ctrl+Mouse Wheel</p><h4 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h4><p><img src="/2019/06/27/tools-ide快捷操作/AutoImport.png" alt="自动导包"></p><p>勾选标注第1个选项，IntelliJ IDEA 将在我们书写代码的时候自动帮我们导入需要用到的包。但是对于那些同名的包，还是需要手动 Alt + Enter 进行导入的</p><p>勾选标注 第2个选项，IntelliJ IDEA 将在我们书写代码的时候自动帮我们优化导入的包，比如自动去掉一些没有用到的包。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>个人意见，仅供参考,顺序代表推荐强度</p><ul><li>Alibaba Java Coding Guidelines 代码检测</li><li>JRebel for Intellij 热部署 （收费）</li><li>Lombok 不用写get set 方法</li><li>save-action  保存的时候导包，格式化代码</li><li>FindBugs Idea 扫描代码，可能出现的bug</li><li>Free Mybatis plugin   mapper跳转到xml。xml跳转到mapper</li><li>Key promoter X  展示快捷键</li><li>Statistic 代码统计</li><li>Translation  Google 翻译 </li><li>jclasslib Bytecode viewer 查看字节码文件</li><li>GosnFormat json转java对象类</li><li>SonarLint  代码检查</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>/**</p><ul><li>Project Name:${project_name}</li><li>File Name:${file_name}</li><li>Package Name:${package_name}</li><li>Date:${date} ${time}</li><li>Copyright (c) ${year}, All Rights Reserved.<br><em></em>/</li></ul><p>${filecomment}</p><p>${package_declaration}<br>/**</p><ul><li>ClassName:${type_name} </li><li>Function: ${todo} </li><li>Reason: ${todo} </li><li>Date: ${date} ${time} </li><li>@author Mu Xiaobai</li><li>@version </li><li>@since JDK 1.8<br>*/<br>${typecomment}<br>${type_declaration}</li></ul><p>aa 包<br>/**</p><ul><li>Project Name:$project_name$</li><li>File Name:$file_name$</li><li>Package Name:$package_name$</li><li>Date:$date$ $time$</li><li>Copyright (c) $year$, All Rights Reserved.<br><em></em>/<br>ss 类<br>/**</li><li>@ClassName: $class_name$ </li><li>@Function: //TODO </li><li>@Reason: //TODO</li><li>@Date: $date$ $time$ </li><li>@author Mu Xiaobai</li><li>@version </li><li>@since JDK 1.8<br><em>/<br>zz 方法<br>/</em> </li><li>@name: $enclosing_method$</li><li>@description: TODO </li><li>@param $param$</li><li>@return: $return$ </li><li>@date: $date$ $time$</li><li>@auther: $user$</li><li>*/</li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>ctrl + shift + r 替换<br>ctrl + shift + f 查找</p><p>alt + ↑/↓  本类中的方法依次上下跳转<br>alt + ←/→  左右边的类</p><p>ctrl + shift + u 大小写替换</p><p>ctrl +  ←/→   光标左/右单词移动<br>ctrl+shift + ←/→  左/右边单词扩选</p><p>ctrl+w 选中光标，依次扩选<br>ctrl +shift + w 反向收缩选中内容</p><p>Ctrl + u    前往当前光标所在的方法的父类的方法 / 接口定义<br>ctrl + b 进入光标所在的方法/变量的接口或是定义处</p><p>ctrl + alt + 鼠标左键 查看方法的实现类<br>ctrl + alt + ←/→  鼠标上次的位置/下次的位置</p><p>Ctrl + Alt + T    对选中的代码弹出环绕选项弹出层 （必备）</p><p>ctrl + x 剪切<br>ctrl + d 复制粘贴<br>ctrl + / 单行注释<br>ctrl + shift + / 选中内容多行注释</p><p>ctrl + z 撤回<br>ctrl + shift + z 撤回的撤回</p><p>ctrl +alt + s 设置<br>ctrl +alt +shift + s 本项目设置 打包</p><p>参考:</p><ul><li><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md" target="_blank" rel="noopener">IntelliJ-IDEA-Tutorial</a></li><li><a href="https://blog.csdn.net/deniro_li/article/details/72902621" target="_blank" rel="noopener">IntelliJ IDEA 快捷键说明大全（中英对照、带图示详解）</a><h2 id="navicat"><a href="#navicat" class="headerlink" title="navicat"></a>navicat</h2></li></ul><p>ctrl + shift + r  选中内容执行<br>ctrl + r 执行当期窗口所有<br>ctrl + q 打开新执行窗口<br>ctrl + w 关闭当期窗口</p><h2 id="plsql"><a href="#plsql" class="headerlink" title="plsql"></a>plsql</h2><p>F8 执行选中</p><p>设置AutoReplace<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sf = select t.* ,t.rowid from </span><br><span class="line">s = select * from</span><br></pre></td></tr></table></figure></p><p>打开PL/SQL，在Tools-&gt;Perferences-&gt;Editor中Autoreplace，勾选Enabled，选择配置的AutoReplace.txt文件，点击OK即可。</p><h2 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h2><h3 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><p>ctrl+shift+G查看方法被调用<br>ctrl+alt+R 重启或者启动tomcat<br>ctrl+shift+T 查找文件在哪里 匹配java<br>ctrl+shift+R resource查找所有资源<br>ctrl+h file search Containing text 搜索包含某个字符串的所有文件<br>ctrl+shift+c注释/反注释<br>ctrl + alt + H查看方法被调用</p><p>ctrl+shift+L  查看所有的快捷键</p><p>ctrl+alt+G  搜索文本</p><h3 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h3><ul><li>svn - <a href="http://subclipse.tigris.org/update_1.8.x" target="_blank" rel="noopener">http://subclipse.tigris.org/update_1.8.x</a></li><li>jd-core - <a href="http://jd.benow.ca/jd-eclipse/update" target="_blank" rel="noopener">http://jd.benow.ca/jd-eclipse/update</a></li><li>zookeeper：  <a href="http://www.massedynamic.org/eclipse/updates/" target="_blank" rel="noopener">http://www.massedynamic.org/eclipse/updates/</a></li><li>Enhanced Class Decompiler  <a href="http://feeling.sourceforge.net/update" target="_blank" rel="noopener">http://feeling.sourceforge.net/update</a></li></ul><p>反编译</p><p>重启之后，在窗口菜单栏点击Widow-&gt;Preference-&gt;General-&gt;Editors-&gt;File Associations,将FileType里的<em>.class和</em>.class without source的Associated editors下面的Class File Editor设置成default即可</p><h2 id="powerdesign"><a href="#powerdesign" class="headerlink" title="powerdesign"></a>powerdesign</h2><h3 id="导出excel脚本"><a href="#导出excel脚本" class="headerlink" title="导出excel脚本"></a>导出excel脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&apos;******************************************************************************</span><br><span class="line">Option Explicit</span><br><span class="line">   Dim rowsNum</span><br><span class="line">   rowsNum = 0</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">&apos; Main function</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">&apos; Get the current active model</span><br><span class="line">    Dim Model</span><br><span class="line">    Set Model = ActiveModel</span><br><span class="line">    If (Model Is Nothing) Or (Not Model.IsKindOf(PdPDM.cls_Model)) Then</span><br><span class="line">       MsgBox &quot;The current model is not an PDM model.&quot;</span><br><span class="line">    Else</span><br><span class="line">      &apos; Get the tables collection</span><br><span class="line">      &apos;创建EXCEL APP</span><br><span class="line">      dim beginrow</span><br><span class="line">      DIM EXCEL, SHEET, SHEETLIST</span><br><span class="line">      set EXCEL = CREATEOBJECT(&quot;Excel.Application&quot;)</span><br><span class="line">      EXCEL.workbooks.add(-4167)&apos;添加工作表</span><br><span class="line">      EXCEL.workbooks(1).sheets(1).name =&quot;表结构&quot;</span><br><span class="line">      set SHEET = EXCEL.workbooks(1).sheets(&quot;表结构&quot;)</span><br><span class="line">       </span><br><span class="line">      EXCEL.workbooks(1).sheets.add</span><br><span class="line">      EXCEL.workbooks(1).sheets(1).name =&quot;目录&quot;</span><br><span class="line">      set SHEETLIST = EXCEL.workbooks(1).sheets(&quot;目录&quot;)</span><br><span class="line">      ShowTableList Model,SHEETLIST</span><br><span class="line"> </span><br><span class="line">      ShowProperties Model, SHEET,SHEETLIST</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">      EXCEL.workbooks(1).Sheets(2).Select</span><br><span class="line">      EXCEL.visible = true</span><br><span class="line">      &apos;设置列宽和自动换行</span><br><span class="line">      sheet.Columns(1).ColumnWidth = 20</span><br><span class="line">      sheet.Columns(2).ColumnWidth = 20</span><br><span class="line">      sheet.Columns(3).ColumnWidth = 20</span><br><span class="line">      sheet.Columns(4).ColumnWidth = 40</span><br><span class="line">      sheet.Columns(5).ColumnWidth = 10</span><br><span class="line">      sheet.Columns(6).ColumnWidth = 10</span><br><span class="line">      sheet.Columns(1).WrapText =true</span><br><span class="line">      sheet.Columns(2).WrapText =true</span><br><span class="line">      sheet.Columns(4).WrapText =true</span><br><span class="line">      &apos;不显示网格线</span><br><span class="line">      EXCEL.ActiveWindow.DisplayGridlines = False</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line"> End If</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">&apos; Show properties of tables</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">Sub ShowProperties(mdl, sheet,SheetList)</span><br><span class="line">   &apos; Show tables of the current model/package</span><br><span class="line">   rowsNum=0</span><br><span class="line">   beginrow = rowsNum+1</span><br><span class="line">   Dim rowIndex</span><br><span class="line">   rowIndex=3</span><br><span class="line">   &apos; For each table</span><br><span class="line">   output &quot;begin&quot;</span><br><span class="line">   Dim tab</span><br><span class="line">   For Each tab In mdl.tables</span><br><span class="line">      ShowTable tab,sheet,rowIndex,sheetList</span><br><span class="line">      rowIndex = rowIndex +1</span><br><span class="line">   Next</span><br><span class="line">   if mdl.tables.count &gt; 0 then</span><br><span class="line">        sheet.Range(&quot;A&quot; &amp; beginrow + 1 &amp; &quot;:A&quot; &amp; rowsNum).Rows.Group</span><br><span class="line">   end if</span><br><span class="line">   output &quot;end&quot;</span><br><span class="line">End Sub</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">&apos; Show table properties</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">Sub ShowTable(tab, sheet,rowIndex,sheetList)</span><br><span class="line">   If IsObject(tab) Then</span><br><span class="line">     Dim rangFlag</span><br><span class="line">     rowsNum = rowsNum + 1</span><br><span class="line">      &apos; Show properties</span><br><span class="line">      Output &quot;================================&quot;</span><br><span class="line">      sheet.cells(rowsNum, 1) =tab.name</span><br><span class="line">      sheet.cells(rowsNum, 1).HorizontalAlignment=3</span><br><span class="line">      sheet.cells(rowsNum, 2) = tab.code</span><br><span class="line">      &apos;sheet.cells(rowsNum, 5).HorizontalAlignment=3</span><br><span class="line">      &apos;sheet.cells(rowsNum, 6) = &quot;&quot;</span><br><span class="line">      &apos;sheet.cells(rowsNum, 7) = &quot;表说明&quot;</span><br><span class="line">      sheet.cells(rowsNum, 3) = tab.comment</span><br><span class="line">      &apos;sheet.cells(rowsNum, 8).HorizontalAlignment=3</span><br><span class="line">      sheet.Range(sheet.cells(rowsNum, 3),sheet.cells(rowsNum, 7)).Merge</span><br><span class="line">      &apos;设置超链接，从目录点击表名去查看表结构</span><br><span class="line">      &apos;字段中文名    字段英文名    字段类型    注释    是否主键    是否非空    默认值</span><br><span class="line">      sheetList.Hyperlinks.Add sheetList.cells(rowIndex,2), &quot;&quot;,&quot;表结构&quot;&amp;&quot;!B&quot;&amp;rowsNum</span><br><span class="line">      rowsNum = rowsNum + 1</span><br><span class="line">      sheet.cells(rowsNum, 1) = &quot;字段中文名&quot;</span><br><span class="line">      sheet.cells(rowsNum, 2) = &quot;字段英文名&quot;</span><br><span class="line">      sheet.cells(rowsNum, 3) = &quot;字段类型&quot;</span><br><span class="line">      sheet.cells(rowsNum, 4) = &quot;注释&quot;</span><br><span class="line">      sheet.cells(rowsNum, 5) = &quot;是否主键&quot;</span><br><span class="line">      sheet.cells(rowsNum, 6) = &quot;是否非空&quot;</span><br><span class="line">      sheet.cells(rowsNum, 7) = &quot;默认值&quot;</span><br><span class="line">      &apos;设置边框</span><br><span class="line">      sheet.Range(sheet.cells(rowsNum-1, 1),sheet.cells(rowsNum, 7)).Borders.LineStyle = &quot;1&quot;</span><br><span class="line">      &apos;sheet.Range(sheet.cells(rowsNum-1, 4),sheet.cells(rowsNum, 9)).Borders.LineStyle = &quot;1&quot;</span><br><span class="line">      &apos;字体为10号</span><br><span class="line">      sheet.Range(sheet.cells(rowsNum-1, 1),sheet.cells(rowsNum, 7)).Font.Size=10</span><br><span class="line">            Dim col &apos; running column</span><br><span class="line">            Dim colsNum</span><br><span class="line">            colsNum = 0</span><br><span class="line">      for each col in tab.columns</span><br><span class="line">        rowsNum = rowsNum + 1</span><br><span class="line">        colsNum = colsNum + 1</span><br><span class="line">          sheet.cells(rowsNum, 1) = col.name</span><br><span class="line">        &apos;sheet.cells(rowsNum, 3) = &quot;&quot;</span><br><span class="line">          &apos;sheet.cells(rowsNum, 4) = col.name</span><br><span class="line">          sheet.cells(rowsNum, 2) = col.code</span><br><span class="line">          sheet.cells(rowsNum, 3) = col.datatype</span><br><span class="line">        sheet.cells(rowsNum, 4) = col.comment</span><br><span class="line">          If col.Primary = true Then</span><br><span class="line">        sheet.cells(rowsNum, 5) = &quot;Y&quot;</span><br><span class="line">        Else</span><br><span class="line">        sheet.cells(rowsNum, 5) = &quot; &quot;</span><br><span class="line">        End If</span><br><span class="line">        If col.Mandatory = true Then</span><br><span class="line">        sheet.cells(rowsNum, 6) = &quot;Y&quot;</span><br><span class="line">        Else</span><br><span class="line">        sheet.cells(rowsNum, 6) = &quot; &quot;</span><br><span class="line">        End If</span><br><span class="line">        sheet.cells(rowsNum, 7) =  col.defaultvalue</span><br><span class="line">      next</span><br><span class="line">      sheet.Range(sheet.cells(rowsNum-colsNum+1,1),sheet.cells(rowsNum,7)).Borders.LineStyle = &quot;3&quot;      </span><br><span class="line">      &apos;sheet.Range(sheet.cells(rowsNum-colsNum+1,4),sheet.cells(rowsNum,9)).Borders.LineStyle = &quot;3&quot;</span><br><span class="line">      sheet.Range(sheet.cells(rowsNum-colsNum+1,1),sheet.cells(rowsNum,7)).Font.Size = 10</span><br><span class="line">      rowsNum = rowsNum + 2</span><br><span class="line">       </span><br><span class="line">      Output &quot;FullDescription: &quot;       + tab.Name</span><br><span class="line">   End If</span><br><span class="line">    </span><br><span class="line">End Sub</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">&apos; Show List Of Table</span><br><span class="line">&apos;-----------------------------------------------------------------------------</span><br><span class="line">Sub ShowTableList(mdl, SheetList)</span><br><span class="line">   &apos; Show tables of the current model/package</span><br><span class="line">   Dim rowsNo</span><br><span class="line">   rowsNo=1</span><br><span class="line">   &apos; For each table</span><br><span class="line">   output &quot;begin&quot;</span><br><span class="line">   SheetList.cells(rowsNo, 1) = &quot;主题&quot;</span><br><span class="line">   SheetList.cells(rowsNo, 2) = &quot;表中文名&quot;</span><br><span class="line">   SheetList.cells(rowsNo, 3) = &quot;表英文名&quot;</span><br><span class="line">   SheetList.cells(rowsNo, 4) = &quot;表说明&quot;</span><br><span class="line">   rowsNo = rowsNo + 1</span><br><span class="line">   SheetList.cells(rowsNo, 1) = mdl.name</span><br><span class="line">   Dim tab</span><br><span class="line">   For Each tab In mdl.tables</span><br><span class="line">     If IsObject(tab) Then</span><br><span class="line">         rowsNo = rowsNo + 1</span><br><span class="line">      SheetList.cells(rowsNo, 1) = &quot;&quot;</span><br><span class="line">      SheetList.cells(rowsNo, 2) = tab.name</span><br><span class="line">      SheetList.cells(rowsNo, 3) = tab.code</span><br><span class="line">      SheetList.cells(rowsNo, 4) = tab.comment</span><br><span class="line">     End If</span><br><span class="line">   Next</span><br><span class="line">    SheetList.Columns(1).ColumnWidth = 20</span><br><span class="line">      SheetList.Columns(2).ColumnWidth = 20</span><br><span class="line">      SheetList.Columns(3).ColumnWidth = 30</span><br><span class="line">     SheetList.Columns(4).ColumnWidth = 60</span><br><span class="line">   output &quot;end&quot;</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      日常工具快捷操作
    
    </summary>
    
      <category term="工具" scheme="https://muxiaobai.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://muxiaobai.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="插件" scheme="https://muxiaobai.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>高并发之缓存、限流、降级</title>
    <link href="https://muxiaobai.github.io/2019/05/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BC%93%E5%AD%98%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E9%99%8D%E7%BA%A7/"/>
    <id>https://muxiaobai.github.io/2019/05/21/高并发之缓存、限流、降级/</id>
    <published>2019-05-21T03:54:24.000Z</published>
    <updated>2019-05-21T12:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先必须要从代码层面上提升性能，利用缓存等，如果在访问量大，确实无法处理的情况下就要考虑限流，或者防刷也是要考虑限流，然后如果服务确实不可用的话就把服务进行降级，比如当无法获取评论信息的时候，但是写的朋友圈是要正常返回的。不能因为评论服务无法提供，连朋友圈也不能看了。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>可以通过注解把技术相关的，读缓存，写日志，写缓存的功能，使用注解加反射来进行操作。</p><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cache cache =getCache();</span><br><span class="line"></span><br><span class="line">if(cache!=null)&#123;</span><br><span class="line">    return cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Data result= getDatabase();</span><br><span class="line">lg.info(&quot;获取数据&quot;);</span><br><span class="line">if(result!=null)&#123;</span><br><span class="line">    setCacheData(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br></pre></td></tr></table></figure></p><p>业务上，实际只有getDatabase才有用。</p><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@getCache()</span><br><span class="line">@setCache()</span><br><span class="line">@log()</span><br><span class="line">public getData()&#123;</span><br><span class="line">    Data result= getDatabase();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过注解反射如果有getCache的话直接使用缓存中的数据，如果有直接返回，如果有log写日志，如果有set则把获取到的数据写到cache中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h4 id="限流瞬时流量"><a href="#限流瞬时流量" class="headerlink" title="限流瞬时流量"></a>限流瞬时流量</h4><p>双11，秒杀，之类的属于瞬时流量很大，平时相对稳定。</p><h4 id="限流总并发量"><a href="#限流总并发量" class="headerlink" title="限流总并发量"></a>限流总并发量</h4><h4 id="限流平均流量"><a href="#限流平均流量" class="headerlink" title="限流平均流量"></a>限流平均流量</h4><ul><li><p>滑动窗口</p></li><li><p>令牌桶，每秒生成n个，限制平均流量</p></li><li><p>漏桶，这个是应对瞬时流量过大的一种方法，一定的速率进行消费，MQ，削峰，解耦，异步。但是能解决的瞬时流量也是有一个最大值。</p></li><li><p>计数器，限制总的并发数，比如说每秒钟只能请求100次，是限制总并发量。通常可用redis缓存，请求增加incr来实现。</p></li></ul><p>采用：Google开源工具包Guava提供了限流工具类RateLimiter，该类基于令牌桶算法来完成限流，非常易于使用。</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>当服务调用者使用同步调用的时候，会产生大量的等待线程占用系统资源，一旦线程资源被耗尽，<br>服务调用者提供的服务也将处于不可用状态，于是服务雪崩效应产生了！<br>这时候就需要比如说：当失败了多少次之后，</p><p>1，超时机制<br>2，服务限流<br>3，服务熔断<br>4，服务降级</p><p>超时机制<br>如果我们加入超时机制，例如2s，那么超过2s就会直接返回了，那么这样就在一定程度上可以抑制消费者资源耗尽的问题</p><p>服务限流<br>通过线程池+队列的方式，通过信号量的方式。比如商品评论比较慢，最大能同时处理10个线程，队列待处理5个，那么如果同时20个线程到达的话，其中就有5个线程被限流了，其中10个先被执行，另外5个在队列中</p><p>服务熔断<br>这个熔断可以理解为我们自己家里的电闸。<br>当依赖的服务有大量超时时，在让新的请求去访问根本没有意义，只会无畏的消耗现有资源，比如我们设置了超时时间为1s，如果短时间内有大量请求在1s内都得不到响应，就意味着这个服务出现了异常，此时就没有必要再让其他的请求去访问这个服务了，这个时候就应该使用熔断器避免资源浪费</p><p>服务降级<br>有服务熔断，必然要有服务降级。<br>所谓降级，就是当某个服务熔断之后，服务将不再被调用，此时客户端可以自己准备一个本地的fallback（回退）回调，返回一个缺省值。 例如：(备用接口/缓存/mock数据)，这样做，虽然服务水平下降，但好歹可用，比直接挂掉要强，当然这也要看适合的业务场景</p>]]></content>
    
    <summary type="html">
    
      高并发下保证可用性的三大神器，缓存，限流，降级
    
    </summary>
    
      <category term="高并发" scheme="https://muxiaobai.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="基础" scheme="https://muxiaobai.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用ELK分析日志</title>
    <link href="https://muxiaobai.github.io/2019/05/18/%E4%BD%BF%E7%94%A8ELK%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97/"/>
    <id>https://muxiaobai.github.io/2019/05/18/使用ELK分析日志/</id>
    <published>2019-05-18T15:35:47.000Z</published>
    <updated>2019-12-25T02:04:12.465Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.elastic.co/cn/elk-stack" target="_blank" rel="noopener">elk 官网介绍</a><br>要解决的问题：<br>对于日志等文件，需要进行分析，例如：访问IP数，什么时候访问最多，用户量最大；<br>简单的架构就是直接使用filebeat来获取到数据。<br>还有一种实现方式是：拉取文件后，先通过Logstash（tools）把对应的文件分析出来，然后输出到ElasticSearch（data）中然后使用kibaba来进行虚拟化的展示（view）。<br>还可以加上output的输出到队列缓存中等。</p><h3 id="主要技术手段"><a href="#主要技术手段" class="headerlink" title="主要技术手段"></a>主要技术手段</h3><p>filebeat、Logstash、ElasticSearch、Kibaba</p><h5 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h5><p>通常会有一个客户端和一个服务器，客户端运行在业务应用机上，可以访问到对应的日志文件，<br>然后连接服务器，服务器把数据发送到Logstash中，也可以把数据直接output到ElasticSearch内。</p><p><img src="/2019/05/18/使用ELK分析日志/filebeat.png" alt="ElasticSearch控制台"></p><h5 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h5><p>Logstash把获取到的数据进行过滤（filter）处理，把找到的文件进行分析，输出到ElasticSearch,</p><h5 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h5><p>不用多讲，存储索引数据用的，基于Lucene，的分布式架构。在这种elk中充当数据源。</p><h5 id="Kibaba"><a href="#Kibaba" class="headerlink" title="Kibaba"></a>Kibaba</h5><p>visual展示</p><h3 id="示例-使用nginx日志来操作，简单版，不使用filebeat"><a href="#示例-使用nginx日志来操作，简单版，不使用filebeat" class="headerlink" title="示例 使用nginx日志来操作，简单版，不使用filebeat"></a>示例 使用nginx日志来操作，简单版，不使用filebeat</h3><p>定义的所有文件路径在<code>/c/ProgrmTool/dev/</code>中</p><h5 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h5><p>参考<a href="https://muxiaobai.github.io/2017/09/02/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E4%B9%8Bnginx%E8%B4%9F%E8%BD%BD/">应用部署之nginx负载</a></p><p><code>/c/ProgrmTool/dev/ &gt;start nginx</code></p><p>nginx 中的log_format格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br></pre></td></tr></table></figure><p>日志文件在../logs/access.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [19/May/2019:11:10:18 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">127.0.0.1 - - [19/May/2019:11:10:19 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://localhost/&quot; &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">127.0.0.1 - - [19/May/2019:11:10:19 +0800] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">127.0.0.1 - - [19/May/2019:11:36:05 +0800] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">127.0.0.1 - - [19/May/2019:11:36:05 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://localhost/&quot; &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><h5 id="配置-Logstash"><a href="#配置-Logstash" class="headerlink" title="配置 Logstash"></a>配置 Logstash</h5><p>把这个地址配置到Logstash中</p><p>测试：<code>./logstash -e &#39;input {stdin 0} output {studout 0}&#39;</code><br>从控制台输入，控制台输出，</p><p>验证grok是否正确：<a href="https://grokdebug.herokuapp.com/" target="_blank" rel="noopener">https://grokdebug.herokuapp.com/</a></p><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># Sample Logstash configuration for creating a simple</span><br><span class="line"># Beats -&gt; Logstash -&gt; Elasticsearch pipeline.</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">        file &#123;</span><br><span class="line">                path =&gt; &quot;C:/ProgramTool/dev/nginx/logs/access.log&quot;</span><br><span class="line">                type =&gt; &quot;nginx-access&quot;</span><br><span class="line">                start_position =&gt; &quot;beginning&quot;</span><br><span class="line">                #sincedb_path =&gt; &quot;/usr/local/logstash/sincedb&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">        if [type] == &quot;nginx-access&quot; &#123;</span><br><span class="line">                grok &#123;</span><br><span class="line">                    patterns_dir =&gt; &quot;C:/ProgramTool/dev/logstash-6.7.0/patterns&quot;        #设置自定义正则路径</span><br><span class="line">                    match =&gt; &#123;</span><br><span class="line">                        &quot;message&quot; =&gt; &quot;%&#123;NGINXACCESS&#125;&quot;</span><br><span class="line">                        #使用patterns路径下文件内部的解析名字</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                date &#123;</span><br><span class="line">                    match =&gt; [ &quot;log_timestamp&quot; , &quot;dd/MMM/YYYY:HH:mm:ss Z&quot; ]</span><br><span class="line">                &#125;</span><br><span class="line">                urldecode &#123;</span><br><span class="line">                    all_fields =&gt; true</span><br><span class="line">                &#125;</span><br><span class="line">            #把所有字段进行urldecode（显示中文）</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">        if [type] == &quot;nginx-access&quot; &#123;</span><br><span class="line">            stdout &#123;</span><br><span class="line">                codec    =&gt; rubydebug</span><br><span class="line">            &#125;</span><br><span class="line">            # 输出到控制台</span><br><span class="line">            elasticsearch &#123;</span><br><span class="line">                    hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">                    manage_template =&gt; true</span><br><span class="line">                    index =&gt; &quot;logstash-nginx-access-%&#123;+YYYY-MM-dd&#125;&quot;</span><br><span class="line">                    # 索引名称</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grok参数设置<code>C:/ProgramTool/dev/logstash-6.7.0/patterns</code>路径下设置nginx的匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NGINXACCESS %&#123;IPORHOST:clientip&#125; %&#123;HTTPDUSER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] &quot;(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:httpversion&#125;)?|%&#123;DATA:rawrequest&#125;)&quot; %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-) %&#123;QS:referrer&#125; %&#123;QS:agent&#125; %&#123;QS:x_forwarded_for&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cnblogs.com/Orgliny/p/5592186.html" target="_blank" rel="noopener">grok参数设置</a><br>更多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URIPARM1 [A-Za-z0-9$.+!*&apos;|()&#123;&#125;,~@#%&amp;/=:;_?\-\[\]]*</span><br><span class="line">URIPATH1 (?:/[A-Za-z0-9$.+!*&apos;()&#123;&#125;,~:;=@#%&amp;_\- ]*)+</span><br><span class="line">URI1 (%&#123;URIPROTO&#125;://)?(?:%&#123;USER&#125;(?::[^@]*)?@)?(?:%&#123;URIHOST&#125;)?(?:%&#123;URIPATHPARAM&#125;)?</span><br><span class="line">NGINXACCESS %&#123;IPORHOST:clientip&#125; %&#123;HTTPDUSER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] &quot;(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:httpversion&#125;)?|%&#123;DATA:rawrequest&#125;)&quot; %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-) %&#123;QS:referrer&#125; %&#123;QS:agent&#125; %&#123;QS:x_forwarded_for&#125;</span><br><span class="line">DEMOACCESS %&#123;IPORHOST:remote_addr&#125; - (%&#123;USERNAME:user&#125;|-) \[%&#123;HTTPDATE:log_timestamp&#125;\] %&#123;HOSTNAME:http_host&#125; %&#123;WORD:request_method&#125; \&quot;%&#123;URIPATH1:uri&#125;\&quot; \&quot;%&#123;URIPARM1:param&#125;\&quot; %&#123;BASE10NUM:http_status&#125; (?:%&#123;BASE10NUM:body_bytes_sent&#125;|-) \&quot;(?:%&#123;URI1:http_referrer&#125;|-)\&quot; (%&#123;BASE10NUM:upstream_status&#125;|-) (?:%&#123;HOSTPORT:upstream_addr&#125;|-) (%&#123;BASE16FLOAT:upstream_response_time&#125;|-) (%&#123;BASE16FLOAT:request_time&#125;|-) (?:%&#123;QUOTEDSTRING:user_agent&#125;|-) \&quot;(%&#123;IPV4:client_ip&#125;|-)\&quot; \&quot;(%&#123;WORD:x_forword_for&#125;|-)\&quot;</span><br></pre></td></tr></table></figure></p><p>上面用到正则切割日志等功能</p><p>启动：<code>./logstash -f ../config/logstash.conf &amp;</code><br><code>./logstash -f ../config/logstash.conf --path.data=C:/ProgramTool/dev/logstash-6.7.0/data</code><br>如果有一个实例的话，启动时，需要指定path.data</p><h5 id="简单的es主从"><a href="#简单的es主从" class="headerlink" title="简单的es主从"></a>简单的es主从</h5><p>master 默认9200端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">cluster.name: muxiaobai-test</span><br><span class="line">node.name: master</span><br><span class="line">node.master: true</span><br><span class="line"></span><br><span class="line">network.host: 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>slave-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: muxiaobai-test</span><br><span class="line">node.name: slave-1</span><br><span class="line">#node.master: true</span><br><span class="line"></span><br><span class="line">network.host: 127.0.0.1</span><br><span class="line">http.port: 9300</span><br><span class="line"></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1&quot;]</span><br></pre></td></tr></table></figure></p><p>slave-2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: muxiaobai-test</span><br><span class="line">node.name: slave-2</span><br><span class="line">#node.master: true</span><br><span class="line"></span><br><span class="line">network.host: 127.0.0.1</span><br><span class="line">http.port: 9400</span><br><span class="line"></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1&quot;]</span><br></pre></td></tr></table></figure></p><h5 id="使用elastic-head-图形化工具查看运行情况"><a href="#使用elastic-head-图形化工具查看运行情况" class="headerlink" title="使用elastic-head 图形化工具查看运行情况"></a>使用elastic-head 图形化工具查看运行情况</h5><p><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">elastic-head github</a><br>需要node环境<br><code>npm install</code> <code>npm run start</code>默认9100端口 访问<a href="http://127.0.0.1:9100" target="_blank" rel="noopener">http://127.0.0.1:9100</a></p><p><img src="/2019/05/18/使用ELK分析日志/elasticsearch-init.png" alt="Logstash日志进入ElasticSearch"></p><h5 id="使用kibaba"><a href="#使用kibaba" class="headerlink" title="使用kibaba"></a>使用kibaba</h5><p>默认端口5601，<a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a>,把对应的索引加进去。</p><h4 id="操作如下"><a href="#操作如下" class="headerlink" title="操作如下"></a>操作如下</h4><p>首先访问 nginx ，地址：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></p><p>然后可以看到Logstash窗口输出的日志</p><p><img src="/2019/05/18/使用ELK分析日志/logstash-nginx.png" alt="ElasticSearch控制台"></p><p><a href="http://localhost:9100,中，可以看到访问日志的内容" target="_blank" rel="noopener">http://localhost:9100,中，可以看到访问日志的内容</a><br>效果如下：<br><img src="/2019/05/18/使用ELK分析日志/elasticsearch-header.png" alt="Logstash日志进入ElasticSearch"><br>具体切分的数据<br><img src="/2019/05/18/使用ELK分析日志/data1.png" alt="Logstash日志进入ElasticSearch"></p><p><img src="/2019/05/18/使用ELK分析日志/data2.png" alt="Logstash日志进入ElasticSearch"></p><p>创建了索引后，<br><img src="/2019/05/18/使用ELK分析日志/kibaba2.png" alt="Logstash日志进入ElasticSearch"><br>在kibaba中有默认的时间线，访问次数，即可展示<br><img src="/2019/05/18/使用ELK分析日志/kibaba4.png" alt="Logstash日志进入ElasticSearch"></p><h3 id="使用filebeat"><a href="#使用filebeat" class="headerlink" title="使用filebeat"></a>使用filebeat</h3><p><a href="https://www.elastic.co/guide/en/beats/filebeat/7.0/filebeat-module-nginx.html#nginx-settings" target="_blank" rel="noopener">nginx filebeat 配置</a></p><p>已经有模板，使用的时候先开启，然后安装，最后启动即可</p><ul><li><code>filebeat  modules enable nginx</code></li><li><code>filebeat setup -e</code></li><li><code>filebeat</code></li><li></li></ul><p>nginx.yml配置文件，需要指定日志文件路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- module: nginx</span><br><span class="line">  access:</span><br><span class="line">    enabled: true</span><br><span class="line">    var.paths: [&quot;C:/ProgramTool/dev/nginx/logs/access.log*&quot;]</span><br><span class="line">  error:</span><br><span class="line">    enabled: true</span><br><span class="line">    var.paths: [&quot;C:/ProgramTool/dev/nginx/logs/error.log*&quot;]</span><br></pre></td></tr></table></figure></p><p>默认直接输出到ElasticSearch</p><p>然后在Logstash的配置文件中使用beat作为input，输入源。<br>主要是input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">    host =&gt; &quot;0.0.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>logstash.conf 默认配置就是从beat中获取数据的</p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/aresxin/p/8035137.html" target="_blank" rel="noopener">ELK系统框架图</a></li><li><a href="https://www.colabug.com/2936270.html" target="_blank" rel="noopener">filebeat和Logstash配合使用</a></li><li><a href="https://github.com/elastic/logstash/blob/88563c86435926a8e5353bd970f92ab61efe58ec/docs/static/filebeat_modules/nginx/pipeline.conf" target="_blank" rel="noopener">官网 Logstash中的beat nginx 配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      日志分析系统搭建
    
    </summary>
    
      <category term="工具" scheme="https://muxiaobai.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="分析" scheme="https://muxiaobai.github.io/tags/%E5%88%86%E6%9E%90/"/>
    
      <category term="日志" scheme="https://muxiaobai.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux 基础命令总结4 shell 快捷键 ps</title>
    <link href="https://muxiaobai.github.io/2019/04/01/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%934/"/>
    <id>https://muxiaobai.github.io/2019/04/01/Linux-基础命令总结4/</id>
    <published>2019-03-31T21:19:12.000Z</published>
    <updated>2020-04-29T08:29:54.605Z</updated>
    
    <content type="html"><![CDATA[<h4 id="shell-常用快捷键"><a href="#shell-常用快捷键" class="headerlink" title="shell 常用快捷键"></a>shell 常用快捷键</h4><p><a href="https://blog.csdn.net/weixin_42256178/article/details/80392077" target="_blank" rel="noopener">常用shell快捷键</a></p><ul><li>ctrl + a 命令行首</li><li>ctrl + e 命令行尾（end）</li><li>ctrl + b 相当于方向键左←（）</li><li>ctrl + f 相当于方向键右→</li><li></li><li>ctrl + u 剪切光标到行首</li><li>ctrl + k 剪切光标到行尾</li><li>ctrl + w 剪切光标前一个单词</li><li>ctrl + y 粘贴上面三个的复制</li><li>ctrl + z 挂起当前命令 jobs bg fg  唤醒</li><li></li><li>ctrl + r 搜索之前的命令</li><li>ctrl + g 取消搜索<br>-</li><li>ctrl + s 锁屏，挂起当前shell</li><li>ctrl + q 取消锁屏，重新启用当前shell</li><li><p>ctrl + l clear 清屏</p></li><li><p>ctrl + insert 插入</p></li></ul><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><ul><li>ps -ef | grep tomcat </li><li>ps -aux | sort -k4nr |head -h 10 内存前十的进程</li><li>du -sh *   当前路径（disk usage）</li><li>df -hP  整个磁盘（disk free）</li><li>df -k /tmp 查看磁盘使用</li><li>crontab -l 定时任务</li><li>tail -f -n 200 /root/file.log 查看实时日志文件</li><li>free -h 查询内存文件</li><li>/var/log/messages 系统日志，</li><li>service /etc/init.d  启动脚本位置</li><li>netstat -ano | grep 端口占用</li><li>netstat -tlnp | grep 端口占用</li></ul><p>wget 判断端口<br>curl</p><p><img src="/2019/04/01/Linux-基础命令总结4/wget测试端口.png" alt="wget"></p>]]></content>
    
    <summary type="html">
    
      shell快捷件键，常用命令
    
    </summary>
    
      <category term="Linux" scheme="https://muxiaobai.github.io/categories/Linux/"/>
    
    
      <category term="基础命令" scheme="https://muxiaobai.github.io/tags/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>性能优化之redis储存计算值</title>
    <link href="https://muxiaobai.github.io/2019/02/16/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bredis%E5%82%A8%E5%AD%98%E8%AE%A1%E7%AE%97%E5%80%BC/"/>
    <id>https://muxiaobai.github.io/2019/02/16/性能优化之redis储存计算值/</id>
    <published>2019-02-15T20:17:43.000Z</published>
    <updated>2019-02-16T05:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>两张表，一个主表，一个树形结构表，</p><p>每一条树形结构数据都有一个状态，要统计出所有叶子节点的状态，展示在主表的列上，前期使用了oracle的<code>start connect</code>统计根节点，在前期主表中的数据量很小的时候，列表价在正常，后期数据量增大，列表响应速度异常。后经过分析，得出每一条根节点循环的时候需要600ms左右，然后数据增大直接是主表的600ms*n。</p><p>树形结构超过三级，前两级结构超过50条记录，</p><h2 id="优化路思路："><a href="#优化路思路：" class="headerlink" title="优化路思路："></a>优化路思路：</h2><p>redis优化查询结果，因为是计算结果，这种数据，在数据库上执行第一次,随后再次查询列表的时候从缓存中获取，减少计算次数。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询的时候先从redis中查询，如果有直接返回；如果没有，再查数据库，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//查询状态,有num直接返回:</span><br><span class="line"></span><br><span class="line">if(Redis.isCached(key, FORP.SPRING_CONTEXT.getBean(&quot;applicationPool&quot;, JedisPool.class)))&#123;</span><br><span class="line">return Integer.parseInt(Redis.getString(key, FORP.SPRING_CONTEXT.getBean(&quot;applicationPool&quot;, JedisPool.class)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询出的结果</span><br><span class="line">String sql =  &quot; select count(*) as num &quot;</span><br><span class="line">+ &quot; from pre_dutysubitem t1 ,pre_dutyitem t2 &quot;</span><br><span class="line">+ &quot; where t2.fk_dutyid = ?  &quot;</span><br><span class="line">+ &quot; and (select  count(*) from pre_dutysubitem t3 &quot;</span><br><span class="line">+ &quot; start with t3.id = t1.id &quot;</span><br><span class="line">+ &quot; connect by prior t3.id =t3.fk_parentid ) = 1 &quot;</span><br><span class="line">+ &quot; and t2.id=t1.fk_dutyitemid and t1.currstatus is not null &quot;;</span><br><span class="line">SqlRowSet rs = null;</span><br><span class="line"></span><br><span class="line">//如果currStatus没值查统计全部子项数量，否则按状态统计</span><br><span class="line">if(StringUtils.isNotBlank(currStatus))&#123;</span><br><span class="line">sql+=&quot; and t1.currstatus = ?  &quot;;</span><br><span class="line">rs = jdbc.queryForRowSet(sql, dutyId, currStatus);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">rs = jdbc.queryForRowSet(sql, dutyId);</span><br><span class="line">&#125;</span><br><span class="line">int num = 0;</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">num =rs.getInt(&quot;num&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//缓存查询结果</span><br><span class="line">Redis.cacheString(key, String.valueOf(num), FORP.SPRING_CONTEXT.getBean(&quot;applicationPool&quot;, JedisPool.class));</span><br><span class="line"></span><br><span class="line">return num;</span><br></pre></td></tr></table></figure><h4 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h4><p>修改状态的时候，先删除redis缓存，再更改数据库状态，可能会出现刚删除，数据库还没来得及更改，又有用户查询，导致redis缓存脏数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//更新数据状态</span><br><span class="line">//删除缓存状态：</span><br><span class="line"></span><br><span class="line">Redis.delete(key, FORP.SPRING_CONTEXT.getBean(&quot;applicationPool&quot;, JedisPool.class));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      redis存储值解决性能问题
    
    </summary>
    
      <category term="性能优化" scheme="https://muxiaobai.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="redis" scheme="https://muxiaobai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>2018年个人总结</title>
    <link href="https://muxiaobai.github.io/2019/01/15/2018%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://muxiaobai.github.io/2019/01/15/2018年个人总结/</id>
    <published>2019-01-14T20:19:28.000Z</published>
    <updated>2020-04-20T12:14:14.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作，个人技能"><a href="#工作，个人技能" class="headerlink" title="工作，个人技能"></a>工作，个人技能</h2><h4 id="新事物、新工具"><a href="#新事物、新工具" class="headerlink" title="新事物、新工具"></a>新事物、新工具</h4><ul><li>自己前期对一些node等命令了解一些，现在通过在项目中使用，更加熟悉，像node、 npm、yarn、vs code 等工具。使用electron，可以实现在win和mac平台上打包成程序。</li><li>Hbuilder工具可以打包成Android和ios上的应用。</li><li>MongoDB redis等基本命令；之前也想着看，但是只是了解到一点儿内容，没有实际的使用，并没有把握，现在这些东西都可以说是熟悉了。</li><li>更新系统可以基本实现脚本化，并且可以保留原始备份应用，之前一直都在写，后来因为window server的原因，中断了，现在又使用起来，肯定要把这部分的知识拾起来，深入一下了。</li><li>杨百翰Coca语料库网站使用，antconc语料分析工具，如果工作上也出现这种没有接触过的工具，应该怎么处理？ </li></ul><h4 id="如何接触新事物、学习新工具"><a href="#如何接触新事物、学习新工具" class="headerlink" title="如何接触新事物、学习新工具"></a>如何接触新事物、学习新工具</h4><p>新事物、新工具这类可以统称为“我的未知世界”、“我的盲区”。</p><p>可以分为三类，一类是知道，简单的使用过，没有深入研究，参加使用英语语种讨论；第二类是听说过，但没有使用过，这类和第三类没有什么区别，参加使用，日语韩语德语等语种研讨，第三类是听都没有听说过，这种是有很大的专业性壁垒，类似去参加一场不知道是什么语言的研讨；</p><p>明确一点的是首先要知道这个工具是做什么用的？出现这个工具，肯定是有一些背景的，为什么会出现，这就是原因，然后找一下有没有类似的工具，可以参考的理念性的，因为同一类工具，是解决同一类问题，，背后会有一定的原理性的东西存在。这样的东西把握住了之后，就能把握主旨。</p><p>最次一级的是怎么使用这个工具？但这个也是最实用的一点。具体的使用情况，在具体用的时候再去研究，这样就能节省时间；人的精力是有限的，之前一位老师和我这么讲的时候，我还总觉得无所谓，我的精力无限，但是现在看来，该听的话还是要听一下的，把时间用在最需要研究的地方。</p><blockquote><p>最后一条，网络如此发达，谷歌百度为何不用？老师在你身边，怎能不好好学习。</p></blockquote><blockquote><p>方法论比方法更重要。</p></blockquote><h4 id="计划性、把控方面"><a href="#计划性、把控方面" class="headerlink" title="计划性、把控方面"></a>计划性、把控方面</h4><p>分两部分，一个是对整体的项目规划性</p><p>计划性认知，比之前有很大的提升，最开始在学校的时候，虽然也是带项目，但是对于一个项目的整体规划，整体到什么阶段，要做到什么事情，要给客户展示什么内容，缺乏认识；只是一味的往前做，没有给客户一个安心，每一个周期做什么东西了，并没有给客户。这样客户的感觉就是很随意，看到什么就做什么。</p><p>二是对任务的把控方面</p><p>能够把任务进行分解，分模块，按步骤进行处理。可以大致预估任务的复杂度，预计的人天,这可以说是提升最大的软技能，上一份工作中，只是对自己能力的预估，慢慢的掌握住方法；任务复杂或者简单，和负责人说有多少内容，慢慢的自己就有了一点感觉，在对别人的时间把控方面也有了提升，这点还要通过看别人的代码，逐渐建立起来的体系。</p><h4 id="分析问题，解决问题"><a href="#分析问题，解决问题" class="headerlink" title="分析问题，解决问题"></a>分析问题，解决问题</h4><p>例如：①有一个树形查询的oracle语句，在数据量少的时候很快就可以查出来列表，数据量大之后，因为每一条数据都要统计其他的信息，列表就要加载很久，最后采用redis的形式，存储这个计算出来的值。</p><p>在影响这个计算值的时候，把redis中的数据清空，在查询的时候把这个值填到redis中，下次列表查询的时候就直接使用这个值，具体可以参考其他的文章<a href="https://muxiaobai.github.io/2019/02/16/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bredis%E5%82%A8%E5%AD%98%E8%AE%A1%E7%AE%97%E5%80%BC/">性能优化之redis储存计算值</a></p><p>②有一个列表，后台响应很快，大概300ms的时间，数据都已经到前台了，但是前台的页面重新layout，又采用的是easyui的组件，因此通过chrome的Performance来进行积累渲染的过程，优化前台的渲染逻辑，从而达到要求。</p><blockquote><p>这个实际上也是因为平时经常看一些文章，所以就有这方面的想法，算是厚积薄发吧，还是要注重积累，现在如果分析到响应速度呀等，就先从前后台的交互位置查起，看是前台，还是后台的问题导致的，再进一步找后台sql还是循环，是数据量大，传输过程，网络影响，还是前台渲染的时候有问题。</p></blockquote><p>遇到问题应该找谁来解决，协调，把握几点吧，自己能解决的问题，说出大概的时间解决，自己解决不了的问题，找相关人员解决，自己不知道找谁来解决的问题，向领导反馈，这些基本的逻辑，有的时候还真的是没呢么容易做到，一般总是想着我来做我来做，但是呢，一个人的精力有限，该分出去的就要分出去，有时，可能就会想着都经过自己的话，就知道，能把控，可是，该放松的该授权的就要授权。</p><p>####</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h4 id="踏过的地方"><a href="#踏过的地方" class="headerlink" title="踏过的地方"></a>踏过的地方</h4><p>踏过的城市：南阳、枣庄、西安、宝鸡太白、深圳、香港、广西河池-柳州、杭州</p><blockquote><p>西安  正南正北的规矩，古代皇宫式的华丽</p></blockquote><p>北方真不是人呆的地方，夏天热的要死，冬天雾霾让人无法呼吸，还是南方好，不冷，空气好，就是离家远了点儿，西安的夏天高达40度，怎么玩？玩不了丫。还是喜欢走路上班。从第一份工作，到现在，上下班都是住宿和公司都是相差不远的，走路，还可以锻炼一下身体，棒棒哒！！！</p><blockquote><p>宝鸡太白 看秦岭云海  高山云海之上，神仙居住的地方</p></blockquote><p>山里面凉快，真的是很凉快，在里面看的水还好一点，但是在一条路上，有一个缺口，可能就是在这里突出一下秦岭的威严，天然的露出了一个小口子，让你们看看，在我大秦岭面前，你们这些小如蝼蚁的人们，都给我臣服吧。再来插播一条，云海去看过的都说好。ps：并没有收广告费。</p><blockquote><p>香港 去体验一把，维多利亚港 高楼，海港，游轮，帆船</p></blockquote><p>登上游轮，吹着海风，别有一番滋味，想到一句话：你以为有钱人是幸福的，实际上，有钱人的幸福你想都想不到。莎莎、万宁、屈臣氏、卓悦，遍地，人挨人，人挤人，护肤品，化妆品，奶粉，保健品（贴膏），很奇怪，奶粉和保健品会在这里售卖?<br>电影里面总能看到有人拿的是一卷钱，用卷起来的，这次过去换港币的时候，真的是这样子的，我跑到一个小的巷道里面，找的是一个比较正规的柜台，当时，旁边有很多那种“一卷”钱，在香港这种地方，没有港币真的很麻烦，很多地方还是只收现金，1000的不收。不像大陆地区，哪怕没有带现金，吃穿玩，一切都正常。<br>想象中的紫金花广场应该很霸气的，到跟前一看，哎呀，还不如大陆的一个小广场，不过还是拍照留念了一下。毕竟来了一趟，不容易呢。</p><blockquote><p>广西河池 看山看水 山水一体，原始山川河流</p></blockquote><p>抖音小视频，山顶上转圈，转圈，我真的是去了，虽然是在不知名的小山顶上，但是这也是山丫，感觉很舒服，和秦岭的山水，和香港的海风是完全不一样的感觉，这里的山水，是小景，是一种温文尔雅的舒适感，坐船真坐的够够的了，不贵，而且将近一个小时，回来的路上，坐的人们都是冷飕飕的，刘三姐的故事，在广西真的是随处都是，路桥，山里，坊间，一会儿说是桂林阳朔的，一会说是河池宜州。本来就是游山玩水，历史问题就不再考究。听说这里的人们还在唱山歌，原来山间人家，自有山间的一些儿玩法，中原人没有见过的，就觉得神奇，唱的都是人家自己的语言和调调。</p><blockquote><p>柳州 近代工业  一种厚重，有工业底蕴的城市</p></blockquote><p>螺蛳粉真的是有螺蛳的，螺蛳熬得汤，加酸笋，加腐竹，加豆泡（豆腐泡），加卤水。</p><p>柳江从中穿过，别称“壶城”，柳州城有很多桥，当时已经建好的有21座，还有在规划中的，为了交通，横穿柳江过来，桥梁工程应该是很发达的；柳工，柳钢，五菱，重工业基地，双面针，金嗓子等，柳钢雪条，雪糕，是一座小城，和惠州，徐州很像，但是没有惠州那么浮躁，没有徐州那么庄重，个人感觉柳州很随和，但也很稳。</p><blockquote><p>杭州 西湖加现代设计的一种和谐</p></blockquote><p>听说是有：西湖醋鱼，龙井虾仁 八宝豆腐等。楼外楼。真的只是听说，去一周，直接就回来了，什么都没有带，遗憾，还说带一点茶叶回来呢，西湖，龙井绿茶，不过自己出去跑一趟，就很好的了。</p><blockquote><p>实际上只要看到外部的，未经历过的，都是心情舒畅。</p></blockquote><h4 id="公开课"><a href="#公开课" class="headerlink" title="公开课"></a>公开课</h4><p>前段时间一直在看心理学的公开课，说实话，收获挺大的，早就想看一些这种社会学心理学的内容，这也是<code>下一年重点内容</code>，</p><h4 id="经历过的事情"><a href="#经历过的事情" class="headerlink" title="经历过的事情"></a>经历过的事情</h4><blockquote><p>辞职和找工作、要福利</p></blockquote><p>和领导说辞职的时候，一定要挺住，别放松，说一个月才能办理，咱就要要一周就能出结果。很多情况下，只不过是口头上说，一般不是要职人员，当前没有必要的项目，那么这种流程很快就能结束的，一个月，待在那里还不要疯了，何必在那里碍眼。找工作的时候，该问清楚的就要问清楚，该有的利益福利，该要就要。有些话适合说清楚，就别含糊。</p><blockquote><p>学会拒绝</p></blockquote><p>上级，上次一个任务，我明确的和上级说过，可能会出现这种问题，需要我们这边提供帮助，可是呀，他说不用我们这边，不用，结果，两天之后，果然还是出现这种问题了，然后又打电话让我给他解决，我就说现在没有时间，要到晚上才行。想其他办法，我估计，还是会找我来进行处理。</p><p>该跑的坑就要跑，上一任技术走了，眼看当下没有人接手，烫手的山芋，让我接，都不是傻瓜。我还是选择出去待在项目上，能跟着实力强的人再学习，何乐而不为呢？蚂蚁金服，唯一对不住的就是她，刚回去，就又跑了。</p><p>亲友，为什么亲属长辈问我有没有钱？真的是很无语，果断拒绝。当时我就不抱有给他的可能，因为我也知道这种人，但像同学，这次问我借钱的时候，我直接问他要多少，有什么事情要帮忙的，有的时候，亲戚这种关系更不能掺和利益，麻烦，说不清，道不明，反而惹得都不舒服。</p><blockquote><p>学会表达自己的真实感受</p></blockquote><p>没有表达好，直言快语，有话直说，工作上在对待上司，工资等，简单一点儿，直接一点儿，省的把自己搞的很累，还过得不舒服。有不知道的就直接问，</p><blockquote><p>学会控制自己的真实感受</p></blockquote><p>从心理学学到的，而且在生活中经历过的。</p><ul><li>1.避免表达出事后诸葛亮的一种态度。</li><li>2.想解决办法，而不是制造麻烦。</li><li>3.有时候太直白，不利于团队团结。</li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><h4 id="2018年计划完成情况"><a href="#2018年计划完成情况" class="headerlink" title="2018年计划完成情况"></a>2018年计划完成情况</h4><ul><li>人不要脸，书不能丢，一个月一本书。要有记录</li><li>画一画自己知识体系，思维导图（包括但不限于JAVA、JS、CSS、browser、network、）</li><li>hello world 大数据 sparker等 demo</li><li>kaggle等课程熟悉，完成5次天池比赛</li></ul><p>完成度20%</p><p>没有驱动性，自驱力差；机器学习只学了点儿皮毛，kaggle完成2个，熟悉大致的操作流程，无法商用。后半年都没有实际操作。反倒是MongoDB、redis等工具开始用起来；运维方面的知识掌握不少，把之前简单的脚本重新掌握并应用了。</p><h4 id="2019年计划"><a href="#2019年计划" class="headerlink" title="2019年计划"></a>2019年计划</h4><ul><li>听讲座，参加技术，文化，社会论坛等，扩展知识广度。</li><li>心理学知识，受益匪浅，需要继续学习。</li><li>研究服务器性能、部署等问题，分析出自己的一套配置。</li><li></li></ul><p>2019.01.15 慕小白 于浙江杭州</p>]]></content>
    
    <summary type="html">
    
      2018年已经过去，总结一下。
    
    </summary>
    
      <category term="总结" scheme="https://muxiaobai.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2018" scheme="https://muxiaobai.github.io/tags/2018/"/>
    
  </entry>
  
</feed>
