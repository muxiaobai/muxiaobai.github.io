<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕小白的博客</title>
  
  <subtitle>有输入,有输出</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muxiaobai.github.io/"/>
  <updated>2022-05-06T10:08:36.014Z</updated>
  <id>https://muxiaobai.github.io/</id>
  
  <author>
    <name>Mu Xiaobai(慕小白)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>devops之k8s</title>
    <link href="https://muxiaobai.github.io/2021/08/19/devops%E4%B9%8Bk8s/"/>
    <id>https://muxiaobai.github.io/2021/08/19/devops之k8s/</id>
    <published>2021-08-19T09:35:35.000Z</published>
    <updated>2022-05-06T10:08:36.014Z</updated>
    
    <content type="html"><![CDATA[<p>kubectl apply -f kuboard_2021_01_29_11_27_09.yaml</p><p>kubectl get svc –all-namespaces</p><p>kubectl get pods –namespace ns | grep app<br>kubectl get pv -A</p><p>进入执行<br>kubectl -n ns  exec -it svc-app-877df6545-j7dzd sh<br>获取日志<br>kubectl -n ns  logs  -f svc-app-877df6545-j7dzd</p><p>kubectl -n ns  logs –tail=200  -f svc-app-877df6545-j7dzd</p><p>拷贝文件<br>kubectl cp ns/svc-app-search-fb47d75bb-xz8pd:var/d/application.yml application.yaml<br>kubectl cp application.yaml ns/svc-app-search-fb47d75bb-xz8pd:var/d/application.yml</p><p>kubectl patch pv pvc-8477bd20-ffbe-4fa2-85b9-f864d7b3690c  -p ‘{“metadata”:{“finalizers”:null}}’ –type=merge<br>kubectl patch pvc elasticsearch-master-db-elasticsearch-0 -p ‘{“metadata”:{“finalizers”:null}}’ –type=merge</p>]]></content>
    
    <summary type="html">
    
      Kubernetes常用命令
    
    </summary>
    
      <category term="devops" scheme="https://muxiaobai.github.io/categories/devops/"/>
    
    
      <category term="devops" scheme="https://muxiaobai.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之MVC的注册和调用</title>
    <link href="https://muxiaobai.github.io/2021/07/20/SpringBoot%E4%B9%8BMVC%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E8%B0%83%E7%94%A8/"/>
    <id>https://muxiaobai.github.io/2021/07/20/SpringBoot之MVC的注册和调用/</id>
    <published>2021-07-20T16:18:02.000Z</published>
    <updated>2022-05-06T10:08:35.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC的DispatcherServlet注册到tomcat中"><a href="#SpringMVC的DispatcherServlet注册到tomcat中" class="headerlink" title="SpringMVC的DispatcherServlet注册到tomcat中"></a>SpringMVC的DispatcherServlet注册到tomcat中</h2><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/注册流程.png" alt="注册流程"></p><p>直接从org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh中看起，<br>重写onRefresh方法创建WebServer;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#createWebServer</span><br><span class="line">private void createWebServer() &#123;</span><br><span class="line">    WebServer webServer = this.webServer;</span><br><span class="line">    ServletContext servletContext = getServletContext();</span><br><span class="line">    if (webServer == null &amp;&amp; servletContext == null) &#123;</span><br><span class="line">        ServletWebServerFactory factory = getWebServerFactory();//这里获取了一个工厂</span><br><span class="line">        this.webServer = factory.getWebServer(getSelfInitializer());//getSelfInitialzer()方法获取了一些需要实现ServletContextInitializer的对象，在StandardContext启动的时候，会之心onStartup()方法。</span><br><span class="line">    &#125;else if (servletContext != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getSelfInitializer().onStartup(servletContext);//这里如果没有servletContext的话就直接执行这些onStartup方法。</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ServletException ex) &#123;</span><br><span class="line">            throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory#getWebServer</span><br><span class="line">这里传入的getSelfInitializer()会在StandardContext start的时候执行onStartup方法。</span><br><span class="line">@Override</span><br><span class="line">public WebServer getWebServer(ServletContextInitializer... initializers) &#123;</span><br><span class="line">    Tomcat tomcat = new Tomcat();// 这个就是一个tocmat里面会添加两大组件 Connector和Container</span><br><span class="line">    File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;);</span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    Connector connector = new Connector(this.protocol);</span><br><span class="line">    tomcat.getService().addConnector(connector);//通过查看tomcat类方法，getService()会，getServer()里面 StandardService放在StandardServer然后把connector放在当前的StandardService中</span><br><span class="line">    customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);//此处在所有的service中设置Connector</span><br><span class="line">    tomcat.getHost().setAutoDeploy(false);//这里会设置一个StandardHost放在StandardEngine中</span><br><span class="line">    configureEngine(tomcat.getEngine());//这里会获取service设置一个StandardEngine</span><br><span class="line">    for (Connector additionalConnector : this.additionalTomcatConnectors) &#123;</span><br><span class="line">        tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">    &#125;</span><br><span class="line">    prepareContext(tomcat.getHost(), initializers);//这里把需要initialzers的ServletContextInitialzer放到</span><br><span class="line">    return getTomcatWebServer(tomcat);// 最终返回的就是一个TomcatWebServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) &#123;</span><br><span class="line">    return new TomcatWebServer(tomcat, getPort() &gt;= 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化的时候会执行<code>initialize</code>,里面有启动<code>this.tomcat.start();</code>就是当前的Tomcat的启动。</p><p>重点看两个<code>prepareContext(tomcat.getHost(), initializers);</code>是准备了一个<code>TomcatEmbeddedContext</code>放在host里面<br><img src="/2021/07/20/SpringBoot之MVC的注册和调用/TomcatEmbeddedContext.png" alt="TomcatEmbeddedContext"><br>可看出来，这就是一个 StandardContext也是一个Container组件，就是tomcat的两个组件之一，另外一个是Connector。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareContext(Host host, ServletContextInitializer[] initializers) &#123;</span><br><span class="line">File documentRoot = getValidDocumentRoot();</span><br><span class="line">TomcatEmbeddedContext context = new TomcatEmbeddedContext();//新建一个  StandardContext</span><br><span class="line">if (documentRoot != null) &#123;</span><br><span class="line">context.setResources(new LoaderHidingResourceRoot(context));</span><br><span class="line">&#125;</span><br><span class="line">context.setName(getContextPath());</span><br><span class="line">context.setDisplayName(getDisplayName());</span><br><span class="line">context.setPath(getContextPath());</span><br><span class="line">File docBase = (documentRoot != null) ? documentRoot : createTempDir(&quot;tomcat-docbase&quot;);</span><br><span class="line">context.setDocBase(docBase.getAbsolutePath());</span><br><span class="line">context.addLifecycleListener(new FixContextListener());</span><br><span class="line">context.setParentClassLoader((this.resourceLoader != null) ? this.resourceLoader.getClassLoader()</span><br><span class="line">: ClassUtils.getDefaultClassLoader());</span><br><span class="line">resetDefaultLocaleMapping(context);</span><br><span class="line">addLocaleMappings(context);</span><br><span class="line">context.setUseRelativeRedirects(false);</span><br><span class="line">...</span><br><span class="line">configureTldSkipPatterns(context);</span><br><span class="line">WebappLoader loader = new WebappLoader(context.getParentClassLoader());</span><br><span class="line">loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName());</span><br><span class="line">loader.setDelegate(true);</span><br><span class="line">context.setLoader(loader);</span><br><span class="line">if (isRegisterDefaultServlet()) &#123;</span><br><span class="line">addDefaultServlet(context);//在context中添加默认的Servlet处理</span><br><span class="line">&#125;</span><br><span class="line">if (shouldRegisterJspServlet()) &#123;</span><br><span class="line">addJspServlet(context);//添加默认Jsp处理</span><br><span class="line">addJasperInitializer(context);</span><br><span class="line">&#125;</span><br><span class="line">context.addLifecycleListener(new StaticResourceConfigurer(context));</span><br><span class="line"></span><br><span class="line">ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);</span><br><span class="line">host.addChild(context);// StandardHost 添加context，</span><br><span class="line">configureContext(context, initializersToUse);</span><br><span class="line">postProcessContext(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>configureContext(context, initializersToUse);</code>最后再配置一下</p><p>这个里面是初始化了一个TomcatStarter放在context中作为一个Servlet容器也就是放在，StandardContext的initializers中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void configureContext(Context context, ServletContextInitializer[] initializers) &#123;</span><br><span class="line">    TomcatStarter starter = new TomcatStarter(initializers);</span><br><span class="line">    if (context instanceof TomcatEmbeddedContext) &#123;</span><br><span class="line">        TomcatEmbeddedContext embeddedContext = (TomcatEmbeddedContext) context;</span><br><span class="line">        embeddedContext.setStarter(starter);</span><br><span class="line">        embeddedContext.setFailCtxIfServletStartFails(true);</span><br><span class="line">    &#125;</span><br><span class="line">    context.addServletContainerInitializer(starter, NO_CLASSES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在StandardContext是LifecycleBase的子类，因此在Lifecycle的start的时候就会执行下面的startInternal(),<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected synchronized void startInternal() throws LifecycleException &#123;</span><br><span class="line">    for (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :initializers.entrySet()) &#123;</span><br><span class="line">        //这里是ToncatStarter的执行，</span><br><span class="line">        entry.getKey().onStartup(entry.getValue(),getServletContext());//getServletContext() 会 new ApplicationContext(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里面的ServletContainerInitialzer就是上面TomcatStarter 然后执行TomcatStarter的onStartup方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (ServletContextInitializer initializer : this.initializers) &#123;</span><br><span class="line">    //将当前的ServletContextInitializer启动执行,</span><br><span class="line">    initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就找到了最初始的getSelfInitializer()中的对象开始执行onStartup方法。<code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#getSelfInitializer</code></p><h4 id="看一下-getSelfInitializer-怎么添加的"><a href="#看一下-getSelfInitializer-怎么添加的" class="headerlink" title="看一下 getSelfInitializer() 怎么添加的"></a>看一下 getSelfInitializer() 怎么添加的</h4><p>这里的启动<code>initializer.onStartup(servletContext);</code>即 <code>getSelfInitializer().onStartup(servletContext)</code>也验证了<code>createWebServer()</code>方法里面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void selfInitialize(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">    prepareWebApplicationContext(servletContext);</span><br><span class="line">    registerApplicationScope(servletContext);</span><br><span class="line">    WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);</span><br><span class="line">    for (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123;</span><br><span class="line">        beans.onStartup(servletContext);//这里就直接执行了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的<code>getServletContextInitializerBeans()</code>是一个集合，在递归循环的时候返回，所以就是<code>this.sortedList</code>的循环onStartup(),</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#getServletContextInitializerBeans</span><br><span class="line"></span><br><span class="line">protected Collection&lt;ServletContextInitializer&gt; getServletContextInitializerBeans() &#123;</span><br><span class="line">    return new ServletContextInitializerBeans(getBeanFactory());//此处获取的即ServletContextInitializerBeans集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>org.springframework.boot.SpringApplication#run(java.lang.String...)</code>中有<code>context = createApplicationContext();</code>的时候，创建了beanFactory,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public GenericApplicationContext() &#123;</span><br><span class="line">    this.beanFactory = new DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">可以看出此处是集合类，会递归</span><br><span class="line">public class ServletContextInitializerBeans extends AbstractCollection&lt;ServletContextInitializer&gt; &#123;</span><br><span class="line">    //递归调用的是 this.sortedList</span><br><span class="line">@Override</span><br><span class="line">public Iterator&lt;ServletContextInitializer&gt; iterator() &#123;</span><br><span class="line">return this.sortedList.iterator();</span><br><span class="line">&#125;</span><br><span class="line">@SafeVarargs</span><br><span class="line">public ServletContextInitializerBeans(ListableBeanFactory beanFactory,</span><br><span class="line">Class&lt;? extends ServletContextInitializer&gt;... initializerTypes) &#123;</span><br><span class="line">this.initializers = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes)</span><br><span class="line">: Collections.singletonList(ServletContextInitializer.class);//默认只有ServletContextInitializer类型</span><br><span class="line">addServletContextInitializerBeans(beanFactory);//从beanFactory中获取到ServletContextInitializer并添加到initializers中</span><br><span class="line">addAdaptableBeans(beanFactory);</span><br><span class="line">List&lt;ServletContextInitializer&gt; sortedInitializers = this.initializers.values().stream()</span><br><span class="line">.flatMap((value) -&gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">this.sortedList = Collections.unmodifiableList(sortedInitializers);//最终执行的位置，也是返回的ServletContextInitializer</span><br><span class="line">logMappings(this.initializers);</span><br><span class="line">&#125;</span><br><span class="line">    //两次循环获取ServletContextInitializer的所有子类</span><br><span class="line">private void addServletContextInitializerBeans(ListableBeanFactory beanFactory) &#123;</span><br><span class="line">for (Class&lt;? extends ServletContextInitializer&gt; initializerType : this.initializerTypes) &#123;</span><br><span class="line">for (Entry&lt;String, ? extends ServletContextInitializer&gt; initializerBean : getOrderedBeansOfType(beanFactory,</span><br><span class="line">initializerType)) &#123;</span><br><span class="line">                    //获取到的getOrderedBeansOfType(beanFactory,initializerType): beanName和对应的bean</span><br><span class="line">addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    //添加到initializers中</span><br><span class="line">private void addServletContextInitializerBean(String beanName, ServletContextInitializer initializer,</span><br><span class="line">ListableBeanFactory beanFactory) &#123;</span><br><span class="line">if (initializer instanceof ServletRegistrationBean) &#123;</span><br><span class="line">Servlet source = ((ServletRegistrationBean&lt;?&gt;) initializer).getServlet();</span><br><span class="line">addServletContextInitializerBean(Servlet.class, beanName, initializer, beanFactory, source);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else &#123;</span><br><span class="line">addServletContextInitializerBean(ServletContextInitializer.class, beanName, initializer, beanFactory,</span><br><span class="line">initializer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addServletContextInitializerBean(Class&lt;?&gt; type, String beanName, ServletContextInitializer initializer,</span><br><span class="line">ListableBeanFactory beanFactory, Object source) &#123;</span><br><span class="line">    this.initializers.add(type, initializer);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    // 从beanFactory(DefaultListableBeanFactory)中获取对应的类，这里的获取到的</span><br><span class="line">    private &lt;T&gt; List&lt;Entry&lt;String, T&gt;&gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&lt;T&gt; type,</span><br><span class="line">Set&lt;?&gt; excludes) &#123;</span><br><span class="line">String[] names = beanFactory.getBeanNamesForType(type, true, false);</span><br><span class="line">Map&lt;String, T&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">for (String name : names) &#123;</span><br><span class="line">if (!excludes.contains(name) &amp;&amp; !ScopedProxyUtils.isScopedTarget(name)) &#123;</span><br><span class="line">T bean = beanFactory.getBean(name, type);</span><br><span class="line">if (!excludes.contains(bean)) &#123;</span><br><span class="line">map.put(name, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Entry&lt;String, T&gt;&gt; beans = new ArrayList&lt;&gt;();</span><br><span class="line">beans.addAll(map.entrySet());</span><br><span class="line">beans.sort((o1, o2) -&gt; AnnotationAwareOrderComparator.INSTANCE.compare(o1.getValue(), o2.getValue()));</span><br><span class="line">return beans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration，自动扫描,<br>onRefresh();生成<code>DispatcherServlet</code>和<code>DispatcherServletRegistrationBean</code>,路径是”/“:继承ServletRegistrationBean,继承 ServletContextInitializer，会被初始化调用，   DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet,this.webMvcProperties.getServlet().getPath()),此处的路径就是”/“<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ServletRegistrationBean(T servlet, boolean alwaysMapUrl, String... urlMappings) &#123;</span><br><span class="line">Assert.notNull(servlet, &quot;Servlet must not be null&quot;);</span><br><span class="line">Assert.notNull(urlMappings, &quot;UrlMappings must not be null&quot;);</span><br><span class="line">this.servlet = servlet;</span><br><span class="line">this.alwaysMapUrl = alwaysMapUrl;</span><br><span class="line">this.urlMappings.addAll(Arrays.asList(urlMappings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/DispatcherServletRegistrationBean.png" alt="DispatcherServletRegistrationBean"></p><p>实现了ServletContextInitializer，因此会被扫描到添加到this.sortedList,然后执行<code>beans.onStartup(servletContext);</code></p><p>将servlet添加到context中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   org.springframework.boot.web.servlet.RegistrationBean#onStartup</span><br><span class="line">   @Override</span><br><span class="line">public final void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">String description = getDescription();</span><br><span class="line">if (!isEnabled()) &#123;</span><br><span class="line">logger.info(StringUtils.capitalize(description) + &quot; was not registered (disabled)&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">register(description, servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>register(description, servletContext);</code>在当前的servletContext中添加了description,<code>addRegistration(description, servletContext);</code>是添加servlet,<code>configure(registration);</code>是给当前的Wrapper添加对应的path ,同时给StandardContext添加路径和类名字对应，<code>servletMappings.put(adjustedPattern, name);</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected final void register(String description, ServletContext servletContext) &#123;</span><br><span class="line">    D registration = addRegistration(description, servletContext);</span><br><span class="line">    if (registration == null) &#123;</span><br><span class="line">        logger.info(</span><br><span class="line">                StringUtils.capitalize(description) + &quot; was not registered &quot; + &quot;(possibly already registered?)&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    configure(registration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ServletRegistrationBean的两个，一个是放servlet 一个是放mapping关系</span><br><span class="line">@Override</span><br><span class="line">protected ServletRegistration.Dynamic addRegistration(String description, ServletContext servletContext) &#123;</span><br><span class="line">    String name = getServletName();</span><br><span class="line">    return servletContext.addServlet(name, this.servlet);//此处的this.servlet是DispatcherServletAutoConfiguration注入的ApplicationContext</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void configure(ServletRegistration.Dynamic registration) &#123;</span><br><span class="line">    super.configure(registration);</span><br><span class="line">    String[] urlMapping = StringUtils.toStringArray(this.urlMappings);</span><br><span class="line">    if (urlMapping.length == 0 &amp;&amp; this.alwaysMapUrl) &#123;</span><br><span class="line">        urlMapping = DEFAULT_MAPPINGS;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!ObjectUtils.isEmpty(urlMapping)) &#123;</span><br><span class="line">        registration.addMapping(urlMapping);</span><br><span class="line">    &#125;</span><br><span class="line">    registration.setLoadOnStartup(this.loadOnStartup);</span><br><span class="line">    if (this.multipartConfig != null) &#123;</span><br><span class="line">        registration.setMultipartConfig(this.multipartConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//ApplicationContext</span><br><span class="line">private ServletRegistration.Dynamic addServlet(String servletName, String servletClass,</span><br><span class="line">        Servlet servlet, Map&lt;String,String&gt; initParams) throws IllegalStateException &#123;</span><br><span class="line">    Wrapper wrapper = (Wrapper) context.findChild(servletName);</span><br><span class="line">    ...</span><br><span class="line">    wrapper = context.createWrapper();</span><br><span class="line">    wrapper.setName(servletName);</span><br><span class="line">    context.addChild(wrapper);//在当前context添加servletWrapper</span><br><span class="line">    ...</span><br><span class="line">    wrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line">    wrapper.setServlet(servlet);//这里的servlet就是DispatcherServlet</span><br><span class="line">    ServletRegistration.Dynamic registration =new ApplicationServletRegistration(wrapper, context);// </span><br><span class="line">    return registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet执行流程"><a href="#DispatcherServlet执行流程" class="headerlink" title="DispatcherServlet执行流程"></a>DispatcherServlet执行流程</h2><p>前言是tomcat的请求可以到servlet中，中间经过了Connector到Container，经过一些Valve，Engine，Host，Contex，到Wrapper，<br>因为拦截所有”/“请求，因此全部都在DispatherServlet中处理请求</p><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/Springmvc执行流程.png" alt="Springmvc执行流程"></p><ul><li>1.DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现</li><li>2.HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现</li><li>3.Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li><li>4.HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li><li>5.ModelAndView是springmvc的封装对象，将model和view封装在一起。</li><li>6.ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</li><li>7.View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ul><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/请求流程.png" alt="请求流程"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">doDispatch(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = null;</span><br><span class="line">boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">...</span><br><span class="line">ModelAndView mv = null;</span><br><span class="line">...</span><br><span class="line">//检查是否是上传附件</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">//通过request找到处理handler，对应图中2、3步骤,返回请求链</span><br><span class="line">// Determine handler for the current request.</span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line">...</span><br><span class="line">//对应图中4步骤，找到handlerAdapter数据</span><br><span class="line">// Determine handler adapter for the current request.</span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">...</span><br><span class="line">//真正调用到处理的地方，对应图中5部分，然后返回对应7 ModelAndView</span><br><span class="line">// Actually invoke the handler.</span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">...</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getHandler()找到对应的处理<code>HandlerExecutionChain</code>请求处理链，返回的是HandlerMapping的包装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">if (this.handlerMappings != null) &#123;</span><br><span class="line">for (HandlerMapping mapping : this.handlerMappings) &#123;</span><br><span class="line">HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">if (handler != null) &#123;</span><br><span class="line">return handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>this.handlerMappings在初始化的时候<code>initHandlerMappings(context);</code>在context中找<code>HandlerMapping.class</code>对象的所有bean放入的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void initHandlerMappings(ApplicationContext context) &#123;</span><br><span class="line">this.handlerMappings = null;</span><br><span class="line">Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);</span><br><span class="line">if (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">this.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那这个context是怎么得到的？<br>就是Spring的ApplicationContext，确切的说是<code>AnnotationConfigServletWebServerApplicationContext</code>,在实例化DispatcherServlet的时候会调用所有的BeanPostProcessor，恰巧也会调用ApplicationContextAwareProcessor的<code>postProcessBeforeInitialization</code>,在这里面调用了<br><code>invokeAwareInterfaces</code>，就调用了bean的<code>setApplicationContext()</code>方法，DispatcherServlet实现了<code>ApplicationContextAware</code><br>因此就把Spring的applicationContext放到DispatcherServlet对象里面了。</p><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/DispatcherServlet.png" alt="DispatcherServlet"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">AccessControlContext acc = null;</span><br><span class="line"></span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line"></span><br><span class="line">return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">if (bean instanceof Aware) &#123;</span><br><span class="line">if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line">if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">//bean 实现了ApplicationContextAware，因此dispatcherServlet中就有了</span><br><span class="line">if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/HandlerAdapter.png" alt="生成HandlerAdapter过程"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">boolean supports(Object handler);</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</span><br><span class="line"></span><br><span class="line">long getLastModified(HttpServletRequest request, Object handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要判断当前的mappedHandler.getHandler()的类型来生成Adapter，<br>RequestMappingHandlerAdapter实现了HandlerAdapter，判断handler 就是执行supports(),handle就是handlerReqeust();</p><p><code>mav = invokeHandlerMethod(request, response, handlerMethod);</code><br><code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code>调用反射</p><h2 id="Spring生成请求地址和方法映射"><a href="#Spring生成请求地址和方法映射" class="headerlink" title="Spring生成请求地址和方法映射"></a>Spring生成请求地址和方法映射</h2><p>主要是找到两个注解的解析，@RequestMapping,@Controller,以及他们的变种,@RestControllrt,@GetMapping,@PostMapping</p><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/生成handler过程.png" alt="生成handler过程"></p><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/RequestMappingHandlerMapping.png" alt="RequestMappingHandlerMapping"></p><p><img src="/2021/07/20/SpringBoot之MVC的注册和调用/ServletWebServerApplicationContext.png" alt="ServletWebServerApplicationContext"></p><ul><li><a href="https://blog.csdn.net/bishabeijing/article/details/115729250" target="_blank" rel="noopener">springboot如何添加dispacherServerlet到tomcat中</a></li><li><a href="https://www.cnblogs.com/yangxiaohui227/p/13187719.html" target="_blank" rel="noopener">springmvc 源码分析（一）– DisparcherServlet的创建和注册到tomcat</a></li><li><a href="https://www.jianshu.com/p/8a20c547e245" target="_blank" rel="noopener">SpringMVC执行流程及工作原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      SpringBoot MVC的注册和执行
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见问题分析RabbitMQ如何处理消息丢失</title>
    <link href="https://muxiaobai.github.io/2021/06/08/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90RabbitMQ%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"/>
    <id>https://muxiaobai.github.io/2021/06/08/常见问题分析RabbitMQ如何处理消息丢失/</id>
    <published>2021-06-08T14:15:00.000Z</published>
    <updated>2022-05-06T10:08:36.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先明确一点-一条消息的传送流程：生产者-gt-MQ-gt-消费者"><a href="#首先明确一点-一条消息的传送流程：生产者-gt-MQ-gt-消费者" class="headerlink" title="首先明确一点 一条消息的传送流程：生产者-&gt;MQ-&gt;消费者"></a>首先明确一点 一条消息的传送流程：生产者-&gt;MQ-&gt;消费者</h2><p>所以有三个地方都会丢失数据：</p><p>生产者发送给MQ的途中出现网络问题<br>MQ自己没保管好弄丢了<br>消费者拿到数据后出错了没有最终完成任务<br>依次分析</p><h3 id="1）生产者弄丢了数据"><a href="#1）生产者弄丢了数据" class="headerlink" title="1）生产者弄丢了数据"></a>1）生产者弄丢了数据</h3><p>生产者将数据发送到rabbitmq的时候，可能因为网络问题导致数据就在半路给搞丢了。</p><p>1.使用事务（性能差）<br>可以选择用rabbitmq提供的事务功能，在生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，开始rabbitmq事务机制，基本上吞吐量会下来，因为太耗性能。</p><p>2.发送回执确认（推荐）<br>可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。<br>　　事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息rabbitmq接收了之后会异步回调你一个接口通知你这个消息接收到了。</p><p>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</p><h3 id="2）RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化"><a href="#2）RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化" class="headerlink" title="2）RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化"></a>2）RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化</h3><p>　　为了防止rabbitmq自己弄丢了数据，这个你必须开启rabbitmq的持久化，就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p><p>　　设置持久化有两个步骤，第一个是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p><p>　　而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</p><p>　　若生产者那边的confirm机制未开启的情况下，哪怕是你给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点点数据会丢失。</p><h3 id="3）消费端弄丢了数据"><a href="#3）消费端弄丢了数据" class="headerlink" title="3）消费端弄丢了数据"></a>3）消费端弄丢了数据</h3><p>　　主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了比如重启了，那么就尴尬了，RabbitMQ认为你都消费了，这数据就丢了。或者消费者拿到数据之后挂了，这时候需要MQ重新指派另一个消费者去执行任务（一块肉，刚用筷子夹起来，发地震抖了一下，肉掉了）</p><p>　　这个时候得用RabbitMQ提供的ack机制，也是一种处理完成发送回执确认的机制。如果MQ等待一段时间后你没有发送过来处理完成 那么RabbitMQ就认为你还没处理完，这个时候RabbitMQ会把这个消费分配给别的consumer去处理，消息是不会丢的。</p>]]></content>
    
    <summary type="html">
    
      常见问题分析---rabbitmq如何处理丢消息
    
    </summary>
    
      <category term="工具" scheme="https://muxiaobai.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot之自动装配</title>
    <link href="https://muxiaobai.github.io/2021/06/02/SpringBoot%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>https://muxiaobai.github.io/2021/06/02/SpringBoot之自动装配/</id>
    <published>2021-06-02T17:30:47.000Z</published>
    <updated>2022-05-06T10:08:35.978Z</updated>
    
    <content type="html"><![CDATA[<p>主图是spring和mybatis的结合的内容</p><p><img src="http://assets.processon.com/chart_image/5c8b1387e4b02b2ce4995739.png" alt="图片"></p><p>此为主要部分spring @Import</p><p><img src="/2021/06/02/SpringBoot之自动装配/import.png" alt="图片"></p><p>一点点分析：</p><p>@Import({xxx.class})直接来的</p><p>@EnableAutoConfiguration中的@Import(AutoConfigurationImportSelector.class)扫描 <code>META-INF/spring.factories</code>中的</p><p>@AutoConfigurationPackage中的@Import(AutoConfigurationPackages.Registrar.class)<br>注册包中的</p><p>这些配置都存在 ，在run中读取放入Spring中</p><p><img src="/2021/06/02/SpringBoot之自动装配/AutowiredAnnotationBeanPostProcessor.png" alt="图片"></p><p>这是一个BeanPostProcessor执行，所有有@Autowired注解的都会被执行注入</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;mid=2247493911&amp;idx=1&amp;sn=1e3a08d74795a5019ad75aeb96e6d03f&amp;chksm=9f22fc83a855759508466fd2b688b84596322c5cf09544d8c131a82b050519863130abb2861d&amp;mpshare=1&amp;scene=1&amp;srcid=0413hiUoUrSnubWmvPrjhtEb&amp;sharer_sharetime=1618283761073&amp;sharer_shareid=76ce302a154389434cac572dafac93a9&amp;exportkey=AWeI%2BZ6voGgk7zqHOgEJWv4%3D&amp;pass_ticket=kIMvV2YwZ%2FHhNKTNMAeYQZjH1J5ya%2BLtLS4VTLEYVerq1bu1Os1JaaImGAR8cIvz&amp;wx_header=0#rd" target="_blank" rel="noopener">Spring Boot 注解原理，自动装配原理，图文并茂，万字长文！</a></p>]]></content>
    
    <summary type="html">
    
      解释自动装配机制，
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习之总览全局</title>
    <link href="https://muxiaobai.github.io/2021/01/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%80%BB%E8%A7%88%E5%85%A8%E5%B1%80/"/>
    <id>https://muxiaobai.github.io/2021/01/27/机器学习之总览全局/</id>
    <published>2021-01-27T17:26:29.000Z</published>
    <updated>2022-05-06T10:08:36.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><pre><code>通过现有数据获取一些未知的联系，生成一个模型，然后在新数据来的时候，可以通过这个模型进行预测。</code></pre><h2 id="为什么要了解机器学习"><a href="#为什么要了解机器学习" class="headerlink" title="为什么要了解机器学习"></a>为什么要了解机器学习</h2><p>在这个人人都在说编程，说python的时候，我们要思考的是背后有什么趋势，为何会这样？我自己想了一些儿原因。</p><ul><li>信息的爆炸</li><li>计算机的算力提升</li><li>人的习惯有传递性，不会立刻改变</li><li>人是喜欢有规则的</li></ul><h2 id="机器学习可以做什么"><a href="#机器学习可以做什么" class="headerlink" title="机器学习可以做什么"></a>机器学习可以做什么</h2><pre><code>主要是预测和辅助决策。</code></pre><h2 id="怎么去深入理解"><a href="#怎么去深入理解" class="headerlink" title="怎么去深入理解"></a>怎么去深入理解</h2><pre><code>个人理解，不要一开始就研究算法，你会自己把自己绕晕，然后也出不来。应结合实际案例，理解了机器学习的常规过程。然后再整理算法，在算法阶段，也不要太纠结具体的那个参数，先有全貌，再有枝叶。</code></pre><p>大概的一个学习过程，</p><h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><h3 id="先来一个最简单的例子—-人人皆知的房价预测"><a href="#先来一个最简单的例子—-人人皆知的房价预测" class="headerlink" title="先来一个最简单的例子—-人人皆知的房价预测"></a>先来一个最简单的例子—-人人皆知的房价预测</h3><h4 id="从最小二乘法开始"><a href="#从最小二乘法开始" class="headerlink" title="从最小二乘法开始"></a>从最小二乘法开始</h4><h3 id="推广到线性模型"><a href="#推广到线性模型" class="headerlink" title="推广到线性模型"></a>推广到线性模型</h3><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><h4 id="变形-Rige-Lasso-ElasticNet"><a href="#变形-Rige-Lasso-ElasticNet" class="headerlink" title="变形  Rige Lasso ElasticNet"></a>变形  Rige Lasso ElasticNet</h4><h4 id="计算距离-相似（欧氏距离、Jaccard相似、cos相似、person相似）"><a href="#计算距离-相似（欧氏距离、Jaccard相似、cos相似、person相似）" class="headerlink" title="计算距离/相似（欧氏距离、Jaccard相似、cos相似、person相似）"></a>计算距离/相似（欧氏距离、Jaccard相似、cos相似、person相似）</h4><h4 id="怎么确认模型过拟合-欠拟合"><a href="#怎么确认模型过拟合-欠拟合" class="headerlink" title="怎么确认模型过拟合/欠拟合"></a>怎么确认模型过拟合/欠拟合</h4><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><h4 id="sign函数-决定"><a href="#sign函数-决定" class="headerlink" title="sign函数 决定"></a>sign函数 决定</h4><h3 id="贝叶斯-隐形马尔科夫链-HMM"><a href="#贝叶斯-隐形马尔科夫链-HMM" class="headerlink" title="贝叶斯,隐形马尔科夫链 HMM"></a>贝叶斯,隐形马尔科夫链 HMM</h3><h3 id="SVM-支持向量机"><a href="#SVM-支持向量机" class="headerlink" title="SVM 支持向量机"></a>SVM 支持向量机</h3><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><h4 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h4><h4 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h4><p>2*2情况，是否连续值；是否监督；</p><p><img src="/2021/01/27/机器学习之总览全局/ml_conceptml_algorithms.png" alt="一些常见的算法归类"></p><p>如何选择合适的算法进行工作：</p><p><img src="/2021/01/27/机器学习之总览全局/sklearn.png" alt="如何选区算法"><br><a href="https://sklearn.apachecn.org/" target="_blank" rel="noopener">sklearn-CN文档</a><br>分类</p>]]></content>
    
    <summary type="html">
    
      总览，概况
    
    </summary>
    
      <category term="机器学习" scheme="https://muxiaobai.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://muxiaobai.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-二叉树-遍历-01</title>
    <link href="https://muxiaobai.github.io/2020/12/03/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-01/"/>
    <id>https://muxiaobai.github.io/2020/12/03/leetcode-二叉树-遍历-01/</id>
    <published>2020-12-03T17:28:04.000Z</published>
    <updated>2022-05-06T10:08:36.030Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    // 前序遍历</span><br><span class="line">    traverse(root.left)</span><br><span class="line">    // 中序遍历</span><br><span class="line">    traverse(root.right)</span><br><span class="line">    // 后序遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 先序遍历</span><br><span class="line">    *144</span><br><span class="line">    *</span><br><span class="line">    作者：LeetCode-Solution</span><br><span class="line">    链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal</span><br><span class="line">    来源：力扣（LeetCode）</span><br><span class="line">    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line">    * @param root</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">public static String traverseb(TreeNode root) &#123;</span><br><span class="line">    // 对于空节点，可以用一个特殊字符表示</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return &quot;#&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将左右子树序列化成字符串</span><br><span class="line">    String left = traverseb(root.left);</span><br><span class="line">    String right = traverseb(root.right);</span><br><span class="line">    /* 先序遍历代码位置 */</span><br><span class="line">    // 左右子树加上自己，就是以自己为根的二叉树序列化结果</span><br><span class="line">    String subTree = root.val + &quot;,&quot; + left + &quot;,&quot; + right;</span><br><span class="line">    return subTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/labuladong/hhh.java" target="_blank" rel="noopener">遍历二叉树</a></p>]]></content>
    
    <summary type="html">
    
      leetcode 二叉树刷题遍历
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>应用部署之nginx的https配置及自动生成证书</title>
    <link href="https://muxiaobai.github.io/2020/10/30/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E4%B9%8Bnginx%E7%9A%84https%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6/"/>
    <id>https://muxiaobai.github.io/2020/10/30/应用部署之nginx的https配置及自动生成证书/</id>
    <published>2020-10-30T10:28:48.000Z</published>
    <updated>2022-05-06T10:08:36.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>运行nginx -V命令查看已经安装的nginx模块</p><p>./configure –prefix=/usr/local/nginx –with-http_stub_status_module –with-http_ssl_module</p><p>需要添加ssl模块<br>make &amp;&amp; make install</p><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen          8080;</span><br><span class="line">listen       8443 ssl;</span><br><span class="line">server_name  localhost;</span><br><span class="line">#ssl on;</span><br><span class="line">root html/app-layui/src;</span><br><span class="line">index login.html index.htm;</span><br><span class="line">ssl_certificate    ../cert/zhang.pem;</span><br><span class="line">ssl_certificate_key ../cert/zhang.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">#charset koi8-r;</span><br><span class="line">#access_log  logs/host.access.log  main;</span><br><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  login.html login.thm;</span><br><span class="line">&#125;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>证书区分<br><img src="应用部署之nginx的https配置及自动生成证书/cert.png" alt="cert.png"></p><p>tomcat keytool 免费证书<br>win&amp;linux 脚本</p><ul><li><a href="https://github.com/muxiaobai/shell/blob/master/winsh/gen_cert.bat" target="_blank" rel="noopener">https://github.com/muxiaobai/shell/blob/master/winsh/gen_cert.bat</a></li><li><a href="https://github.com/muxiaobai/shell/blob/master/linux/gen_cert.sh" target="_blank" rel="noopener">https://github.com/muxiaobai/shell/blob/master/linux/gen_cert.sh</a></li></ul><p>免费安全证书  1year<br><a href="https://freessl.cn/" target="_blank" rel="noopener">https://freessl.cn/</a></p><p>安全证书 </p><p><a href="https://github.com/certbot/certbot" target="_blank" rel="noopener">https://github.com/certbot/certbot</a>   90day</p><p>参考:</p><ul><li><a href="https://blog.csdn.net/achenyuan/article/details/83340179" target="_blank" rel="noopener">keytool和openssl生成证书，应用tomcat和nginx</a></li></ul>]]></content>
    
    <summary type="html">
    
       部署https 脚本生成证书
    
    </summary>
    
      <category term="deploy" scheme="https://muxiaobai.github.io/categories/deploy/"/>
    
    
      <category term="nginx" scheme="https://muxiaobai.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux-基础命令总结之systemctl</title>
    <link href="https://muxiaobai.github.io/2020/09/23/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E4%B9%8Bsystemctl/"/>
    <id>https://muxiaobai.github.io/2020/09/23/Linux-基础命令总结之systemctl/</id>
    <published>2020-09-23T14:47:30.000Z</published>
    <updated>2022-05-06T10:08:35.974Z</updated>
    
    <content type="html"><![CDATA[<p>systemctl也会去/etc/init.d目录下，查看，执行相关程序</p><ul><li>systemctl status firewalld</li><li>systemctl list-unit-files 所有的资源</li><li>systemctl list-units  –type=service 正在运行的   type 类型</li></ul><p>unit 为资源</p><ul><li>Service unit：系统服务</li><li>Target unit：多个 Unit 构成的一个组</li><li>Device Unit：硬件设备</li><li>Mount Unit：文件系统的挂载点</li><li>Automount Unit：自动挂载点</li><li>Path Unit：文件或路径</li><li>Scope Unit：不是由 Systemd 启动的外部进程</li><li>Slice Unit：进程组</li><li>Snapshot Unit：Systemd 快照，可以切回某个快照</li><li>Socket Unit：进程间通信的 socket</li><li>Swap Unit：swap 文件</li><li>Timer Unit：定时器</li></ul><p>最常用的就是service unit</p><p>文件位置</p><p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的<br>配置文件存放在那个目录</p><p>启动一个服务：systemctl start firewalld.service<br>关闭一个服务：systemctl stop firewalld.service<br>重启一个服务：systemctl restart firewalld.service<br>显示一个服务的状态：systemctl status firewalld.service<br>在开机时启用一个服务：systemctl enable firewalld.service<br>在开机时禁用一个服务：systemctl disable firewalld.service<br>查看服务是否开机启动：systemctlis-enabled firewalld.service<br>查看已启动的服务列表：systemctllist-unit-files|grep enabled<br>查看启动失败的服务列表：systemctl–failed</p><p>启动服务（等同于service httpd start）<br>systemctl start httpd.service<br>停止服务（等同于service httpd stop）<br>systemctl stop httpd.service<br>重启服务（等同于service httpd restart）<br>systemctl restart httpd.service<br>查看服务是否运行（等同于service httpd status）<br>systemctl status httpd.service<br>开机自启动服务（等同于chkconfig httpd on）<br>systemctl enable httpd.service<br>开机时禁用服务（等同于chkconfig httpd on）<br>systemctl disable httpd.service<br>查看服务是否开机启动 （等同于chkconfig –list）</p><p><code>journalctl</code> 日志</p><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      服务命令  centos7 systemctl centos6以下  service 
    
    </summary>
    
      <category term="Linux" scheme="https://muxiaobai.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS网络设置</title>
    <link href="https://muxiaobai.github.io/2020/09/23/CentOS%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"/>
    <id>https://muxiaobai.github.io/2020/09/23/CentOS网络设置/</id>
    <published>2020-09-23T13:58:22.000Z</published>
    <updated>2022-05-06T10:08:35.962Z</updated>
    
    <content type="html"><![CDATA[<p>查看硬件的编号</p><p><code>ip addr</code></p><p><img src="/2020/09/23/CentOS网络设置/ip.png" alt="获取硬件编号"></p><p>路径：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">#BOOTPROTO=dhcp</span><br><span class="line">IPADDR=192.168.160.74</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.160.254</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=3187afee-d4cd-4047-a498-e63f00570e53</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">HWADDR=00:0C:29:86:ef:a3</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/23/CentOS网络设置/ifcfg-ens33.png" alt="图解命令"></p><p>重启网络<br><code>systemctl restart network</code></p>]]></content>
    
    <summary type="html">
    
      网络配置 ip addr, ifcfg-ens33
    
    </summary>
    
      <category term="Linux" scheme="https://muxiaobai.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch集群化部署方案</title>
    <link href="https://muxiaobai.github.io/2020/06/23/%E9%9B%86%E7%BE%A4%E4%B9%8BElasticsearch%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>https://muxiaobai.github.io/2020/06/23/集群之Elasticsearch部署方案/</id>
    <published>2020-06-23T20:28:19.000Z</published>
    <updated>2022-05-06T10:08:36.066Z</updated>
    
    <content type="html"><![CDATA[<p>应用服务IP为:192.168.1.2,ES_HOME为安装目录</p><h3 id="1-修改elasticsearch-yml配置："><a href="#1-修改elasticsearch-yml配置：" class="headerlink" title="1.修改elasticsearch.yml配置："></a>1.修改elasticsearch.yml配置：</h3><p>修改ES_HOME/config.elasticsearch.yml<br>network.host: 192.168.1.2 # 对外暴露的IP，本机IP<br>http.port: 9200 #设置对外服务的http端口号<br>transport.tcp.port: 9300 #设置节点之间交互的端口号<br>discovery.zen.ping.unicast.hosts: [“192.168.1.2:9300”,”192.168.1.2:9301”,”192.168.1.2:9302”]</p><p>#集群IP其它可以是主节点的IP加transport.tcp.port端口</p><p>修改ES_HOME/config/analysis-hanlp/hanlp.properties<br>root 为ES_HOME绝对路径</p><p>修改ES_HOME/config/analysis-hanlp/hanlp-remote.xml<br>remote_ext_dict和remote_ext_stopwords</p><entry key="remote_ext_dict"><a href="http://192.168.1.2:8080/dict" target="_blank" rel="noopener">http://192.168.1.2:8080/dict</a></entry><br><entry key="remote_ext_stopwords"><a href="http://192.168.1.2:8080/stop_words" target="_blank" rel="noopener">http://192.168.1.2:8080/stop_words</a></entry><p>可以添加hanlp插件或者ik插件 并配置远程更新词库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Logs(&quot;分词热更新到分词器中接口&quot;)</span><br><span class="line">@RequestMapping(&quot;/dict&quot;)</span><br><span class="line">public ResponseEntity dict(WebRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    // 1. 应用相关的方式计算得到(application-specific calculation)</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    if (request.checkNotModified(date)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; list= new ArrayList();</span><br><span class="line">    return ResponseEntity.ok().lastModified(date).body(String.join(&quot;\n&quot;,list));</span><br><span class="line">&#125;</span><br><span class="line">@Logs(&quot;停顿词热更新到分词器中接口&quot;)</span><br><span class="line">@RequestMapping(&quot;/stop_words&quot;)</span><br><span class="line">public ResponseEntity stopWords(WebRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    // 1. 应用相关的方式计算得到(application-specific calculation)</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    if (request.checkNotModified(date)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; list= new ArrayList();</span><br><span class="line">    return ResponseEntity.ok().lastModified(date).body(String.join(&quot;\n&quot;,list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-修改下面三个配置"><a href="#2-修改下面三个配置" class="headerlink" title="2.    修改下面三个配置"></a>2.    修改下面三个配置</h3><h4 id="vim-etc-security-limits-conf"><a href="#vim-etc-security-limits-conf" class="headerlink" title="vim /etc/security/limits.conf"></a>vim /etc/security/limits.conf</h4><p>错误1：max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536]<br>这个问题是无法创建本地文件,用户最大可创建文件数太小<br>解决：只需要修改创建文件的最大数目为65536就行了<br>root用户修改<br>vim /etc/security/limits.conf</p><pre><code>root soft nofile 65536root hard nofile 65536* soft nofile 65536* hard nofile 65536</code></pre><p>保存、退出、重新登录才可生效</p><p>参数解释：</p><ul><li>soft nproc:可打开的文件描述符的最大数(软限制)</li><li>hard nproc:可打开的文件描述符的最大数(硬限制)</li><li>soft nofile:单个用户可用的最大进程数量(软限制)</li><li>hard nofile:单个用户可用的最大进程数量(硬限制)<h4 id="vim-etc-sysctl-conf"><a href="#vim-etc-sysctl-conf" class="headerlink" title="vim /etc/sysctl.conf"></a>vim /etc/sysctl.conf</h4></li></ul><p>错误2：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]<br>虚拟内存太小<br>切换到root用户修改</p><p>vim /etc/sysctl.conf</p><p>vm.max_map_count=262144<br>执行命令：</p><p> sysctl -p</p><h4 id="vim-ES-HOME-config-jvm-options"><a href="#vim-ES-HOME-config-jvm-options" class="headerlink" title="vim ES_HOME/config/jvm.options"></a>vim ES_HOME/config/jvm.options</h4><p>错误3：Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=’Cannot allocate memory’ (errno=12)<br>jvm需要分配的内存太大<br>vim ES_HOME/config/jvm.options</p><p>设置 –Xmx2g和-Xms2g</p><p>推荐单机版16g<br>单机不得超过32G，否则会引发指针膨胀，虽然堆内存变大了，但是所能指向的实际对象会减少。</p><h3 id="3-不能使用root启动，必须创建用户"><a href="#3-不能使用root启动，必须创建用户" class="headerlink" title="3.    不能使用root启动，必须创建用户"></a>3.    不能使用root启动，必须创建用户</h3><p>添加用户：useradd -m 用户名  然后设置密码  passwd 用户名<br>useradd -m admin<br>passwd admin<br>修改文件夹权限<br>chown -R  admin elasticsearch</p><p>启动可能出现的错误</p><h3 id="4-启动"><a href="#4-启动" class="headerlink" title="4.    启动"></a>4.    启动</h3><p>ES_HOME/bin/elasticsearch -d</p><h3 id="5-无法形成集群"><a href="#5-无法形成集群" class="headerlink" title="5.    无法形成集群"></a>5.    无法形成集群</h3><p>删除elsticsearch文件夹下的data文件夹下的节点数据<br>调整 discovery.zen.minimum_master_nodes: 2 （N  master节点/2）+1</p><h3 id="6-设置密码X-pack"><a href="#6-设置密码X-pack" class="headerlink" title="6.    设置密码X-pack"></a>6.    设置密码X-pack</h3><p>1、    安全配置<br>默认情况下，拥有安全免费许可证时，Elasticsearch安全功能被禁用。 要启用安全功能，需要设置xpack.security.enabled。<br>在每个节点(包括node-1、node-2、node-3)的elasticsearch.yml配置文件中，新增：<br>xpack.security.enabled: true<br>2、    为节点间通信配置传输层安全性(TLS/SSL)<br>借助elasticsearch-certutil命令生成证书<br>cd ES_HOME/bin/<br>./elasticsearch-certutil ca -out /etc/elasticsearch/elastic-certificates.p12 -pass “”</p><p>Root用户<br>chown -R elasticsearch:elasticsearch   /etc/elasticsearch/elastic-certificates.p12<br>将证书拷贝到其他节点，放入 /etc/elasticsearch 目录下<br>cd /etc/elasticsearch/<br>scp elastic-certificates.p12  172.168.201.77:/etc/elasticsearch/<br>scp elastic-certificates.p12  172.168.201.78:/etc/elasticsearch/<br>3、    配置加密通信<br>启用安全功能后，必须使用TLS来确保节点之间的通信已加密。<br>在elasticsearch.yml中心新增配置如下：(其他节点相同配置)<br>xpack.security.transport.ssl.enabled: true<br>xpack.security.transport.ssl.verification_mode: certificate<br>xpack.security.transport.ssl.keystore.path: elastic-certificates.p12<br>xpack.security.transport.ssl.truststore.path: elastic-certificates.p12<br>重启elasticsearch服务<br>4、    设置集群密码<br>因为你上面已经做了SSL通信，所以只需要在第一台es(master)上设置用户名和密码就可以了，其他的2台es就会是相同的用户名密码<br>[elastic@es-node1 bin]$ cd /usr/share/elasticsearch/bin<br>[elastic@es-node1 bin]$ ./elasticsearch-setup-passwords -h  #查看命令帮助<br>Sets the passwords for reserved users</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p>auto - Uses randomly generated passwords          #主要命令选项，表示系统将使用随机字符串设置密码<br>interactive - Uses passwords entered by a user    #主要命令选项，表示使用用户输入的字符串作为密码</p><p>Non-option arguments:<br>command            </p><p>Option         Description      </p><hr><p>-h, –help     show help<br>-s, –silent   show minimal output<br>-v, –verbose  show verbose output<br>[elastic@es-node1 bin]$ ./elasticsearch-setup-passwords auto  #为了演示效果，这里我们使用系统自动创建<br>Initiating the setup of passwords for reserved users elastic,kibana,logstash_system,beats_system.<br>The passwords will be randomly generated and printed to the console.<br>Please confirm that you would like to continue [y/N]y     #选择y<br>Changed password for user kibana                   #kibana角色和密码<br>PASSWORD kibana = 4VXPRYIVibyAbjugK6Ok<br>Changed password for user logstash_system          #logstash角色和密码<br>PASSWORD logstash_system = 2m4uVdSzDzpt9OEmNin5<br>Changed password for user beats_system             #beast角色和密码<br>PASSWORD beats_system = O8VOzAaD3fO6bstCGDyQ<br>Changed password for user elastic                  #elasticsearch角色和密码<br>PASSWORD elastic = 1TWVMeN8tiBy917thUxq<br>核心：<br>auto - 随机生成密码。<br>interactive - 自定义不同用户的密码。<br>附：elasticsearch-setup-passwords此脚本只能运行一次，如要修改密码可以在kibana 中设置密码</p><p>验证是否正常<br><a href="http://192.168.1.2:9200" target="_blank" rel="noopener">http://192.168.1.2:9200</a></p><p>输入上一步生成的elastic和密码</p><p><a href="http://192.168.1.2:9200/_cluster/health" target="_blank" rel="noopener">http://192.168.1.2:9200/_cluster/health</a></p><p><a href="http://192.168.160.23:9100/?auth_user=elastic&amp;auth_password=123123" target="_blank" rel="noopener">http://192.168.160.23:9100/?auth_user=elastic&amp;auth_password=123123</a><br>curl -u elastic ‘<a href="http://192.168.1.2:9200/_xpack/security/_authenticate?pretty’" target="_blank" rel="noopener">http://192.168.1.2:9200/_xpack/security/_authenticate?pretty’</a> </p><h3 id="7-重置密码-非必须，如忘记密码"><a href="#7-重置密码-非必须，如忘记密码" class="headerlink" title="7.    重置密码(非必须，如忘记密码)"></a>7.    重置密码(非必须，如忘记密码)</h3><p>创建本地超级账户，然后使用api接口本地超级账户重置elastic账户的密码<br>(1) 停止elasticsearch服务<br>(2) 确保你的配置文件中支持本地账户认证支持，如果你使用的是xpack的默认配置则无需做特殊修改；如果你配置了其他认证方式则需要确保配置本地认证方式在ES_HOME/config/elasticsearch.yml中；<br>(3) 使用命令ES_HOME/bin/ elasticsearch-users 建一个基于本地问价认证的超级管理员<br>bin/elasticsearch-users useradd my_admin -p my_password -r superuser<br>(4) 启动elasticsearch服务<br>(5) 通过api重置elastic超级管理员的密码<br>curl -H “Content-Type:application/json” -XPOST -u my_admin ‘<a href="http://192.168.1.2:9200/_xpack/security/user/elastic/_password&#39;" target="_blank" rel="noopener">http://192.168.1.2:9200/_xpack/security/user/elastic/_password&#39;</a> -d ‘{ “password” : “123123” }’<br>(6) 校验下密码是否重置成功<br>curl -u elastic ‘<a href="http://192.168.1.2:9200/_xpack/security/_authenticate?pretty&#39;" target="_blank" rel="noopener">http://192.168.1.2:9200/_xpack/security/_authenticate?pretty&#39;</a><br>(7)删除my_admin账号<br>bin/elasticsearch-users userdel my_admin</p><h2 id="附：默认集群配置："><a href="#附：默认集群配置：" class="headerlink" title="附：默认集群配置："></a>附：默认集群配置：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true  #跨域连接相关设置</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;  #跨域连接相关设置  </span><br><span class="line">http.cors.allow-headers: Authorization,content-type</span><br><span class="line"></span><br><span class="line">cluster.name: elasticsearch #集群的名称，同一个集群该值必须设置成相同的</span><br><span class="line">node.name: master #该节点的名字</span><br><span class="line">node.master: true #该节点有机会成为master节点</span><br><span class="line">node.data: true #该节点可以存储数据</span><br><span class="line"></span><br><span class="line">#network.bind_host: 0.0.0.0 #设置绑定的IP地址，可以是IPV4或者IPV6</span><br><span class="line">#network.publish_host: 192.168.1.2 #设置其他节点与该节点交互的IP地址</span><br><span class="line">network.host: 192.168.1.2 #该参数用于同时设置bind_host和publish_host</span><br><span class="line"></span><br><span class="line">http.port: 9200 #设置对外服务的http端口号</span><br><span class="line">http.max_content_length: 100mb #设置http内容的最大大小</span><br><span class="line">http.enabled: true #是否开启http服务对外提供服务</span><br><span class="line">transport.tcp.port: 9300 #设置节点之间交互的端口号</span><br><span class="line">transport.tcp.compress: true #设置是否压缩tcp上交互传输的数据</span><br><span class="line"></span><br><span class="line">cluster.initial_master_nodes: [&quot;master&quot;]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2 #设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。官方推荐（N/2）+1</span><br><span class="line">discovery.zen.ping_timeout: 120s #设置集群中自动发现其他节点时ping连接的超时时间</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.1.2:9300&quot;,&quot;192.168.1.2:9500&quot;,&quot;192.168.1.2:9700&quot;] #设置集群中的Master节点的初始列表，可以通过这些节点来自动发现其他新加入集群的节点</span><br><span class="line">#discovery.zen.ping.unicast.hosts 使用network.host. transport.tcp.port</span><br><span class="line"></span><br><span class="line">#开启x-pack安全验证</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.license.self_generated.type: basic</span><br><span class="line">##如果是basic license的话需要加入下面这一行，不然的话restart elasticsearch之后会报错。</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line">xpack.security.transport.ssl.verification_mode: certificate</span><br><span class="line">xpack.security.transport.ssl.keystore.path: elastic-certificates.p12</span><br><span class="line">xpack.security.transport.ssl.truststore.path: elastic-certificates.p12</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/muxiaobai/shell/tree/master/linux/elasticsearch" target="_blank" rel="noopener">github 集群脚本</a></p><p>自动化部署，包含单机多节点和多机多节点，其中，多机需要ssh自动登录。</p>]]></content>
    
    <summary type="html">
    
      安装集群ES,集群方案
    
    </summary>
    
      <category term="集群" scheme="https://muxiaobai.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 高级之JIT即时编译</title>
    <link href="https://muxiaobai.github.io/2020/06/04/Thinking-in-java-%E9%AB%98%E7%BA%A7%E4%B9%8BJIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/"/>
    <id>https://muxiaobai.github.io/2020/06/04/Thinking-in-java-高级之JIT即时编译/</id>
    <published>2020-06-04T16:54:39.000Z</published>
    <updated>2022-05-06T10:08:35.994Z</updated>
    
    <content type="html"><![CDATA[<p>以synchronized为例：<br><img src="/2020/06/04/Thinking-in-java-高级之JIT即时编译/execjava.png" alt="exec"></p><h3 id="什么是JIT？"><a href="#什么是JIT？" class="headerlink" title="什么是JIT？"></a>什么是JIT？</h3><p>JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。JIT编译一词后来被泛华，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。JIT(即时编译)是用来提高java程序运行效率的，原本字节码由解释器需要经过解释再运行，现在有了JIT技术，将字节码编译成平台相关的原生机器码，并进行各个层次的优化，这些机器码会被缓存起来，以备下次使用，如果JIT对每条字节码都进行编译，缓存(缓存的指令是有限的)，会增加开销，因此JIT只对热点代码进行即时编译，如循环，高频度使用的方法，会将整个方法编译成本地机器码，然后直接运行机器码。</p><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>pom.xml添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;LATEST&lt;/version&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">            &lt;execution&gt;</span><br><span class="line">                &lt;goals&gt;</span><br><span class="line">                    &lt;goal&gt;java&lt;/goal&gt;</span><br><span class="line">                &lt;/goals&gt;</span><br><span class="line">            &lt;/execution&gt;</span><br><span class="line">        &lt;/executions&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">            &lt;mainClass&gt;org.adoptopenjdk.jitwatch.launch.LaunchUI&lt;/mainClass&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p><p>main运行添加参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+TraceClassLoading</span><br><span class="line">-XX:+LogCompilation</span><br><span class="line">-XX:LogFile=mylogfile.log</span><br><span class="line">-XX:+PrintAssembly</span><br><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure></p><p>生成log文件<code>mvn exec:java</code>运行，添加log文件和源文件和编译文件</p><h3 id="编译器的时间开销和空间开销："><a href="#编译器的时间开销和空间开销：" class="headerlink" title="编译器的时间开销和空间开销："></a>编译器的时间开销和空间开销：</h3><p><img src="/2020/06/04/Thinking-in-java-高级之JIT即时编译/jit逻辑图.png" alt="jit逻辑图"><br>解释器的执行，抽象的看是这样的：<br>字节码 -&gt; [ 解释器 解释执行机器码 ] -&gt; 执行结果<br>而要JIT编译然后再执行的话，抽象的看则是：<br>字节码 -&gt; [ 编译器 编译 ] -&gt; 与机器相关的机器码-&gt; [ 执行 ] -&gt; 执行结果</p><p>说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。</p><h3 id="不会被JIT编译"><a href="#不会被JIT编译" class="headerlink" title="不会被JIT编译"></a>不会被JIT编译</h3><p>JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快。怎么算是“只执行一次的代码”呢？粗略说，下面两个条件同时满足时就是严格的“只执行一次”</p><p>1、只被调用一次，例如类的构造器（class initializer，()）<br>2、没有循环</p><p>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。只有对频繁执行的代码，JIT编译才能保证有正面的收益。</p><p>对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致“代码爆炸”。这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎。<br>哪些程序代码会被编译为本地代码？如何编译为本地代码？</p><h3 id="会被JIT编译"><a href="#会被JIT编译" class="headerlink" title="会被JIT编译"></a>会被JIT编译</h3><p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？运行过程中会被即时编译器编译的“热点代码”有两类：</p><p>1、被多次调用的方法。<br>2、被多次执行的循环体。</p><p>两种情况，编译器都是以整个方法作为编译对象。 这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换了。<br><img src="/2020/06/04/Thinking-in-java-高级之JIT即时编译/jit.png" alt="jit未编译和编译过得"></p><h3 id="呢到底多少次才会被JIT编译？"><a href="#呢到底多少次才会被JIT编译？" class="headerlink" title="呢到底多少次才会被JIT编译？"></a>呢到底多少次才会被JIT编译？</h3><p>即时编译JIT只在代码段执行足够次数才会进行优化，在执行过程中不断收集各种数据，作为优化的决策，所以在优化完成之前，例子中的User对象还是在堆上进行分配。</p><p>那么一段代码需要执行多少次才会触发JIT优化呢？通常这个值由-XX:CompileThreshold参数进行设置：</p><p>1、使用client编译器时，默认为1500；<br>2、使用server编译器时，默认为10000；</p><p>意味着如果方法调用次数或循环次数达到这个阈值就会触发标准编译，更改CompileThreshold标志的值，将使编译器提早（或延迟）编译。</p><p>除了标准编译，还有一个叫做OSR（On Stack Replacement）栈上替换的编译，如上述例子中的main方法，只执行一次，远远达不到阈值，但是方法体中执行了多次循环，OSR编译就是只编译该循环代码，然后将其替换，下次循环时就执行编译好的代码，不过触发OSR编译也需要一个阈值，可以通过以下公式得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:CompileThreshold = 10000</span><br><span class="line">-XX:OnStackReplacePercentage = 140</span><br><span class="line">-XX:InterpreterProfilePercentage = 33</span><br></pre></td></tr></table></figure><p>OSR trigger = (CompileThreshold * (OnStackReplacePercentage - InterpreterProfilePercentage)) / 100 = 10700</p><p>其中trigger即为OSR编译的阈值。</p><ul><li><a href="https://blog.csdn.net/qq_28674045/article/details/51896129" target="_blank" rel="noopener">Java性能优化指南系列(三）：理解JIT编译器</a></li><li><a href="https://www.jianshu.com/p/20bd2e9b1f03" target="_blank" rel="noopener">浅谈HotSpot逃逸分析</a></li><li><a href="https://www.jianshu.com/p/eea12f3bf490" target="_blank" rel="noopener">Java JIT 知识</a></li><li><a href="https://www.cnblogs.com/dzhou/p/9549839.html" target="_blank" rel="noopener">什么是JIT</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文主要介绍JIT是什么，什么时候会JIT，以及那些JVM参数与JIT有关
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>https是如何保护我们的隐私?</title>
    <link href="https://muxiaobai.github.io/2020/05/26/https%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E6%88%91%E4%BB%AC%E7%9A%84%E9%9A%90%E7%A7%81/"/>
    <id>https://muxiaobai.github.io/2020/05/26/https是如何保护我们的隐私/</id>
    <published>2020-05-26T10:50:55.000Z</published>
    <updated>2022-05-06T10:08:36.014Z</updated>
    
    <content type="html"><![CDATA[<p>怎么配置可以参考<a href="https://muxiaobai.github.io/2020/01/02/SpringBoot%E4%B9%8Bhttps%E8%AF%B7%E6%B1%82/">SpringBoot之https请求</a></p><h3 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h3><p>在信息安全性问题中，我们常常要做到三点才能保证信息的安全：</p><ul><li>信息的保密性</li><li>信息的完整性</li><li>身份识别</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>非对称加密中的：公钥(public)和私钥(private)</p><ul><li>公钥(public key)是对外开放的，私钥(private key)是自己拥有的。</li><li>公钥(public key)加密的数据，只能用私钥(private key)解密。</li><li>私钥(private key)加密的数据，只能用公钥(public key)解密。</li></ul><h3 id="一个简单的过程"><a href="#一个简单的过程" class="headerlink" title="一个简单的过程"></a>一个简单的过程</h3><p>首先，客户端向服务器发出加密请求。</p><p>3)服务器用自己的私钥加密网页以后，连同本身的数字证书，这里的数字证书，是CA发给你的（默认你是知道CA颁布的证书的），一起发送给客户端。</p><p>4)客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</p><p>5)如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</p><p>6)如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告</p><p>自己生成的证书，浏览器没有维护证书机构，因此标记不安全，但从算法上来说是安全的，加密过的信息，只是不知道出处，数据来源。</p><p><img src="https是如何保护我们的隐私/unsafe.png" alt="自己生成的证书"><br>明确一点：各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以客户端只需要知道是哪个机构(CA)颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p><p><a href="https://www.jianshu.com/p/29e0ba31fb8d" target="_blank" rel="noopener">一文看懂HTTPS、证书机构（CA）、证书、数字签名、私钥、公钥</a><br><a href="https://www.sohu.com/a/320031789_371153" target="_blank" rel="noopener">是时候理解下HTTPS的原理及流程了</a><br><a href="https://blog.csdn.net/u011123724/article/details/80586173" target="_blank" rel="noopener">钥与私钥，HTTPS详解</a><br><a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">对应的英文版本 上一篇</a></p>]]></content>
    
    <summary type="html">
    
      http 和https 为什么https可以保护隐私，CA又是什么？
    
    </summary>
    
      <category term="deploy" scheme="https://muxiaobai.github.io/categories/deploy/"/>
    
    
      <category term="信息安全" scheme="https://muxiaobai.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 高级之对象大小模型</title>
    <link href="https://muxiaobai.github.io/2020/05/19/Thinking-in-java-%E9%AB%98%E7%BA%A7%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://muxiaobai.github.io/2020/05/19/Thinking-in-java-高级之对象内存模型/</id>
    <published>2020-05-19T10:50:29.000Z</published>
    <updated>2022-05-06T10:08:35.998Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍对象的创建，对象一般有哪些内容，对象大小是怎么计算的，学习完，可以根据对象大小来优化jvm的设置。</p><p>下文默认64位机并开启指针压缩，-XX:+UseCompressedOops<br>压缩的所用：<br>1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力<br>2.为了减少64位平台下内存的消耗，启用指针压缩功能<br>3.在jvm中，32位地址表示4G个对象的指针，在4G-32G堆内存范围内，可以通过编码、解码方式进行优化，使得jvm可以支持更大的内存配置<br>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间<br>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p><p>以下内容会被压缩：<br>1.对象的全局静态变量(即类属性)<br>2.对象头信息:64位平台下，原生对象头大小为16字节，压缩后为12字节<br>3.对象的引用类型:64位平台下，引用类型本身大小为8字节，压缩后为4字节<br>4.对象数组类型:64位平台下，数组类型本身大小为24字节，压缩后16字节</p><p><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/jvm内存.png" alt="java 对象大小"><br>jvm内存模型图，熟悉吧，接着往下看。</p><p><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/oop指针.png" alt="java 对象大小"><br>先看图这个熟悉jvm的对这个指针指向都知道，基本数据类型在栈帧中，对象，复杂类型，栈帧中只保存对对象的应用，而真实的对象是存在堆中的，我们本文是要揭示堆中的这个对象到底有什么内容，包含哪些数据，记录的什么信息。</p><h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p>首先堆中的都是复杂对象这个可以理解吧，基本对象都在栈帧中了，就是int，long，char这些，注意String 不是 Integer不是，基本类型，这种是包装类型，String<br>内部包含一个char[] 和一个hash属性。<br><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/java对象大小.png" alt="java 对象大小"><br>对象包括 markword oop，（数组长度）成为对象头，这里有可能有一个内部对齐，然后是对象的属性，最后还有一个对齐。</p><p>注意：对齐，8位对齐，一个字节。<br><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/java对象模型.png" alt="java 对象大小"></p><p>大小应该怎么计算呢？分为两种情况，一种是Object ，一种是Array，Array中对象头包含了一个4位的数组长度。</p><h3 id="markword"><a href="#markword" class="headerlink" title="_markword"></a>_markword</h3><p><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/markword结构图.jpg" alt="java 对象大小"></p><p>这是markword的详细信息，也就是堆中的对象头包含的信息。<br>这里的正常对象，age  4位  2^4-1 =15,Eden区，从form到to同一个对象，最多标记只能移动15次，参数是<br>MaxTenuringThreshold 默认也是15，在调试gc的时候可以把年龄打印出来-XX:+PrintTenuringDistribution.</p><p>markword<br>第一部分markword,用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“MarkWord”。</p><h3 id="KlassOop"><a href="#KlassOop" class="headerlink" title="KlassOop"></a>KlassOop</h3><p>klass 64位机本有8字节，压缩之后4字节<br>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例. 32位4字节，64位开启指针压缩或最大堆内存&lt;32g时 4字节，否则8字节</p><p>指针，治理是指向方法区现在叫metaspace，我们可以想象一下反射的时候我们是不是要获取Class对象，这个Oop可以想象就是为了获取Class对象。</p><h3 id="数组长度-Array对象"><a href="#数组长度-Array对象" class="headerlink" title="数组长度(Array对象)"></a>数组长度(Array对象)</h3><p>数组长度（只有数组对象有） 4字节<br>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.int最大值2g，2^31，java数组（包含字符串）最长2g</p><h3 id="实际数据大小"><a href="#实际数据大小" class="headerlink" title="实际数据大小"></a>实际数据大小</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型大小：单位字节</p><ul><li>1 byte boolean</li><li>2 short char (ref引用，复杂对象指向，)</li><li>4 int folat</li><li>8 long double</li></ul><h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p>String =char[] + hash<br>Object = ref 4<br>上一个对象添加引用，本对象计算</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>包含数组类型属性的对象，还要加上一个数组长度，<br>一个数组需要添加一个长度</p><ul><li>int[] 基本类型 添加数组长度4 加上基本类型大小</li><li>Object[] 对象数组  添加数组长度 + ref  另外Object对象要占用16个位</li></ul><p><a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/java/objectsize/DoubleArraySize.java" target="_blank" rel="noopener">DoubleArraySize</a></p><p>下面来实战一下吧。</p><h2 id="JOL工具"><a href="#JOL工具" class="headerlink" title="JOL工具"></a>JOL工具</h2><p>pom.xml 引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class="line">print(ClassLayout.parseInstance(new Object()).toPrintable());</span><br><span class="line">print(ClassLayout.parseInstance(Object.class).toPrintable());//这个实际上是class对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12        (object header)                           N/A</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">java.lang.Class object internals:</span><br><span class="line"> OFFSET  SIZE                                              TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4                                                   (object header)                           01 e8 bf 80 (00000001 11101000 10111111 10000000) (-2134906879)</span><br><span class="line">      4     4                                                   (object header)                           1e 00 00 00 (00011110 00000000 00000000 00000000) (30)</span><br><span class="line">      8     4                                                   (object header)                           df 03 00 f8 (11011111 00000011 00000000 11111000) (-134216737)</span><br><span class="line">     12     4                     java.lang.reflect.Constructor Class.cachedConstructor                   null</span><br><span class="line">     16     4                                   java.lang.Class Class.newInstanceCallerCache              null</span><br><span class="line">     20     4                                  java.lang.String Class.name                                (object)</span><br><span class="line">     24     4                                                   (alignment/padding gap)                  </span><br><span class="line">     28     4                       java.lang.ref.SoftReference Class.reflectionData                      (object)</span><br><span class="line">     32     4   sun.reflect.generics.repository.ClassRepository Class.genericInfo                         null</span><br><span class="line">     36     4                                java.lang.Object[] Class.enumConstants                       null</span><br><span class="line">     40     4                                     java.util.Map Class.enumConstantDirectory               null</span><br><span class="line">     44     4                    java.lang.Class.AnnotationData Class.annotationData                      (object)</span><br><span class="line">     48     4             sun.reflect.annotation.AnnotationType Class.annotationType                      null</span><br><span class="line">     52     4                java.lang.ClassValue.ClassValueMap Class.classValueMap                       null</span><br><span class="line">     56    32                                                   (alignment/padding gap)                  </span><br><span class="line">     88     4                                               int Class.classRedefinedCount                 0</span><br><span class="line">     92   404                                                   (loss due to the next object alignment)</span><br><span class="line">Instance size: 496 bytes</span><br><span class="line">Space losses: 36 bytes internal + 404 bytes external = 440 bytes total</span><br></pre></td></tr></table></figure><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h3 id="本身大小"><a href="#本身大小" class="headerlink" title="本身大小"></a>本身大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package io.github.muxiaobai.java.objectsize;</span><br><span class="line"></span><br><span class="line">import org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line">public class JOLPeople &#123;</span><br><span class="line">    int age = 20;</span><br><span class="line">    String name = &quot;Xiaoming&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        print(ClassLayout.parseInstance(new JOLPeople()).toPrintable());</span><br><span class="line"></span><br><span class="line">        print(ClassLayout.parseInstance(new String(&quot;Xiaoming&quot;)).toPrintable());</span><br><span class="line">        char[] chars = new char[8];</span><br><span class="line">        chars[0] = &apos;X&apos;;</span><br><span class="line">        chars[1] = &apos;i&apos;;</span><br><span class="line">        chars[2] = &apos;a&apos;;</span><br><span class="line">        chars[3] = &apos;o&apos;;</span><br><span class="line">        chars[4] = &apos;m&apos;;</span><br><span class="line">        chars[5] = &apos;i&apos;;</span><br><span class="line">        chars[6] = &apos;n&apos;;</span><br><span class="line">        chars[7] = &apos;g&apos;;</span><br><span class="line"></span><br><span class="line">        print(ClassLayout.parseInstance(chars).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void print(String message) &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><h2 id="JOLPeople-本身"><a href="#JOLPeople-本身" class="headerlink" title="JOLPeople 本身"></a>JOLPeople 本身</h2><p> io.github.muxiaobai.java.objectsize.JOLPeople object internals:<br> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE<br> 0     4                    (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)<br> 4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br> 8     4                    (object header)                           af f3 00 f8 (10101111 11110011 00000000 11111000) (-134155345)<br> 12     4                int JOLPeople.age                             20<br> 16     4   java.lang.String JOLPeople.name                            (object)<br> 20     4                    (loss due to the next object alignment)<br> Instance size: 24 bytes<br> Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</p><hr><p> _mark +oop  + 4(age的value)+ 4(name引用)<br> 8     + 4   +  4            +4          + 4(lose) =  24</p><h3 id="ShallowSize"><a href="#ShallowSize" class="headerlink" title="ShallowSize"></a>ShallowSize</h3><p> String 是一个char[] 数组 和hash 两个属性</p><p> The value is used for character storage.<br>private final char value[];</p><p> Cache the hash code for the string<br>private int hash; // Default to 0</p><p>String</p><hr><p> java.lang.String object internals:<br> OFFSET  SIZE     TYPE DESCRIPTION                               VALUE<br> 0     4          (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)<br> 4     4          (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br> 8     4          (object header)                           da 02 00 f8 (11011010 00000010 00000000 11111000) (-134216998)<br> 12     4   char[] String.value                              []<br> 16     4      int String.hash                               0<br> 20     4          (loss due to the next object alignment)<br> Instance size: 24 bytes<br> Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</p><hr><p> _mark +oop  + 引用(char[])+ hash<br> 8     + 4   +  4            4 + lose =  24</p><p> char[]数组 大小</p><hr><p> [C object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br> 0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br> 4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br> 8     4        (object header)                           41 00 00 f8 (01000001 00000000 00000000 11111000) (-134217663)<br> 12     4        (object header)                           08 00 00 00 (00001000 00000000 00000000 00000000) (8)<br> 16    16   char [C.<elements>                             N/A<br> Instance size: 32 bytes<br> Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</elements></p><hr><p> _mark +oop + 数组长度 + 实际数据<br> 8     + 4   +  4     + 8(arrLength) * 2(char) =  32</p><p> 我们可以手工计算一下JOLPeople obj = new JOLPeople()的大小：<br> JOLPeople的Shallow size = 8(_mark) + 4(oop指针) +  4(age的value)+ 4(name引用) + 4(lose) = 24<br> String对象的长度 = 8(_mark) + 4(oop指针) + 4(char[8]引用) +4(hash) +4(lose) =  24<br> char[]对象长度 =  8(_mark) + 4(oop指针) +  4(数组长度占4个字节) + 8*2(value) = 32<br> 所以JOLPeople实际占用的空间 = 24 + 24 + 32 = 80</p><p>验证：参考:<a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/java/objectsize/ShallowSize.java" target="_blank" rel="noopener">github ShallowSize.java</a><br><a href="https://blog.csdn.net/scdn_cp/article/details/86491792" target="_blank" rel="noopener">Java对象结构与锁实现原理及MarkWord详解</a></p>]]></content>
    
    <summary type="html">
    
      Java对象模型，对象大小，对象头，数组对象，如何计算，怎么验证，(OOP)Ordinary Object Pointer
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 高级之synchronized</title>
    <link href="https://muxiaobai.github.io/2020/05/07/Thinking-in-java-%E9%AB%98%E7%BA%A7%E4%B9%8Bsynchronized/"/>
    <id>https://muxiaobai.github.io/2020/05/07/Thinking-in-java-高级之synchronized/</id>
    <published>2020-05-07T16:39:25.000Z</published>
    <updated>2022-05-06T10:08:35.998Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要</p><h3 id="先从内核态和用户态说起"><a href="#先从内核态和用户态说起" class="headerlink" title="先从内核态和用户态说起"></a>先从内核态和用户态说起</h3><p>0x80 软中断 频繁切换会耗时，切换到内核态，调用内核方法。</p><h3 id="从DCL到锁升级"><a href="#从DCL到锁升级" class="headerlink" title="从DCL到锁升级"></a>从DCL到锁升级</h3><p>Double Check Lock 单例<a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/java/java/threadTest/Singleton.java" target="_blank" rel="noopener">参考Singleton.java</a></p><p>普通 偏向锁 轻量级锁 重量级锁</p><p>升级过程</p><h3 id="需要-markword信息-标记有哪一种锁"><a href="#需要-markword信息-标记有哪一种锁" class="headerlink" title="需要_markword信息 标记有哪一种锁"></a>需要_markword信息 标记有哪一种锁</h3><p><img src="/2020/05/07/Thinking-in-java-高级之synchronized/锁偏向.png" alt="java 对象大小"></p><h3 id="java字节码指令"><a href="#java字节码指令" class="headerlink" title="java字节码指令"></a>java字节码指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> private static sync classSync = new sync();</span><br><span class="line">public void doSth()&#123;</span><br><span class="line">       synchronized (sync.class)&#123;</span><br><span class="line">           System.out.println(&quot;test Synchronized 锁的是 class对象 因此this不会标记&quot; );</span><br><span class="line">           System.out.println(ClassLayout.parseInstance(this).toPrintable());</span><br><span class="line">       &#125;</span><br><span class="line">       synchronized (classSync)&#123;</span><br><span class="line">           System.out.println(&quot;test Synchronized 锁的是 private classSync对象 因此this会标记&quot; );</span><br><span class="line">           System.out.println(ClassLayout.parseInstance(this).toPrintable());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>sync锁对象，一个是锁class对象，一个是锁object对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;io/github/muxiaobai/java/java/threadTest/base/sync&gt;</span><br><span class="line"> 2 dup</span><br><span class="line"> 3 astore_1</span><br><span class="line"> 4 monitorenter   sync进入</span><br><span class="line"> 5 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line"> 8 ldc #12 &lt;test Synchronized 锁的是 class对象 因此this不会标记&gt;</span><br><span class="line">10 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">13 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">16 aload_0</span><br><span class="line">17 invokestatic #10 &lt;org/openjdk/jol/info/ClassLayout.parseInstance&gt;</span><br><span class="line">20 invokevirtual #11 &lt;org/openjdk/jol/info/ClassLayout.toPrintable&gt;</span><br><span class="line">23 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">26 aload_1</span><br><span class="line">27 monitorexit   sync退出</span><br><span class="line">28 goto 36 (+8)  异常退出 跳到36行，aload_0 继续往下执行，下一个sync</span><br><span class="line">31 astore_2</span><br><span class="line">32 aload_1</span><br><span class="line">33 monitorexit    sync退出</span><br><span class="line">34 aload_2</span><br><span class="line">35 athrow</span><br><span class="line">36 aload_0</span><br><span class="line">37 getfield #4 &lt;io/github/muxiaobai/java/java/threadTest/base/sync.classSync&gt;</span><br><span class="line">40 dup</span><br><span class="line">41 astore_1</span><br><span class="line">42 monitorenter  sync进入</span><br><span class="line">43 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">46 ldc #13 &lt;test Synchronized 锁的是 private classSync对象 因此this会标记&gt;</span><br><span class="line">48 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">51 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">54 aload_0</span><br><span class="line">55 invokestatic #10 &lt;org/openjdk/jol/info/ClassLayout.parseInstance&gt;</span><br><span class="line">58 invokevirtual #11 &lt;org/openjdk/jol/info/ClassLayout.toPrintable&gt;</span><br><span class="line">61 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">64 aload_1</span><br><span class="line">65 monitorexit   sync退出</span><br><span class="line">66 goto 74 (+8)  异常直接跳到 74行return</span><br><span class="line">69 astore_3</span><br><span class="line">70 aload_1</span><br><span class="line">71 monitorexit  sync退出</span><br><span class="line">72 aload_3</span><br><span class="line">73 athrow</span><br><span class="line">74 return</span><br></pre></td></tr></table></figure></p><p>注意 monitorenter 和monitorexit  ，每一个sync关键字，对应 一个enter和两个exit，正常退出和异常退出。</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>即时编译JIT只在代码段执行足够次数才会进行优化，在执行过程中不断收集各种数据，作为优化的决策; 什么代码会被即时编译 JIT，？</p><p><code>lock cmpxchg</code></p><p>方法上的锁调用方法的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void doSth1()&#123;</span><br><span class="line">       System.out.println(&quot;test Synchronized method，sync调用这个方法，方法上的，会锁this对象 ，也就是main方法中 new的sync&quot; );</span><br><span class="line">       System.out.println(ClassLayout.parseInstance(this).toPrintable());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>// access flags 0x21<br>public synchronized doSth1()V<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line"> 3 ldc #14 &lt;test Synchronized method，sync调用这个方法，方法上的，会锁this对象 ，也就是main方法中 new的sync&gt;</span><br><span class="line"> 5 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"> 8 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">11 aload_0</span><br><span class="line">12 invokestatic #10 &lt;org/openjdk/jol/info/ClassLayout.parseInstance&gt;</span><br><span class="line">15 invokevirtual #11 &lt;org/openjdk/jol/info/ClassLayout.toPrintable&gt;</span><br><span class="line">18 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">21 return</span><br></pre></td></tr></table></figure></p><p>### </p><ul><li><a href="https://juejin.im/post/5d5374076fb9a06ac76da894#heading-18" target="_blank" rel="noopener">Synchronized解析——如果你愿意一层一层剥开我的心</a></li><li><a href="https://www.cnblogs.com/charlesblc/p/5994162.html" target="_blank" rel="noopener">【转载】Java中的锁机制 synchronized &amp; 偏向锁 &amp; 轻量级锁 &amp; 重量级锁 &amp; 各自优缺点及场景 &amp; AtomicReference</a></li></ul>]]></content>
    
    <summary type="html">
    
      从synchronized到汇编,结合锁升级,探究背后的本质，
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java线上代码监控-linux分析线上问题</title>
    <link href="https://muxiaobai.github.io/2020/04/29/java%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81%E7%9B%91%E6%8E%A7-linux%E5%88%86%E6%9E%90%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    <id>https://muxiaobai.github.io/2020/04/29/java线上代码监控-linux分析线上问题/</id>
    <published>2020-04-29T16:41:41.000Z</published>
    <updated>2022-05-06T10:08:36.014Z</updated>
    
    <content type="html"><![CDATA[<p>jps(Java Virtual Machine Process Status Tool)<br>jstack(查看线程)、jmap(查看内存)和jstat(性能分析)</p><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>jps 找到对应的进程ID</p><p><code>jps -m -l</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure><p><code>ll /proc/[pid]/ | grep exe</code></p><p>可以查到时哪一个后台进程在执行</p><h2 id="未重启的话，分析现在的时候"><a href="#未重启的话，分析现在的时候" class="headerlink" title="未重启的话，分析现在的时候:"></a>未重启的话，分析现在的时候:</h2><h3 id="jstack-线程问题"><a href="#jstack-线程问题" class="headerlink" title="jstack 线程问题"></a>jstack 线程问题</h3><p>ps -mp [pid] -o THREAD,tid,time |sort -rn 打印CPU最高的线程<br>top -Hp [pid] </p><p>printf “%x\n” 22338 把线程ID转换成16进制<br>5742</p><p>jstack [pid] | grep 5742 -A 30 打印堆栈信息</p><p>-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况<br>-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</p><p>-F  to force a thread dump. Use when jstack <pid> does not respond (process is hung)<br>-m  to print both java and native frames (mixed mode)<br>-l  long listing. Prints additional information about locks<br>-h or -help to print this help message</pid></p><p><a href="https://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">jstack Dump 日志文件中的线程状态</a></p><p>线程死锁：<br>jstack –l pid | grep -i –E ‘BLOCKED | deadlock’</p><h3 id="jmap-堆问题"><a href="#jmap-堆问题" class="headerlink" title="jmap 堆问题"></a>jmap 堆问题</h3><p>jmap -heap [pid] 先查看堆栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./jmap -heap 22327</span><br><span class="line">Attaching to process ID 22327, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.201-b09</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 89128960 (85.0MB)</span><br><span class="line">   MaxNewSize               = 715653120 (682.5MB)</span><br><span class="line">   OldSize                  = 179306496 (171.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 671612928 (640.5MB)</span><br><span class="line">   used     = 349908376 (333.6986312866211MB)</span><br><span class="line">   free     = 321704552 (306.8013687133789MB)</span><br><span class="line">   52.0997082414709% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 12582912 (12.0MB)</span><br><span class="line">   used     = 12566640 (11.984481811523438MB)</span><br><span class="line">   free     = 16272 (0.0155181884765625MB)</span><br><span class="line">   99.87068176269531% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 22020096 (21.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 236978176 (226.0MB)</span><br><span class="line">   used     = 45630600 (43.51673126220703MB)</span><br><span class="line">   free     = 191347576 (182.48326873779297MB)</span><br><span class="line">   19.255190823985412% used</span><br><span class="line"></span><br><span class="line">38073 interned Strings occupying 3725472 bytes.</span><br></pre></td></tr></table></figure><p>查看对象</p><p>用jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象，如下：</p><p>数量和容量</p><p>实例数量前十的类：jmap -histo pid | sort -n -r -k 2 | head -10</p><p>实例容量前十的类：jmap -histo pid | sort -n -r -k 3 | head -10</p><h4 id="生成hprof文件（hprof（Heap-CPU-Profiling-Tool））"><a href="#生成hprof文件（hprof（Heap-CPU-Profiling-Tool））" class="headerlink" title="生成hprof文件（hprof（Heap/CPU Profiling Tool））"></a>生成hprof文件（hprof（Heap/CPU Profiling Tool））</h4><p><code>./jmap -dump:live,format=b,file=dump.dump [pid]</code></p><p>可以用：<code>./jhat -port 9998 dump.dump</code>  <code>./jhat -J-Xmx512m -port 9998 dump.dump</code><br>jhat -port 7401 -J -Xmx4G dump.dump</p><p>或者dump文件修改为dump.hprof,可以加到jprofiler</p><p>作用：主要分析内部当时的对象。</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat（JVM统计监测工具）</p><p>每隔250ms采集4次<code>./jstat -gc 30359 250 4</code><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>区容量（Capacity）和使用量（Used）<br>S0 S1 Survivor E O Eden Old M MetaspaceSize CCS CompressedClassSpaceSize  YG young gc FG  full gc T time FCT full gc time</p><p><code>./jstat -options</code> 参数 -gc  </p><p>250ms调用4次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./jstat -gc 22327  250 4</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU            MC     MU     CCSC   CCSU      YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br></pre></td></tr></table></figure><h2 id="准备重启复现的话："><a href="#准备重启复现的话：" class="headerlink" title="准备重启复现的话："></a>准备重启复现的话：</h2><p>第一步 加参数 ：</p><p>gc日志 配置Catalina.bat JAVA_OPTS</p><p><code>-Xloggc:./logs/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintTenuringDistribution -XX:+PrintHeapAtGC -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32  -XX:GCLogFileSize=64m -XX:+HeapDumpOnOutOfMemoryError</code></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247495546&amp;idx=1&amp;sn=f435f56c3b92802ef649cd14bb60711b&amp;chksm=e92ad275de5d5b63b9fc1e48463044ea1b234a4f28d0ad8d7964c42516f1cf7cae47c60162dc&amp;scene=0&amp;xtrack=1&amp;exportkey=AeNCSm6QS4EwNcRCTNfXDUs%3D&amp;pass_ticket=sHf4d8XsExleK1yRet7Gq5oJd6I%2FDOYRgopyFK8gH%2B81%2FhlGHzeiSrSlgR9oXDlk#rd" target="_blank" rel="noopener">步骤:线上问题定位，重启大法好！线上常见问题排查手册</a></li><li><a href="https://blog.csdn.net/muyimo/article/details/52837323?utm_source=distribute.pc_relevant.none-task-blog-baidujs-8" target="_blank" rel="noopener">VM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解</a></li></ul><p>一  线上常见问题定位</p><p>常见问题 1：CPU 利用率高</p><p>CPU 使用率是衡量系统繁忙程度的重要指标，一般情况下单纯的 CPU 高并没有问题，它代表系统正在不断的处理我们的任务，但是如果 CPU 过高，导致任务处理不过来，从而引起 load 高，这个是非常危险需要关注的。 CPU 使用率的安全值没有一个标准值，取决于你的系统是计算密集型还是 IO 密集型，一般计算密集型应用 CPU 使用率偏高 load 偏低，IO 密集型相反。</p><p>问题原因及定位：</p><p>1  频繁 FullGC/YongGC</p><p>2  代码消耗，如死循环，md5 等内存态操作</p><p>常见问题 2：load 高</p><p>load 指单位时间内活跃进程数，包含运行态（runnable 和 running）和不可中断态（ IO、内核态锁）。关键字是运行态和不可中断态，运行态可以联想到 Java 线程的 6 种状态，如下，线程 new 之后处于 NEW 状态，执行 start 进入 runnable 等待 CPU 调度，因此如果 CPU 很忙会导致 runnable 进程数增加；不可中断态主要包含网络 IO、磁盘 IO 以及内核态的锁，如 synchronized 等。</p><p>问题原因及定位：</p><p>1  CPU 利用率高，可运行态进程数多</p><p>2  iowait，等待 IO</p><p>3  等待内核态锁，如 synchronized</p><p>常见问题 3：持续 FullGC</p><p>问题原因及定位：</p><p>1  prommotion failed</p><p>从S区晋升的对象在老年代也放不下导致 FullGC（fgc 回收无效则抛 OOM）。</p><p>1）survivor 区太小，对象过早进入老年代。</p><p>2）大对象分配，没有足够的内存。</p><p>日志查找关键字 “allocating large”；</p><p>2  concurrent mode failed</p><p>在 CMS GC 过程中业务线程将对象放入老年代（并发收集的特点）内存不足。详细原因：</p><p>1）fgc 触发比例过大，导致老年代占用过多，并发收集时用户线程持续产生对象导致达到触发 FGC 比例。</p><p>jinfo  查看 CMSInitiatingOccupancyFraction 参数，一般 70~80 即可</p><p>2）老年代存在内存碎片。</p><p>jinfo  查看 UseCMSCompactAtFullCollection 参数，在 FullGC 后整理内存</p><p>常见问题 4：线程池满</p><p>Java 线程池以有界队列的线程池为例，当新任务提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求。如果正在运行的线程数等于 corePoolSize 时，则新任务被添加到队列中，直到队列满。当队列满了后，会继续开辟新线程来处理任务，但不超过 maximumPoolSize。当任务队列满了并且已开辟了最大线程数，此时又来了新任务，ThreadPoolExecutor 会拒绝服务。</p><p>问题原因及定位：</p><p>2  数据库慢 sql 或者数据库死锁</p><p>日志关键字 “Deadlock found when trying to get lock”</p><p>Jstack 或 zprofiler 查看阻塞态线程</p><p>3  Java 代码死锁</p><p>jstack –l pid | grep -i -E ‘BLOCKED | deadlock’</p>]]></content>
    
    <summary type="html">
    
      总结CPU怎么处理load 怎么处理
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot之https请求</title>
    <link href="https://muxiaobai.github.io/2020/01/02/SpringBoot%E4%B9%8Bhttps%E8%AF%B7%E6%B1%82/"/>
    <id>https://muxiaobai.github.io/2020/01/02/SpringBoot之https请求/</id>
    <published>2020-01-02T14:26:33.000Z</published>
    <updated>2022-05-06T10:08:35.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias spring -keypass 123456 -keyalg RSA -keysize 1024 -validity 365 -keystore E:/spring.keystore -storepass 123456</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-genkey      在用户主目录中创建一个默认文件&quot;.keystore&quot;,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书</span><br><span class="line">(在没有指定生成位置的情况下,keystore会存在用户系统默认目录，如：对于window xp系统，会生成在系统的C:/Documents and Settings/UserName/文件名为“.keystore”)</span><br><span class="line">-alias       产生别名</span><br><span class="line">-keystore    指定密钥库的名称(产生的各类信息将不在.keystore文件中)</span><br><span class="line">-keyalg      指定密钥的算法 (如 RSA  DSA（如果不指定默认采用DSA）)</span><br><span class="line">-validity    指定创建的证书有效期多少天</span><br><span class="line">-keysize     指定密钥长度</span><br><span class="line">-storepass   指定密钥库的密码(获取keystore信息所需的密码)</span><br><span class="line">-keypass     指定别名条目的密码(私钥的密码)</span><br><span class="line">-dname       指定证书拥有者信息 例如：  &quot;CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名称,ST=州或省份名称,C=单位的两字母国家代码&quot;</span><br><span class="line">-list        显示密钥库中的证书信息      keytool -list -v -keystore 指定keystore -storepass 密码</span><br><span class="line">-v           显示密钥库中的证书详细信息</span><br><span class="line">-export      将别名指定的证书导出到文件  keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码</span><br><span class="line">-file        参数指定导出到文件的文件名</span><br><span class="line">-delete      删除密钥库中某条目          keytool -delete -alias 指定需删除的别  -keystore 指定keystore  -storepass 密码</span><br><span class="line">-printcert   查看导出的证书信息          keytool -printcert -file yushan.crt</span><br><span class="line">-keypasswd   修改密钥库中指定条目口令    keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new  新密码  -storepass keystore密码  -keystore sage</span><br><span class="line">-storepasswd 修改keystore口令      keytool -storepasswd -keystore e:/yushan.keystore(需修改口令的keystore) -storepass 123456(原始密码) -new yushan(新密码)</span><br><span class="line">-import      将已签名数字证书导入密钥库  keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书</span><br></pre></td></tr></table></figure><p>默认参数：</p><p>下面是各选项的缺省值。<br>-alias “mykey”</p><p>-keyalg “DSA”</p><p>-keysize 1024</p><p>-validity 90</p><p>-keystore 用户宿主目录中名为 .keystore 的文件</p><p>-file 读时为标准输入，写时为标准输</p><h2 id="修改yaml配置文件"><a href="#修改yaml配置文件" class="headerlink" title="修改yaml配置文件"></a>修改yaml配置文件</h2><p>把E盘下的spring.keystore证书文件拷贝到项目中的resources目录中 , 然后在application.yml中配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  ssl:</span><br><span class="line">    key-alias: spring</span><br><span class="line">    key-password: 123456</span><br><span class="line">    key-store: classpath:spring.keystore</span><br></pre></td></tr></table></figure></p><p>和生成的证书的参数对应，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8443</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /</span><br><span class="line">  ssl:</span><br><span class="line">    key-store: classpath:spring.keystore</span><br><span class="line">    key-password: 123456</span><br><span class="line">    key-alias: spring</span><br><span class="line">    key-store-type:</span><br><span class="line">    key-store-password:</span><br><span class="line">    key-store-provider:</span><br><span class="line">http:</span><br><span class="line">  port: 8080</span><br></pre></td></tr></table></figure><h2 id="添加http和https同时监听"><a href="#添加http和https同时监听" class="headerlink" title="添加http和https同时监听"></a>添加http和https同时监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.catalina.Context;</span><br><span class="line">import org.apache.catalina.connector.Connector;</span><br><span class="line">import org.apache.tomcat.util.descriptor.web.SecurityCollection;</span><br><span class="line">import org.apache.tomcat.util.descriptor.web.SecurityConstraint;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @date 2020/1/2/002 13:52</span><br><span class="line"> * @TODO Http支持</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class TomcatConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    TomcatServletWebServerFactory tomcatServletWebServerFactory() &#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void postProcessContext(Context context) &#123;</span><br><span class="line">                SecurityConstraint constraint = new SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(&quot;CONFIDENTIAL&quot;);</span><br><span class="line">                SecurityCollection collection = new SecurityCollection();</span><br><span class="line">                collection.addPattern(&quot;/*&quot;);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">    private Connector createTomcatConnector() &#123;</span><br><span class="line">        // 默认协议为 TomcatServletWebServerFactory.DEFAULT_PROTOCOL=org.apache.coyote.http11.Http11NioProtocol</span><br><span class="line">        Connector connector = new</span><br><span class="line">                Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);</span><br><span class="line">        connector.setScheme(&quot;http&quot;);</span><br><span class="line">        connector.setPort(port);</span><br><span class="line">        connector.setSecure(false);</span><br><span class="line">        connector.setRedirectPort(httpsPort);//请求8080转到8443端口</span><br><span class="line">        return connector;</span><br><span class="line">    &#125;</span><br><span class="line">    //8080 请求8080转到8443端口</span><br><span class="line">    @Value(&quot;$&#123;http.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">    </span><br><span class="line">    //8443</span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private Integer httpsPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2020-01-02 14:17:43.303  INFO 10076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine local hostname</span><br><span class="line">2020-01-02 14:17:44.394  INFO 10076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine local hostname</span><br><span class="line">2020-01-02 14:17:44.629  INFO 10076 --- [           main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING</span><br><span class="line">2020-01-02 14:17:44.667  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka in region us-east-1</span><br><span class="line">2020-01-02 14:17:44.719  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON encoding codec LegacyJacksonJson</span><br><span class="line">2020-01-02 14:17:44.720  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON decoding codec LegacyJacksonJson</span><br><span class="line">2020-01-02 14:17:44.873  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML encoding codec XStreamXml</span><br><span class="line">2020-01-02 14:17:44.874  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML decoding codec XStreamXml</span><br><span class="line">2020-01-02 14:17:45.066  INFO 10076 --- [           main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2020-01-02 14:17:45.122  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Disable delta property : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : true</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: true</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br><span class="line">2020-01-02 14:17:45.316  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : The response status is 200</span><br><span class="line">2020-01-02 14:17:45.319  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 10</span><br><span class="line">2020-01-02 14:17:45.322  INFO 10076 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2020-01-02 14:17:45.327  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1577945865325 with initial instances count: 5</span><br><span class="line">2020-01-02 14:17:45.330  INFO 10076 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application APP-SEARCH with eureka with status UP</span><br><span class="line">2020-01-02 14:17:45.330  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1577945865330, current=UP, previous=STARTING]</span><br><span class="line">2020-01-02 14:17:45.333  INFO 10076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APP-SEARCH/192.168.170.1:8443: registering service...</span><br><span class="line">2020-01-02 14:17:45.375  INFO 10076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APP-SEARCH/192.168.170.1:8443 - registration status: 204</span><br><span class="line">2020-01-02 14:17:45.398  INFO 10076 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8443 (https) 8080 (http) with context path &apos;&apos;</span><br></pre></td></tr></table></figure></p><p>最终日志启动监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-01-02 14:17:45.398  INFO 10076 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8443 (https) 8080 (http) with context path &apos;&apos;</span><br></pre></td></tr></table></figure></p><h3 id="免费证书-失效最多一年"><a href="#免费证书-失效最多一年" class="headerlink" title="免费证书 失效最多一年"></a>免费证书 失效最多一年</h3><p> <a href="https://freessl.cn/" target="_blank" rel="noopener">https://freessl.cn/</a></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/Smile__1/article/details/99848578" target="_blank" rel="noopener">证书生成</a></li><li><a href="https://blog.csdn.net/qq_36699423/article/details/93481187" target="_blank" rel="noopener">SpringBoot配置同时支持http和https</a></li><li><a href="https://segmentfault.com/a/1190000020052375" target="_blank" rel="noopener">SpringBoot支持https</a></li><li><a href="https://juejin.im/post/5efa9c9e6fb9a07e5a1c2705" target="_blank" rel="noopener">证书</a></li></ul>]]></content>
    
    <summary type="html">
    
      https和http，实际上和之前我们配置tomcat 的https一个道理
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>tools-需要开启自启动的应用配置</title>
    <link href="https://muxiaobai.github.io/2019/12/26/tools-%E9%9C%80%E8%A6%81%E5%BC%80%E5%90%AF%E8%87%AA%E5%90%AF%E5%8A%A8%E7%9A%84%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://muxiaobai.github.io/2019/12/26/tools-需要开启自启动的应用配置/</id>
    <published>2019-12-26T14:58:37.000Z</published>
    <updated>2022-05-06T10:08:36.030Z</updated>
    
    <content type="html"><![CDATA[<p><code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>每个人对应的目录可能不一致，<br>可以用 win +r  <code>shell:startup</code><br>把需要启动的bat文件创建快捷方式，到此文件夹下<br><img src="/2019/12/26/tools-需要开启自启动的应用配置/自启动目录.png" alt="自启动目录"></p><p>或者开机启动脚本</p><p>win+r  gpedit.msc</p><p>用户配置—-&gt; Windows设置—-&gt;脚本（登陆/注销）—-&gt; 登陆—-&gt;添加—-&gt;start.bat</p><p>一开机就启动必须的应用 IDEA VS Code  Chrome CloudMusic,自己写的脚本必须启动的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">echo start </span><br><span class="line"></span><br><span class="line">echo idea START</span><br><span class="line">start /d &quot;E:\Program Files\JetBrains\IntelliJ IDEA 2019.1.2\bin&quot; idea64.exe</span><br><span class="line"></span><br><span class="line">echo VS CODE START</span><br><span class="line">start /d &quot;E:\tools\Microsoft VS Code&quot; code.exe</span><br><span class="line"></span><br><span class="line">echo sublime START</span><br><span class="line">start /d &quot;E:\Program Files\Sublime Text 3&quot; sublime_text.exe</span><br><span class="line"></span><br><span class="line">echo Chrome START</span><br><span class="line">start /d &quot;C:\Program Files (x86)\Google\Chrome\Application&quot; chrome.exe</span><br><span class="line"></span><br><span class="line">echo cloudmusic START</span><br><span class="line">start /d &quot;E:\Program Files (x86)\Netease\CloudMusic&quot; cloudmusic.exe</span><br><span class="line"></span><br><span class="line">echo javaw START</span><br><span class="line">start /d  &quot;E:\workspace\idea\app-cloud\&quot; taskrunjavaw.bat</span><br><span class="line"></span><br><span class="line">echo nginx START</span><br><span class="line">start /d  &quot;E:\tools\nginx-1.14.2\&quot; nginx.exe  -c conf/nginx.conf</span><br><span class="line"></span><br><span class="line">echo dbeaver START</span><br><span class="line">start /d  &quot;E:\tools\dbeaver-ee-7.2.0-win32.win32.x86_64\dbeaver&quot; dbeaver.exe</span><br><span class="line"></span><br><span class="line">echo redis START</span><br><span class="line">start /d  &quot;E:\tools\Redis-x64-3.2.100\&quot; redis-server.exe --service-install redis.windows-service.conf --loglevel verbose</span><br><span class="line"></span><br><span class="line">echo ssr START</span><br><span class="line">start /d &quot;E:\tools\ssr-win-4.9.0\ShadowsocksR-win-4.9.0&quot; ShadowsocksR-dotnet4.0.exe</span><br><span class="line"></span><br><span class="line">echo Ditto START</span><br><span class="line">start /d &quot;E:\tools\DittoPortable_64bit_3_23_124_0剪贴板\Ditto&quot; Ditto.exe</span><br><span class="line"></span><br><span class="line">echo pg_sql START</span><br><span class="line">&quot;E:\Program Files\pgsql\bin\pg_ctl.exe&quot;  -D &quot;E:\Program Files\pgsql\data&quot; start</span><br><span class="line"></span><br><span class="line">echo vmware START</span><br><span class="line">&quot;E:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe&quot; start &quot;E:\Users\Administrator\Documents\Virtual Machines\CentOS-192.168.160.75\CentOS-192.168.160.75.vmx&quot;</span><br><span class="line"></span><br><span class="line">echo ES START</span><br><span class="line">start /d &quot;E:\tools\elk\elasticsearch-7.5.1-master\bin&quot;  elasticsearch.bat</span><br><span class="line"></span><br><span class="line">start /d &quot;E:\tools\elk\elasticsearch-7.5.1-slave1\bin&quot;  elasticsearch.bat</span><br><span class="line"></span><br><span class="line">start /d &quot;E:\tools\elk\kibana-7.5.1-windows-x86_64\bin&quot;  kibana.bat</span><br><span class="line"></span><br><span class="line">echo jupyter START</span><br><span class="line">start  E:\ProgramData\Anaconda3\python.exe E:\ProgramData\Anaconda3\cwp.py E:\ProgramData\Anaconda3\envs\tensorflow E:\ProgramData\Anaconda3\envs\tensorflow\python.exe E:\ProgramData\Anaconda3\envs\tensorflow\Scripts\jupyter-notebook-script.py E:\workspace\git</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>切换到对应目录然后执行exe</p><p>taskrunjavaw.bat 中是需要启动的平台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">start javaw -jar ./app-core/app-register/target/app-register-0.0.1.jar   &amp;</span><br><span class="line">ping -n 8 127.0.0.1 1&gt;null</span><br><span class="line">rem 等待8秒</span><br><span class="line">echo &quot;app-register&quot;</span><br><span class="line">start javaw -jar ./app-core/app-config/target/app-config-0.0.1.jar &amp;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p><p>对于一些不经常变动的，定式启动内容可以如此处理。</p>]]></content>
    
    <summary type="html">
    
      每一次开机都要开启很多软件，在这里就找到解决办法，晚上可以关机，早上可以开机，然后就可以去接开水喝了，静待启动。
    
    </summary>
    
      <category term="工具" scheme="https://muxiaobai.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>devops之jenkins持续集成</title>
    <link href="https://muxiaobai.github.io/2019/12/21/devops%E4%B9%8Bjenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://muxiaobai.github.io/2019/12/21/devops之jenkins持续集成/</id>
    <published>2019-12-21T13:28:29.000Z</published>
    <updated>2022-05-06T10:08:36.010Z</updated>
    
    <content type="html"><![CDATA[<p>分两步走，第一安装，第二配置</p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000 /root/jenkins_home</span><br><span class="line">chmod 777 /var/run/docker.sock</span><br></pre></td></tr></table></figure><h2 id="docker-创建jenkins工具持续集成"><a href="#docker-创建jenkins工具持续集成" class="headerlink" title="docker 创建jenkins工具持续集成"></a>docker 创建jenkins工具持续集成</h2><p>拉取镜像 <code>docker pulljenkins/jenkins</code></p><p>8080映射到16000 5000映射到16001端口<br>创建容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name jenkins -p 16000:8080 -p 16001:50000 \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v $(which docker):/bin/docker \</span><br><span class="line">    -v /root/jenkins_home:/var/jenkins_home \</span><br><span class="line">    -d jenkins/jenkins</span><br></pre></td></tr></table></figure><ul><li>/root/jenkins_home 为jenkins工作空间，包括插件maven，git工具等</li><li>需要在shell中使用宿主机的docker命令</li></ul><p>删除容器：<code>docker rm -f jenkins</code></p><p>下面的创建，添加了本地执行shell挂载卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -d -p 16000:8080 -p 16001:50000 \</span><br><span class="line">    -v /opt/demo/:/opt/demo \</span><br><span class="line">    -v /root/jenkins_home/:/var/jenkins_home \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v $(which docker):/usr/bin/docker \</span><br><span class="line">    -v $(which git):/usr/bin/git \</span><br><span class="line">    -v ~/.ssh:/var/jenkins_home/.ssh \</span><br><span class="line">    --name=jenkins jenkins/jenkins</span><br></pre></td></tr></table></figure><p>挂载：其中/opt/demo 为命令执行空间</p><p>访问 <a href="http://ip:16000" target="_blank" rel="noopener">http://ip:16000</a></p><p>以上 安装完成</p><p>参考<a href="https://www.cnblogs.com/stulzq/p/8627360.html" target="_blank" rel="noopener">jenkins安装</a></p><h2 id="构建集成配置"><a href="#构建集成配置" class="headerlink" title="构建集成配置"></a>构建集成配置</h2><p>需要以下工具     </p><ul><li>Git plugin 源码地址</li><li>Maven Integration plugin   构建工具</li><li>Publish Over SSH 远程发布</li></ul><p><code>/root/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation</code>在这个文件夹下会有maven工具支持构建</p><p>新建项目选择maven,需要安装maven 工具<br><img src="/2019/12/21/devops之jenkins持续集成/pom.png" alt="maven"></p><h3 id="配置源码仓库"><a href="#配置源码仓库" class="headerlink" title="配置源码仓库"></a>配置源码仓库</h3><p>配置git地址，分支<code>refs/heads/dev</code></p><p><img src="/2019/12/21/devops之jenkins持续集成/gitsource.png" alt="源码配置"></p><h3 id="配置触发器"><a href="#配置触发器" class="headerlink" title="配置触发器"></a>配置触发器</h3><h4 id="github-hook"><a href="#github-hook" class="headerlink" title="github hook"></a>github hook</h4><p><img src="/2019/12/21/devops之jenkins持续集成/githubhook.png" alt="github hook"><br>只用把github勾选<br><img src="/2019/12/21/devops之jenkins持续集成/配置触发器.png" alt="配置触发器"></p><h4 id="gitlab配置"><a href="#gitlab配置" class="headerlink" title="gitlab配置"></a>gitlab配置</h4><p>Accepted Merge Requests Events 接受合并分支时，触发<br><img src="/2019/12/21/devops之jenkins持续集成/webhook.png" alt="配置jenkins合并触发"><br>出现<code>Url is blocked: Requests to the local network are not allowed</code> 问题，需要在系统管理员处配置：<br><img src="/2019/12/21/devops之jenkins持续集成/gitlab配置1.png" alt="配置gitlabwebhook"><br>合并分支时候调用hook地址<br><img src="/2019/12/21/devops之jenkins持续集成/gitlab配置2.png" alt="配置gitlab"></p><h3 id="配置-Build"><a href="#配置-Build" class="headerlink" title="配置 Build"></a>配置 Build</h3><p>pom.xml<br>clean package<br><img src="/2019/12/21/devops之jenkins持续集成/bulid.png" alt="build"></p><h3 id="配置Post-Steps"><a href="#配置Post-Steps" class="headerlink" title="配置Post Steps"></a>配置Post Steps</h3><h4 id="本机发布执行shell"><a href="#本机发布执行shell" class="headerlink" title="本机发布执行shell"></a>本机发布执行shell</h4><p>shell脚本</p><p><img src="/2019/12/21/devops之jenkins持续集成/shell.png" alt="本地shell"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">WORK_DIR=/opt/demo/package</span><br><span class="line">PROJECT_NAME=app-demo</span><br><span class="line">PROJECT_VERSION=0.0.1</span><br><span class="line">echo `pwd`</span><br><span class="line">docker ps -a </span><br><span class="line">#  判断工作目录是否存在</span><br><span class="line">if [ ! -e $&#123;WORK_DIR&#125; ] &amp;&amp; [ ! -d $&#123;WORK_DIR&#125; ]; then</span><br><span class="line">    mkdir -p $&#123;WORK_DIR&#125;</span><br><span class="line">    echo &quot;Create Dir: $&#123;WORK_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Dockerfile存在 删除</span><br><span class="line">if [ -e $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile ]; then</span><br><span class="line">    rm -rf $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile</span><br><span class="line">    echo &quot;Remove File: $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile&quot;</span><br><span class="line">fi</span><br><span class="line"># 如果容器已经启动，移除</span><br><span class="line">if docker ps -a | grep $&#123;PROJECT_NAME&#125;; then</span><br><span class="line">    docker rm -f $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;</span><br><span class="line">    docker rmi -f $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;</span><br><span class="line">    echo &quot;Remove Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 拷贝jar包到工作目录 jar是通过maven pom.xml 生成的</span><br><span class="line">cp ./target/*.jar $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/ </span><br><span class="line"># 拷贝Dockerfile到工作目录 是提前编写在git项目内</span><br><span class="line">cp ./Dockerfile $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/</span><br><span class="line"></span><br><span class="line"># 开始构建镜像</span><br><span class="line"># 进入工作目录</span><br><span class="line">cd $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/</span><br><span class="line"># 构建镜像 在个工作目录，依据当前目录创建镜像</span><br><span class="line"># docker build -t $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125; .</span><br><span class="line"># 推送镜像</span><br><span class="line"># docker push $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125;</span><br><span class="line"></span><br><span class="line">#  启动容器</span><br><span class="line"># docker run -d -p 18000:8761 --name $&#123;PROJECT_NAME&#125; $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125;</span><br><span class="line"></span><br><span class="line">#dockerstart.sh 为便捷构建容器启动容器脚本</span><br><span class="line">#cd $&#123;WORK_DIR&#125;</span><br><span class="line">#sh ../shell/dockerstart.sh $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; /opt/demo/package/ 18000</span><br><span class="line"></span><br><span class="line">#判断容器启动成功</span><br><span class="line">if docker ps  | grep $&#123;PROJECT_NAME&#125;; then</span><br><span class="line">    echo &quot;Start Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; Success&quot;</span><br><span class="line">else </span><br><span class="line">    echo &quot;Start Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; Error&quot;</span><br><span class="line">    return 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="远程发布SSH-Publishers"><a href="#远程发布SSH-Publishers" class="headerlink" title="远程发布SSH Publishers"></a>远程发布SSH Publishers</h4><p>配置插件如果要进行远程发布，需要插件</p><p>先在系统全局配置中配置以下ssh<br><img src="/2019/12/21/devops之jenkins持续集成/配置ssh.png" alt="配置"><br><img src="/2019/12/21/devops之jenkins持续集成/SSHpublisher.png" alt="远程发布"></p><p><a href="https://blog.csdn.net/Denny2333/article/details/88037413" target="_blank" rel="noopener">配置构建项目</a></p>]]></content>
    
    <summary type="html">
    
      通过docker安装jenkins，发布springboot项目
    
    </summary>
    
      <category term="devops" scheme="https://muxiaobai.github.io/categories/devops/"/>
    
    
      <category term="devops" scheme="https://muxiaobai.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之AQS和应用</title>
    <link href="https://muxiaobai.github.io/2019/10/31/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8BAQS%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <id>https://muxiaobai.github.io/2019/10/31/Thinking-in-java-基础之AQS和应用/</id>
    <published>2019-10-31T13:12:44.000Z</published>
    <updated>2022-05-06T10:08:35.982Z</updated>
    
    <content type="html"><![CDATA[<p>使用锁的时候我们直接<code>ReentrantLock lock = new ReentrantLock();lock.lock();</code>,这中间究竟有什么内容,<br>lock的时候，其它线程为什么不能执行，unlook()的时候其它的线程究竟从哪个线程能执行？本文主要分析lock的各种情况。</p><h2 id="j-u-c-locks-AbstractQueuedSynchronizer"><a href="#j-u-c-locks-AbstractQueuedSynchronizer" class="headerlink" title="j.u.c.locks.AbstractQueuedSynchronizer"></a>j.u.c.locks.AbstractQueuedSynchronizer</h2><p>有共享和独占两种状态，SHARE，EXCLUSIVE 这两个在AQS中对应两个Node节点{state:1,thread:Thread.CurrentThread()},节点里面的内容。<br>从名字里面就能知道，共享锁，每一个线程来都可以拿到锁，简单的来说，就是可以运行lock和unlock内的代码，独占锁，一个线程lock，其它线程必须等到unlock之后，再去抢占锁。</p><blockquote><p>排队接水喝，我的杯子放在这里，当前这个饮水机就我能用。其它人来了，不好意思，排队。</p></blockquote><p>至于怎么抢占，又分为公平锁，和非公平锁，公平锁：先来后到，非公平：随机获取。</p><blockquote><p>排队接水喝， 先后顺序，公平，来了个领导，他先接水，不公平，但合理。</p></blockquote><p>AbstractOwnableSynchronizer</p><p><img src="/2019/10/31/Thinking-in-java-基础之AQS和应用/state.png" alt="图"><br>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p><p>资源state使用volatile标识，保证所有的线程来的时候都是确定的值。详细查看<a href>volatile</a>，其它线程在队列里。</p><p>protected boolean tryAcquire(int arg) : 独占式获取同步状态，试着获取，成功返回true，反之为false<br>protected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；<br>protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；<br>protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为false<br>protected boolean isHeldExclusively() ： 是否在独占模式下被线程占用。</p><h2 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch 倒计时器"></a>CountDownLatch 倒计时器</h2><p>它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行</p><p>CountDownLatch，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h2><p>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. (CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源,可以指定多个线程同时访问某个资源</p><h2 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock 重入锁"></a>ReentrantLock 重入锁</h2><blockquote><p>排队接水喝，水杯太大，杯子放着接，我先干别的事，干完了回来，直接就能拿杯子，重入。</p></blockquote><p>ReentrantLock，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><h2 id="tomcat的-LimitLatch"><a href="#tomcat的-LimitLatch" class="headerlink" title="tomcat的 LimitLatch"></a>tomcat的 LimitLatch</h2><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">Java并发包基石-AQS详解</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md#41-countdownlatch-%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">JavaGuide</a></li></ul>]]></content>
    
    <summary type="html">
    
      jdk的juc中的AQS和应用，各种锁的比较
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
      <category term="Thread" scheme="https://muxiaobai.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之类加载顺序&amp;初始化</title>
    <link href="https://muxiaobai.github.io/2019/10/21/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://muxiaobai.github.io/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/</id>
    <published>2019-10-21T15:25:42.000Z</published>
    <updated>2022-05-06T10:08:35.990Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先来一个题"><a href="#先来一个题" class="headerlink" title="先来一个题"></a>先来一个题</h4><p>FatherClass:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class FatherClass &#123;</span><br><span class="line">    public  static  int F_NUM = 1111;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    FatherClass()&#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">        F_NUM = 5555;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SonClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SonClass  extends  FatherClass&#123;</span><br><span class="line">    public  static  int S_NUM = 2222;</span><br><span class="line">    static &#123;</span><br><span class="line">        F_NUM = 3333;</span><br><span class="line">        System.out.println(S_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        S_NUM = 4444;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里是一个大坑，没有无参的构造方法，所以newInstance的时候会报错</span><br><span class="line">    SonClass(int inNUM)&#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LoaderOrder &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">//        testClassLoad();</span><br><span class="line">        testClassForName();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void testClassLoad() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class clazz =LoaderOrder.class.getClassLoader().loadClass(&quot;io.github.muxiaobai.spring_my_demo.loadClass.SonClass&quot;);</span><br><span class="line">        System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">        System.out.println(&quot;===========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void testClassForName() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class clazz =Class.forName(&quot;io.github.muxiaobai.spring_my_demo.loadClass.SonClass&quot;);</span><br><span class="line">        System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">        System.out.println(&quot;===========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ClassLoad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InstantiationException: io.github.muxiaobai.spring_my_demo.loadClass.SonClass</span><br><span class="line">at java.lang.Class.newInstance(Class.java:427)</span><br></pre></td></tr></table></figure></p><p>使用Class.forName();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">---------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InstantiationException: io.github.muxiaobai.spring_my_demo.loadClass.SonClass</span><br></pre></td></tr></table></figure><p>链接：static成员变量，附初始值。0,null,false,</p><p>初始化做了那些事情？显性的：static语句块，执行到实例化的时候没有无参的构造函数，因此父类和子类都没有实例化。</p><p>没有完成类的初始化，无法访问类成员</p><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/Class初始化.png" alt="初始化"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="java对象，获取"><a href="#java对象，获取" class="headerlink" title="java对象，获取"></a>java对象，获取</h5><ul><li>new </li><li>反射</li><li>反序列化</li><li>克隆</li></ul><h5 id="Class对象获取"><a href="#Class对象获取" class="headerlink" title="Class对象获取"></a>Class对象获取</h5><ul><li>类名.class</li><li>实例.getClass()</li><li>classloader.loadClass(“包.类”)</li><li>Class.forName(“包.类”);</li></ul><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/获取Class四种方式.PNG" alt="初始化"></p><p>jvm加载步骤：加载——链接（验证，准备，解析）———–初始化</p><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/Class初始化时机.png" alt="初始化"></p><p>两种，实际上是识别到字节码指令:new，putstatic,getstatic,invokestatic,<br>反射</p><p>根据Java虚拟机的规范，只有5中情况属于主动引用：</p><ul><li><p>遇到new（使用new 关键字实例化一个对象）、getstatic（读取一个类的静态字段）、putstatic或者invokestatic（设置一个类的静态字段）这4条指令的时候，如果累没有进行过初始化。则需要先触发其初始化。</p></li><li><p>使用反射进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果其父类没有初始化，则需要先触发其父类的初始化</p></li><li><p>程序启动需要触发main方法的时候，虚拟机会先触发这个类的初始化</p></li><li><p>当使用jdk1.7的动态语言支持的时候，如果一个java.lang.invoke.MethodHandler实例最后的解析结果为REF_getStatic、REF_pusStatic、REF_invokeStatic的方法句柄（句柄中包含了对象的实例数据和类型数据，句柄是访问对象的一种方法。句柄存储在堆中），并且句柄对应的类没有被初始化，那么需要先触发这个类的初始化。</p></li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><a href="https://www.cnblogs.com/shyroke/p/9161603.html" target="_blank" rel="noopener">类加载机制和类的加载、连接（验证、准备、解析）和初始化</a></li></ul>]]></content>
    
    <summary type="html">
    
      类加载过程
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
</feed>
