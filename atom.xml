<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕小白的博客</title>
  
  <subtitle>有输入,有输出</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muxiaobai.github.io/"/>
  <updated>2020-12-03T12:37:52.803Z</updated>
  <id>https://muxiaobai.github.io/</id>
  
  <author>
    <name>Mu Xiaobai(慕小白)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-二叉树-遍历-01</title>
    <link href="https://muxiaobai.github.io/2020/12/03/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-01/"/>
    <id>https://muxiaobai.github.io/2020/12/03/leetcode-二叉树-遍历-01/</id>
    <published>2020-12-03T09:28:04.000Z</published>
    <updated>2020-12-03T12:37:52.803Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    // 前序遍历</span><br><span class="line">    traverse(root.left)</span><br><span class="line">    // 中序遍历</span><br><span class="line">    traverse(root.right)</span><br><span class="line">    // 后序遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 先序遍历</span><br><span class="line"> *144</span><br><span class="line"> *</span><br><span class="line"> 作者：LeetCode-Solution</span><br><span class="line"> 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal</span><br><span class="line"> 来源：力扣（LeetCode）</span><br><span class="line"> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"> * @param root</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String traverseb(TreeNode root) &#123;</span><br><span class="line">    // 对于空节点，可以用一个特殊字符表示</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return &quot;#&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将左右子树序列化成字符串</span><br><span class="line">    String left = traverseb(root.left);</span><br><span class="line">    String right = traverseb(root.right);</span><br><span class="line">    /* 先序遍历代码位置 */</span><br><span class="line">    // 左右子树加上自己，就是以自己为根的二叉树序列化结果</span><br><span class="line">    String subTree = root.val + &quot;,&quot; + left + &quot;,&quot; + right;</span><br><span class="line">    return subTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/labuladong/hhh.java" target="_blank" rel="noopener">遍历二叉树</a></p>]]></content>
    
    <summary type="html">
    
      leetcode 二叉树刷题遍历
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>应用部署之nginx的https配置及自动生成证书</title>
    <link href="https://muxiaobai.github.io/2020/10/30/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E4%B9%8Bnginx%E7%9A%84https%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6/"/>
    <id>https://muxiaobai.github.io/2020/10/30/应用部署之nginx的https配置及自动生成证书/</id>
    <published>2020-10-30T02:28:48.000Z</published>
    <updated>2020-12-01T07:09:17.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>运行nginx -V命令查看已经安装的nginx模块</p><p>./configure –prefix=/usr/local/nginx –with-http_stub_status_module –with-http_ssl_module</p><p>需要添加ssl模块<br>make &amp;&amp; make install</p><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen          8080;</span><br><span class="line">listen       8443 ssl;</span><br><span class="line">server_name  localhost;</span><br><span class="line">#ssl on;</span><br><span class="line">root html/app-layui/src;</span><br><span class="line">index login.html index.htm;</span><br><span class="line">ssl_certificate    ../cert/zhang.pem;</span><br><span class="line">ssl_certificate_key ../cert/zhang.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">#charset koi8-r;</span><br><span class="line">#access_log  logs/host.access.log  main;</span><br><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  login.html login.thm;</span><br><span class="line">&#125;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>证书区分<br><img src="应用部署之nginx的https配置及自动生成证书/cert.png" alt="cert.png"></p><p>tomcat keytool 免费证书<br>win&amp;linux 脚本</p><ul><li><a href="https://github.com/muxiaobai/shell/blob/master/winsh/gen_cert.bat" target="_blank" rel="noopener">https://github.com/muxiaobai/shell/blob/master/winsh/gen_cert.bat</a></li><li><a href="https://github.com/muxiaobai/shell/blob/master/linux/gen_cert.sh" target="_blank" rel="noopener">https://github.com/muxiaobai/shell/blob/master/linux/gen_cert.sh</a></li></ul><p>免费安全证书  1year<br><a href="https://freessl.cn/" target="_blank" rel="noopener">https://freessl.cn/</a></p><p>安全证书 </p><p><a href="https://github.com/certbot/certbot" target="_blank" rel="noopener">https://github.com/certbot/certbot</a>   90day</p><p>参考:</p><ul><li><a href="https://blog.csdn.net/achenyuan/article/details/83340179" target="_blank" rel="noopener">keytool和openssl生成证书，应用tomcat和nginx</a></li></ul>]]></content>
    
    <summary type="html">
    
       部署https 脚本生成证书
    
    </summary>
    
      <category term="deploy" scheme="https://muxiaobai.github.io/categories/deploy/"/>
    
    
      <category term="nginx" scheme="https://muxiaobai.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux-基础命令总结之systemctl</title>
    <link href="https://muxiaobai.github.io/2020/09/23/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E4%B9%8Bsystemctl/"/>
    <id>https://muxiaobai.github.io/2020/09/23/Linux-基础命令总结之systemctl/</id>
    <published>2020-09-23T06:47:30.000Z</published>
    <updated>2020-12-03T09:19:35.177Z</updated>
    
    <content type="html"><![CDATA[<p>systemctl也会去/etc/init.d目录下，查看，执行相关程序</p><ul><li>systemctl status firewalld</li><li>systemctl list-unit-files 所有的资源</li><li>systemctl list-units  –type=service 正在运行的   type 类型</li></ul><p>unit 为资源</p><ul><li>Service unit：系统服务</li><li>Target unit：多个 Unit 构成的一个组</li><li>Device Unit：硬件设备</li><li>Mount Unit：文件系统的挂载点</li><li>Automount Unit：自动挂载点</li><li>Path Unit：文件或路径</li><li>Scope Unit：不是由 Systemd 启动的外部进程</li><li>Slice Unit：进程组</li><li>Snapshot Unit：Systemd 快照，可以切回某个快照</li><li>Socket Unit：进程间通信的 socket</li><li>Swap Unit：swap 文件</li><li>Timer Unit：定时器</li></ul><p>最常用的就是service unit</p><p>文件位置</p><p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的<br>配置文件存放在那个目录</p><p>启动一个服务：systemctl start firewalld.service<br>关闭一个服务：systemctl stop firewalld.service<br>重启一个服务：systemctl restart firewalld.service<br>显示一个服务的状态：systemctl status firewalld.service<br>在开机时启用一个服务：systemctl enable firewalld.service<br>在开机时禁用一个服务：systemctl disable firewalld.service<br>查看服务是否开机启动：systemctlis-enabled firewalld.service<br>查看已启动的服务列表：systemctllist-unit-files|grep enabled<br>查看启动失败的服务列表：systemctl–failed</p><p>启动服务（等同于service httpd start）<br>systemctl start httpd.service<br>停止服务（等同于service httpd stop）<br>systemctl stop httpd.service<br>重启服务（等同于service httpd restart）<br>systemctl restart httpd.service<br>查看服务是否运行（等同于service httpd status）<br>systemctl status httpd.service<br>开机自启动服务（等同于chkconfig httpd on）<br>systemctl enable httpd.service<br>开机时禁用服务（等同于chkconfig httpd on）<br>systemctl disable httpd.service<br>查看服务是否开机启动 （等同于chkconfig –list）</p><p><code>journalctl</code> 日志</p><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      服务命令  centos7 systemctl centos6以下  service 
    
    </summary>
    
      <category term="Linux" scheme="https://muxiaobai.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS网络设置</title>
    <link href="https://muxiaobai.github.io/2020/09/23/CentOS%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"/>
    <id>https://muxiaobai.github.io/2020/09/23/CentOS网络设置/</id>
    <published>2020-09-23T05:58:22.000Z</published>
    <updated>2020-10-30T02:43:10.849Z</updated>
    
    <content type="html"><![CDATA[<p>查看硬件的编号</p><p><code>ip addr</code></p><p><img src="/2020/09/23/CentOS网络设置/ip.png" alt="获取硬件编号"></p><p>路径：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">#BOOTPROTO=dhcp</span><br><span class="line">IPADDR=192.168.160.74</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.160.254</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=3187afee-d4cd-4047-a498-e63f00570e53</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">HWADDR=00:0C:29:86:ef:a3</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/23/CentOS网络设置/ifcfg-ens33.png" alt="图解命令"></p><p>重启网络<br><code>systemctl restart network</code></p>]]></content>
    
    <summary type="html">
    
      网络配置 ip addr, ifcfg-ens33
    
    </summary>
    
      <category term="Linux" scheme="https://muxiaobai.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch集群化部署方案</title>
    <link href="https://muxiaobai.github.io/2020/06/23/%E9%9B%86%E7%BE%A4%E4%B9%8BElasticsearch%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>https://muxiaobai.github.io/2020/06/23/集群之Elasticsearch部署方案/</id>
    <published>2020-06-23T12:28:19.000Z</published>
    <updated>2020-08-18T05:33:22.286Z</updated>
    
    <content type="html"><![CDATA[<p>应用服务IP为:192.168.1.2,ES_HOME为安装目录</p><h3 id="1-修改elasticsearch-yml配置："><a href="#1-修改elasticsearch-yml配置：" class="headerlink" title="1.修改elasticsearch.yml配置："></a>1.修改elasticsearch.yml配置：</h3><p>修改ES_HOME/config.elasticsearch.yml<br>network.host: 192.168.1.2 # 对外暴露的IP，本机IP<br>http.port: 9200 #设置对外服务的http端口号<br>transport.tcp.port: 9300 #设置节点之间交互的端口号<br>discovery.zen.ping.unicast.hosts: [“192.168.1.2:9300”,”192.168.1.2:9301”,”192.168.1.2:9302”]</p><p>#集群IP其它可以是主节点的IP加transport.tcp.port端口</p><p>修改ES_HOME/config/analysis-hanlp/hanlp.properties<br>root 为ES_HOME绝对路径</p><p>修改ES_HOME/config/analysis-hanlp/hanlp-remote.xml<br>remote_ext_dict和remote_ext_stopwords</p><entry key="remote_ext_dict"><a href="http://192.168.1.2:8080/dict" target="_blank" rel="noopener">http://192.168.1.2:8080/dict</a></entry><br><entry key="remote_ext_stopwords"><a href="http://192.168.1.2:8080/stop_words" target="_blank" rel="noopener">http://192.168.1.2:8080/stop_words</a></entry><p>可以添加hanlp插件或者ik插件 并配置远程更新词库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Logs(&quot;分词热更新到分词器中接口&quot;)</span><br><span class="line">@RequestMapping(&quot;/dict&quot;)</span><br><span class="line">public ResponseEntity dict(WebRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    // 1. 应用相关的方式计算得到(application-specific calculation)</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    if (request.checkNotModified(date)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; list= new ArrayList();</span><br><span class="line">    return ResponseEntity.ok().lastModified(date).body(String.join(&quot;\n&quot;,list));</span><br><span class="line">&#125;</span><br><span class="line">@Logs(&quot;停顿词热更新到分词器中接口&quot;)</span><br><span class="line">@RequestMapping(&quot;/stop_words&quot;)</span><br><span class="line">public ResponseEntity stopWords(WebRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    // 1. 应用相关的方式计算得到(application-specific calculation)</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    if (request.checkNotModified(date)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; list= new ArrayList();</span><br><span class="line">    return ResponseEntity.ok().lastModified(date).body(String.join(&quot;\n&quot;,list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-修改下面三个配置"><a href="#2-修改下面三个配置" class="headerlink" title="2.    修改下面三个配置"></a>2.    修改下面三个配置</h3><h4 id="vim-etc-security-limits-conf"><a href="#vim-etc-security-limits-conf" class="headerlink" title="vim /etc/security/limits.conf"></a>vim /etc/security/limits.conf</h4><p>错误1：max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536]<br>这个问题是无法创建本地文件,用户最大可创建文件数太小<br>解决：只需要修改创建文件的最大数目为65536就行了<br>root用户修改<br>vim /etc/security/limits.conf</p><pre><code>root soft nofile 65536root hard nofile 65536* soft nofile 65536* hard nofile 65536</code></pre><p>保存、退出、重新登录才可生效</p><p>参数解释：</p><ul><li>soft nproc:可打开的文件描述符的最大数(软限制)</li><li>hard nproc:可打开的文件描述符的最大数(硬限制)</li><li>soft nofile:单个用户可用的最大进程数量(软限制)</li><li>hard nofile:单个用户可用的最大进程数量(硬限制)<h4 id="vim-etc-sysctl-conf"><a href="#vim-etc-sysctl-conf" class="headerlink" title="vim /etc/sysctl.conf"></a>vim /etc/sysctl.conf</h4></li></ul><p>错误2：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]<br>虚拟内存太小<br>切换到root用户修改</p><p>vim /etc/sysctl.conf</p><p>vm.max_map_count=262144<br>执行命令：</p><p> sysctl -p</p><h4 id="vim-ES-HOME-config-jvm-options"><a href="#vim-ES-HOME-config-jvm-options" class="headerlink" title="vim ES_HOME/config/jvm.options"></a>vim ES_HOME/config/jvm.options</h4><p>错误3：Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=’Cannot allocate memory’ (errno=12)<br>jvm需要分配的内存太大<br>vim ES_HOME/config/jvm.options</p><p>设置 –Xmx2g和-Xms2g</p><p>推荐单机版16g<br>单机不得超过32G，否则会引发指针膨胀，虽然堆内存变大了，但是所能指向的实际对象会减少。</p><h3 id="3-不能使用root启动，必须创建用户"><a href="#3-不能使用root启动，必须创建用户" class="headerlink" title="3.    不能使用root启动，必须创建用户"></a>3.    不能使用root启动，必须创建用户</h3><p>添加用户：useradd -m 用户名  然后设置密码  passwd 用户名<br>useradd -m admin<br>passwd admin<br>修改文件夹权限<br>chown -R  admin elasticsearch</p><p>启动可能出现的错误</p><h3 id="4-启动"><a href="#4-启动" class="headerlink" title="4.    启动"></a>4.    启动</h3><p>ES_HOME/bin/elasticsearch -d</p><h3 id="5-无法形成集群"><a href="#5-无法形成集群" class="headerlink" title="5.    无法形成集群"></a>5.    无法形成集群</h3><p>删除elsticsearch文件夹下的data文件夹下的节点数据<br>调整 discovery.zen.minimum_master_nodes: 2 （N  master节点/2）+1</p><h3 id="6-设置密码X-pack"><a href="#6-设置密码X-pack" class="headerlink" title="6.    设置密码X-pack"></a>6.    设置密码X-pack</h3><p>1、    安全配置<br>默认情况下，拥有安全免费许可证时，Elasticsearch安全功能被禁用。 要启用安全功能，需要设置xpack.security.enabled。<br>在每个节点(包括node-1、node-2、node-3)的elasticsearch.yml配置文件中，新增：<br>xpack.security.enabled: true<br>2、    为节点间通信配置传输层安全性(TLS/SSL)<br>借助elasticsearch-certutil命令生成证书<br>cd ES_HOME/bin/<br>./elasticsearch-certutil ca -out /etc/elasticsearch/elastic-certificates.p12 -pass “”</p><p>Root用户<br>chown -R elasticsearch:elasticsearch   /etc/elasticsearch/elastic-certificates.p12<br>将证书拷贝到其他节点，放入 /etc/elasticsearch 目录下<br>cd /etc/elasticsearch/<br>scp elastic-certificates.p12  172.168.201.77:/etc/elasticsearch/<br>scp elastic-certificates.p12  172.168.201.78:/etc/elasticsearch/<br>3、    配置加密通信<br>启用安全功能后，必须使用TLS来确保节点之间的通信已加密。<br>在elasticsearch.yml中心新增配置如下：(其他节点相同配置)<br>xpack.security.transport.ssl.enabled: true<br>xpack.security.transport.ssl.verification_mode: certificate<br>xpack.security.transport.ssl.keystore.path: elastic-certificates.p12<br>xpack.security.transport.ssl.truststore.path: elastic-certificates.p12<br>重启elasticsearch服务<br>4、    设置集群密码<br>因为你上面已经做了SSL通信，所以只需要在第一台es(master)上设置用户名和密码就可以了，其他的2台es就会是相同的用户名密码<br>[elastic@es-node1 bin]$ cd /usr/share/elasticsearch/bin<br>[elastic@es-node1 bin]$ ./elasticsearch-setup-passwords -h  #查看命令帮助<br>Sets the passwords for reserved users</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p>auto - Uses randomly generated passwords          #主要命令选项，表示系统将使用随机字符串设置密码<br>interactive - Uses passwords entered by a user    #主要命令选项，表示使用用户输入的字符串作为密码</p><p>Non-option arguments:<br>command            </p><p>Option         Description      </p><hr><p>-h, –help     show help<br>-s, –silent   show minimal output<br>-v, –verbose  show verbose output<br>[elastic@es-node1 bin]$ ./elasticsearch-setup-passwords auto  #为了演示效果，这里我们使用系统自动创建<br>Initiating the setup of passwords for reserved users elastic,kibana,logstash_system,beats_system.<br>The passwords will be randomly generated and printed to the console.<br>Please confirm that you would like to continue [y/N]y     #选择y<br>Changed password for user kibana                   #kibana角色和密码<br>PASSWORD kibana = 4VXPRYIVibyAbjugK6Ok<br>Changed password for user logstash_system          #logstash角色和密码<br>PASSWORD logstash_system = 2m4uVdSzDzpt9OEmNin5<br>Changed password for user beats_system             #beast角色和密码<br>PASSWORD beats_system = O8VOzAaD3fO6bstCGDyQ<br>Changed password for user elastic                  #elasticsearch角色和密码<br>PASSWORD elastic = 1TWVMeN8tiBy917thUxq<br>核心：<br>auto - 随机生成密码。<br>interactive - 自定义不同用户的密码。<br>附：elasticsearch-setup-passwords此脚本只能运行一次，如要修改密码可以在kibana 中设置密码</p><p>验证是否正常<br><a href="http://192.168.1.2:9200" target="_blank" rel="noopener">http://192.168.1.2:9200</a></p><p>输入上一步生成的elastic和密码</p><p><a href="http://192.168.1.2:9200/_cluster/health" target="_blank" rel="noopener">http://192.168.1.2:9200/_cluster/health</a></p><p><a href="http://192.168.160.23:9100/?auth_user=elastic&amp;auth_password=123123" target="_blank" rel="noopener">http://192.168.160.23:9100/?auth_user=elastic&amp;auth_password=123123</a><br>curl -u elastic ‘<a href="http://192.168.1.2:9200/_xpack/security/_authenticate?pretty’" target="_blank" rel="noopener">http://192.168.1.2:9200/_xpack/security/_authenticate?pretty’</a> </p><h3 id="7-重置密码-非必须，如忘记密码"><a href="#7-重置密码-非必须，如忘记密码" class="headerlink" title="7.    重置密码(非必须，如忘记密码)"></a>7.    重置密码(非必须，如忘记密码)</h3><p>创建本地超级账户，然后使用api接口本地超级账户重置elastic账户的密码<br>(1) 停止elasticsearch服务<br>(2) 确保你的配置文件中支持本地账户认证支持，如果你使用的是xpack的默认配置则无需做特殊修改；如果你配置了其他认证方式则需要确保配置本地认证方式在ES_HOME/config/elasticsearch.yml中；<br>(3) 使用命令ES_HOME/bin/ elasticsearch-users 建一个基于本地问价认证的超级管理员<br>bin/elasticsearch-users useradd my_admin -p my_password -r superuser<br>(4) 启动elasticsearch服务<br>(5) 通过api重置elastic超级管理员的密码<br>curl -H “Content-Type:application/json” -XPOST -u my_admin ‘<a href="http://192.168.1.2:9200/_xpack/security/user/elastic/_password&#39;" target="_blank" rel="noopener">http://192.168.1.2:9200/_xpack/security/user/elastic/_password&#39;</a> -d ‘{ “password” : “123123” }’<br>(6) 校验下密码是否重置成功<br>curl -u elastic ‘<a href="http://192.168.1.2:9200/_xpack/security/_authenticate?pretty&#39;" target="_blank" rel="noopener">http://192.168.1.2:9200/_xpack/security/_authenticate?pretty&#39;</a><br>(7)删除my_admin账号<br>bin/elasticsearch-users userdel my_admin</p><h2 id="附：默认集群配置："><a href="#附：默认集群配置：" class="headerlink" title="附：默认集群配置："></a>附：默认集群配置：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true  #跨域连接相关设置</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;  #跨域连接相关设置  </span><br><span class="line">http.cors.allow-headers: Authorization,content-type</span><br><span class="line"></span><br><span class="line">cluster.name: elasticsearch #集群的名称，同一个集群该值必须设置成相同的</span><br><span class="line">node.name: master #该节点的名字</span><br><span class="line">node.master: true #该节点有机会成为master节点</span><br><span class="line">node.data: true #该节点可以存储数据</span><br><span class="line"></span><br><span class="line">#network.bind_host: 0.0.0.0 #设置绑定的IP地址，可以是IPV4或者IPV6</span><br><span class="line">#network.publish_host: 192.168.1.2 #设置其他节点与该节点交互的IP地址</span><br><span class="line">network.host: 192.168.1.2 #该参数用于同时设置bind_host和publish_host</span><br><span class="line"></span><br><span class="line">http.port: 9200 #设置对外服务的http端口号</span><br><span class="line">http.max_content_length: 100mb #设置http内容的最大大小</span><br><span class="line">http.enabled: true #是否开启http服务对外提供服务</span><br><span class="line">transport.tcp.port: 9300 #设置节点之间交互的端口号</span><br><span class="line">transport.tcp.compress: true #设置是否压缩tcp上交互传输的数据</span><br><span class="line"></span><br><span class="line">cluster.initial_master_nodes: [&quot;master&quot;]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2 #设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。官方推荐（N/2）+1</span><br><span class="line">discovery.zen.ping_timeout: 120s #设置集群中自动发现其他节点时ping连接的超时时间</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.1.2:9300&quot;,&quot;192.168.1.2:9500&quot;,&quot;192.168.1.2:9700&quot;] #设置集群中的Master节点的初始列表，可以通过这些节点来自动发现其他新加入集群的节点</span><br><span class="line">#discovery.zen.ping.unicast.hosts 使用network.host. transport.tcp.port</span><br><span class="line"></span><br><span class="line">#开启x-pack安全验证</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.license.self_generated.type: basic</span><br><span class="line">##如果是basic license的话需要加入下面这一行，不然的话restart elasticsearch之后会报错。</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line">xpack.security.transport.ssl.verification_mode: certificate</span><br><span class="line">xpack.security.transport.ssl.keystore.path: elastic-certificates.p12</span><br><span class="line">xpack.security.transport.ssl.truststore.path: elastic-certificates.p12</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/muxiaobai/shell/tree/master/linux/elasticsearch" target="_blank" rel="noopener">github 集群脚本</a></p><p>自动化部署，包含单机多节点和多机多节点，其中，多机需要ssh自动登录。</p>]]></content>
    
    <summary type="html">
    
      安装集群ES,集群方案
    
    </summary>
    
      <category term="集群" scheme="https://muxiaobai.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 高级之JIT即时编译</title>
    <link href="https://muxiaobai.github.io/2020/06/04/Thinking-in-java-%E9%AB%98%E7%BA%A7%E4%B9%8BJIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/"/>
    <id>https://muxiaobai.github.io/2020/06/04/Thinking-in-java-高级之JIT即时编译/</id>
    <published>2020-06-04T08:54:39.000Z</published>
    <updated>2020-06-12T07:29:53.201Z</updated>
    
    <content type="html"><![CDATA[<p>以synchronized为例：<br><img src="/2020/06/04/Thinking-in-java-高级之JIT即时编译/execjava.png" alt="exec"></p><h3 id="什么是JIT？"><a href="#什么是JIT？" class="headerlink" title="什么是JIT？"></a>什么是JIT？</h3><p>JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。JIT编译一词后来被泛华，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。JIT(即时编译)是用来提高java程序运行效率的，原本字节码由解释器需要经过解释再运行，现在有了JIT技术，将字节码编译成平台相关的原生机器码，并进行各个层次的优化，这些机器码会被缓存起来，以备下次使用，如果JIT对每条字节码都进行编译，缓存(缓存的指令是有限的)，会增加开销，因此JIT只对热点代码进行即时编译，如循环，高频度使用的方法，会将整个方法编译成本地机器码，然后直接运行机器码。</p><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>pom.xml添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;LATEST&lt;/version&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">            &lt;execution&gt;</span><br><span class="line">                &lt;goals&gt;</span><br><span class="line">                    &lt;goal&gt;java&lt;/goal&gt;</span><br><span class="line">                &lt;/goals&gt;</span><br><span class="line">            &lt;/execution&gt;</span><br><span class="line">        &lt;/executions&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">            &lt;mainClass&gt;org.adoptopenjdk.jitwatch.launch.LaunchUI&lt;/mainClass&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p><p>main运行添加参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+TraceClassLoading</span><br><span class="line">-XX:+LogCompilation</span><br><span class="line">-XX:LogFile=mylogfile.log</span><br><span class="line">-XX:+PrintAssembly</span><br><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure></p><p>生成log文件<code>mvn exec:java</code>运行，添加log文件和源文件和编译文件</p><h3 id="编译器的时间开销和空间开销："><a href="#编译器的时间开销和空间开销：" class="headerlink" title="编译器的时间开销和空间开销："></a>编译器的时间开销和空间开销：</h3><p><img src="/2020/06/04/Thinking-in-java-高级之JIT即时编译/jit逻辑图.png" alt="jit逻辑图"><br>解释器的执行，抽象的看是这样的：<br>字节码 -&gt; [ 解释器 解释执行机器码 ] -&gt; 执行结果<br>而要JIT编译然后再执行的话，抽象的看则是：<br>字节码 -&gt; [ 编译器 编译 ] -&gt; 与机器相关的机器码-&gt; [ 执行 ] -&gt; 执行结果</p><p>说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。</p><h3 id="不会被JIT编译"><a href="#不会被JIT编译" class="headerlink" title="不会被JIT编译"></a>不会被JIT编译</h3><p>JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快。怎么算是“只执行一次的代码”呢？粗略说，下面两个条件同时满足时就是严格的“只执行一次”</p><p>1、只被调用一次，例如类的构造器（class initializer，()）<br>2、没有循环</p><p>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。只有对频繁执行的代码，JIT编译才能保证有正面的收益。</p><p>对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致“代码爆炸”。这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎。<br>哪些程序代码会被编译为本地代码？如何编译为本地代码？</p><h3 id="会被JIT编译"><a href="#会被JIT编译" class="headerlink" title="会被JIT编译"></a>会被JIT编译</h3><p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？运行过程中会被即时编译器编译的“热点代码”有两类：</p><p>1、被多次调用的方法。<br>2、被多次执行的循环体。</p><p>两种情况，编译器都是以整个方法作为编译对象。 这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换了。<br><img src="/2020/06/04/Thinking-in-java-高级之JIT即时编译/jit.png" alt="jit未编译和编译过得"></p><h3 id="呢到底多少次才会被JIT编译？"><a href="#呢到底多少次才会被JIT编译？" class="headerlink" title="呢到底多少次才会被JIT编译？"></a>呢到底多少次才会被JIT编译？</h3><p>即时编译JIT只在代码段执行足够次数才会进行优化，在执行过程中不断收集各种数据，作为优化的决策，所以在优化完成之前，例子中的User对象还是在堆上进行分配。</p><p>那么一段代码需要执行多少次才会触发JIT优化呢？通常这个值由-XX:CompileThreshold参数进行设置：</p><p>1、使用client编译器时，默认为1500；<br>2、使用server编译器时，默认为10000；</p><p>意味着如果方法调用次数或循环次数达到这个阈值就会触发标准编译，更改CompileThreshold标志的值，将使编译器提早（或延迟）编译。</p><p>除了标准编译，还有一个叫做OSR（On Stack Replacement）栈上替换的编译，如上述例子中的main方法，只执行一次，远远达不到阈值，但是方法体中执行了多次循环，OSR编译就是只编译该循环代码，然后将其替换，下次循环时就执行编译好的代码，不过触发OSR编译也需要一个阈值，可以通过以下公式得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:CompileThreshold = 10000</span><br><span class="line">-XX:OnStackReplacePercentage = 140</span><br><span class="line">-XX:InterpreterProfilePercentage = 33</span><br></pre></td></tr></table></figure><p>OSR trigger = (CompileThreshold * (OnStackReplacePercentage - InterpreterProfilePercentage)) / 100 = 10700</p><p>其中trigger即为OSR编译的阈值。</p><ul><li><a href="https://blog.csdn.net/qq_28674045/article/details/51896129" target="_blank" rel="noopener">Java性能优化指南系列(三）：理解JIT编译器</a></li><li><a href="https://www.jianshu.com/p/20bd2e9b1f03" target="_blank" rel="noopener">浅谈HotSpot逃逸分析</a></li><li><a href="https://www.jianshu.com/p/eea12f3bf490" target="_blank" rel="noopener">Java JIT 知识</a></li><li><a href="https://www.cnblogs.com/dzhou/p/9549839.html" target="_blank" rel="noopener">什么是JIT</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文主要介绍JIT是什么，什么时候会JIT，以及那些JVM参数与JIT有关
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>https是如何保护我们的隐私?</title>
    <link href="https://muxiaobai.github.io/2020/05/26/https%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E6%88%91%E4%BB%AC%E7%9A%84%E9%9A%90%E7%A7%81/"/>
    <id>https://muxiaobai.github.io/2020/05/26/https是如何保护我们的隐私/</id>
    <published>2020-05-26T02:50:55.000Z</published>
    <updated>2020-06-01T07:15:31.337Z</updated>
    
    <content type="html"><![CDATA[<p>怎么配置可以参考<a href="https://muxiaobai.github.io/2020/01/02/SpringBoot%E4%B9%8Bhttps%E8%AF%B7%E6%B1%82/">SpringBoot之https请求</a></p><h3 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h3><p>在信息安全性问题中，我们常常要做到三点才能保证信息的安全：</p><ul><li>信息的保密性</li><li>信息的完整性</li><li>身份识别</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>非对称加密中的：公钥(public)和私钥(private)</p><ul><li>公钥(public key)是对外开放的，私钥(private key)是自己拥有的。</li><li>公钥(public key)加密的数据，只能用私钥(private key)解密。</li><li>私钥(private key)加密的数据，只能用公钥(public key)解密。</li></ul><h3 id="一个简单的过程"><a href="#一个简单的过程" class="headerlink" title="一个简单的过程"></a>一个简单的过程</h3><p>首先，客户端向服务器发出加密请求。</p><p>3)服务器用自己的私钥加密网页以后，连同本身的数字证书，这里的数字证书，是CA发给你的（默认你是知道CA颁布的证书的），一起发送给客户端。</p><p>4)客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</p><p>5)如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</p><p>6)如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告</p><p>自己生成的证书，浏览器没有维护证书机构，因此标记不安全，但从算法上来说是安全的，加密过的信息，只是不知道出处，数据来源。</p><p><img src="https是如何保护我们的隐私/unsafe.png" alt="自己生成的证书"><br>明确一点：各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以客户端只需要知道是哪个机构(CA)颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p><p><a href="https://www.jianshu.com/p/29e0ba31fb8d" target="_blank" rel="noopener">一文看懂HTTPS、证书机构（CA）、证书、数字签名、私钥、公钥</a><br><a href="https://www.sohu.com/a/320031789_371153" target="_blank" rel="noopener">是时候理解下HTTPS的原理及流程了</a><br><a href="https://blog.csdn.net/u011123724/article/details/80586173" target="_blank" rel="noopener">钥与私钥，HTTPS详解</a><br><a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">对应的英文版本 上一篇</a></p>]]></content>
    
    <summary type="html">
    
      http 和https 为什么https可以保护隐私，CA又是什么？
    
    </summary>
    
      <category term="deploy" scheme="https://muxiaobai.github.io/categories/deploy/"/>
    
    
      <category term="信息安全" scheme="https://muxiaobai.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 高级之对象大小模型</title>
    <link href="https://muxiaobai.github.io/2020/05/19/Thinking-in-java-%E9%AB%98%E7%BA%A7%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://muxiaobai.github.io/2020/05/19/Thinking-in-java-高级之对象内存模型/</id>
    <published>2020-05-19T02:50:29.000Z</published>
    <updated>2020-06-01T07:56:32.874Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍对象的创建，对象一般有哪些内容，对象大小是怎么计算的，学习完，可以根据对象大小来优化jvm的设置。</p><p>下文默认64位机并开启指针压缩，-XX:+UseCompressedOops<br>压缩的所用：<br>1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力<br>2.为了减少64位平台下内存的消耗，启用指针压缩功能<br>3.在jvm中，32位地址表示4G个对象的指针，在4G-32G堆内存范围内，可以通过编码、解码方式进行优化，使得jvm可以支持更大的内存配置<br>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间<br>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p><p>以下内容会被压缩：<br>1.对象的全局静态变量(即类属性)<br>2.对象头信息:64位平台下，原生对象头大小为16字节，压缩后为12字节<br>3.对象的引用类型:64位平台下，引用类型本身大小为8字节，压缩后为4字节<br>4.对象数组类型:64位平台下，数组类型本身大小为24字节，压缩后16字节</p><p><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/jvm内存.png" alt="java 对象大小"><br>jvm内存模型图，熟悉吧，接着往下看。</p><p><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/oop指针.png" alt="java 对象大小"><br>先看图这个熟悉jvm的对这个指针指向都知道，基本数据类型在栈帧中，对象，复杂类型，栈帧中只保存对对象的应用，而真实的对象是存在堆中的，我们本文是要揭示堆中的这个对象到底有什么内容，包含哪些数据，记录的什么信息。</p><h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p>首先堆中的都是复杂对象这个可以理解吧，基本对象都在栈帧中了，就是int，long，char这些，注意String 不是 Integer不是，基本类型，这种是包装类型，String<br>内部包含一个char[] 和一个hash属性。<br><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/java对象大小.png" alt="java 对象大小"><br>对象包括 markword oop，（数组长度）成为对象头，这里有可能有一个内部对齐，然后是对象的属性，最后还有一个对齐。</p><p>注意：对齐，8位对齐，一个字节。<br><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/java对象模型.png" alt="java 对象大小"></p><p>大小应该怎么计算呢？分为两种情况，一种是Object ，一种是Array，Array中对象头包含了一个4位的数组长度。</p><h3 id="markword"><a href="#markword" class="headerlink" title="_markword"></a>_markword</h3><p><img src="/2020/05/19/Thinking-in-java-高级之对象内存模型/markword结构图.jpg" alt="java 对象大小"></p><p>这是markword的详细信息，也就是堆中的对象头包含的信息。<br>这里的正常对象，age  4位  2^4-1 =15,Eden区，从form到to同一个对象，最多标记只能移动15次，参数是<br>MaxTenuringThreshold 默认也是15，在调试gc的时候可以把年龄打印出来-XX:+PrintTenuringDistribution.</p><p>markword<br>第一部分markword,用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“MarkWord”。</p><h3 id="KlassOop"><a href="#KlassOop" class="headerlink" title="KlassOop"></a>KlassOop</h3><p>klass 64位机本有8字节，压缩之后4字节<br>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例. 32位4字节，64位开启指针压缩或最大堆内存&lt;32g时 4字节，否则8字节</p><p>指针，治理是指向方法区现在叫metaspace，我们可以想象一下反射的时候我们是不是要获取Class对象，这个Oop可以想象就是为了获取Class对象。</p><h3 id="数组长度-Array对象"><a href="#数组长度-Array对象" class="headerlink" title="数组长度(Array对象)"></a>数组长度(Array对象)</h3><p>数组长度（只有数组对象有） 4字节<br>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.int最大值2g，2^31，java数组（包含字符串）最长2g</p><h3 id="实际数据大小"><a href="#实际数据大小" class="headerlink" title="实际数据大小"></a>实际数据大小</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型大小：单位字节</p><ul><li>1 byte boolean</li><li>2 short char (ref引用，复杂对象指向，)</li><li>4 int folat</li><li>8 long double</li></ul><h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p>String =char[] + hash<br>Object = ref 4<br>上一个对象添加引用，本对象计算</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>包含数组类型属性的对象，还要加上一个数组长度，<br>一个数组需要添加一个长度</p><ul><li>int[] 基本类型 添加数组长度4 加上基本类型大小</li><li>Object[] 对象数组  添加数组长度 + ref  另外Object对象要占用16个位</li></ul><p><a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/java/objectsize/DoubleArraySize.java" target="_blank" rel="noopener">DoubleArraySize</a></p><p>下面来实战一下吧。</p><h2 id="JOL工具"><a href="#JOL工具" class="headerlink" title="JOL工具"></a>JOL工具</h2><p>pom.xml 引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class="line">print(ClassLayout.parseInstance(new Object()).toPrintable());</span><br><span class="line">print(ClassLayout.parseInstance(Object.class).toPrintable());//这个实际上是class对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12        (object header)                           N/A</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">java.lang.Class object internals:</span><br><span class="line"> OFFSET  SIZE                                              TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4                                                   (object header)                           01 e8 bf 80 (00000001 11101000 10111111 10000000) (-2134906879)</span><br><span class="line">      4     4                                                   (object header)                           1e 00 00 00 (00011110 00000000 00000000 00000000) (30)</span><br><span class="line">      8     4                                                   (object header)                           df 03 00 f8 (11011111 00000011 00000000 11111000) (-134216737)</span><br><span class="line">     12     4                     java.lang.reflect.Constructor Class.cachedConstructor                   null</span><br><span class="line">     16     4                                   java.lang.Class Class.newInstanceCallerCache              null</span><br><span class="line">     20     4                                  java.lang.String Class.name                                (object)</span><br><span class="line">     24     4                                                   (alignment/padding gap)                  </span><br><span class="line">     28     4                       java.lang.ref.SoftReference Class.reflectionData                      (object)</span><br><span class="line">     32     4   sun.reflect.generics.repository.ClassRepository Class.genericInfo                         null</span><br><span class="line">     36     4                                java.lang.Object[] Class.enumConstants                       null</span><br><span class="line">     40     4                                     java.util.Map Class.enumConstantDirectory               null</span><br><span class="line">     44     4                    java.lang.Class.AnnotationData Class.annotationData                      (object)</span><br><span class="line">     48     4             sun.reflect.annotation.AnnotationType Class.annotationType                      null</span><br><span class="line">     52     4                java.lang.ClassValue.ClassValueMap Class.classValueMap                       null</span><br><span class="line">     56    32                                                   (alignment/padding gap)                  </span><br><span class="line">     88     4                                               int Class.classRedefinedCount                 0</span><br><span class="line">     92   404                                                   (loss due to the next object alignment)</span><br><span class="line">Instance size: 496 bytes</span><br><span class="line">Space losses: 36 bytes internal + 404 bytes external = 440 bytes total</span><br></pre></td></tr></table></figure><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h3 id="本身大小"><a href="#本身大小" class="headerlink" title="本身大小"></a>本身大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package io.github.muxiaobai.java.objectsize;</span><br><span class="line"></span><br><span class="line">import org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line">public class JOLPeople &#123;</span><br><span class="line">    int age = 20;</span><br><span class="line">    String name = &quot;Xiaoming&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        print(ClassLayout.parseInstance(new JOLPeople()).toPrintable());</span><br><span class="line"></span><br><span class="line">        print(ClassLayout.parseInstance(new String(&quot;Xiaoming&quot;)).toPrintable());</span><br><span class="line">        char[] chars = new char[8];</span><br><span class="line">        chars[0] = &apos;X&apos;;</span><br><span class="line">        chars[1] = &apos;i&apos;;</span><br><span class="line">        chars[2] = &apos;a&apos;;</span><br><span class="line">        chars[3] = &apos;o&apos;;</span><br><span class="line">        chars[4] = &apos;m&apos;;</span><br><span class="line">        chars[5] = &apos;i&apos;;</span><br><span class="line">        chars[6] = &apos;n&apos;;</span><br><span class="line">        chars[7] = &apos;g&apos;;</span><br><span class="line"></span><br><span class="line">        print(ClassLayout.parseInstance(chars).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void print(String message) &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><h2 id="JOLPeople-本身"><a href="#JOLPeople-本身" class="headerlink" title="JOLPeople 本身"></a>JOLPeople 本身</h2><p> io.github.muxiaobai.java.objectsize.JOLPeople object internals:<br> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE<br> 0     4                    (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)<br> 4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br> 8     4                    (object header)                           af f3 00 f8 (10101111 11110011 00000000 11111000) (-134155345)<br> 12     4                int JOLPeople.age                             20<br> 16     4   java.lang.String JOLPeople.name                            (object)<br> 20     4                    (loss due to the next object alignment)<br> Instance size: 24 bytes<br> Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</p><hr><p> _mark +oop  + 4(age的value)+ 4(name引用)<br> 8     + 4   +  4            +4          + 4(lose) =  24</p><h3 id="ShallowSize"><a href="#ShallowSize" class="headerlink" title="ShallowSize"></a>ShallowSize</h3><p> String 是一个char[] 数组 和hash 两个属性</p><p> The value is used for character storage.<br>private final char value[];</p><p> Cache the hash code for the string<br>private int hash; // Default to 0</p><p>String</p><hr><p> java.lang.String object internals:<br> OFFSET  SIZE     TYPE DESCRIPTION                               VALUE<br> 0     4          (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)<br> 4     4          (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br> 8     4          (object header)                           da 02 00 f8 (11011010 00000010 00000000 11111000) (-134216998)<br> 12     4   char[] String.value                              []<br> 16     4      int String.hash                               0<br> 20     4          (loss due to the next object alignment)<br> Instance size: 24 bytes<br> Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</p><hr><p> _mark +oop  + 引用(char[])+ hash<br> 8     + 4   +  4            4 + lose =  24</p><p> char[]数组 大小</p><hr><p> [C object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br> 0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br> 4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br> 8     4        (object header)                           41 00 00 f8 (01000001 00000000 00000000 11111000) (-134217663)<br> 12     4        (object header)                           08 00 00 00 (00001000 00000000 00000000 00000000) (8)<br> 16    16   char [C.<elements>                             N/A<br> Instance size: 32 bytes<br> Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</elements></p><hr><p> _mark +oop + 数组长度 + 实际数据<br> 8     + 4   +  4     + 8(arrLength) * 2(char) =  32</p><p> 我们可以手工计算一下JOLPeople obj = new JOLPeople()的大小：<br> JOLPeople的Shallow size = 8(_mark) + 4(oop指针) +  4(age的value)+ 4(name引用) + 4(lose) = 24<br> String对象的长度 = 8(_mark) + 4(oop指针) + 4(char[8]引用) +4(hash) +4(lose) =  24<br> char[]对象长度 =  8(_mark) + 4(oop指针) +  4(数组长度占4个字节) + 8*2(value) = 32<br> 所以JOLPeople实际占用的空间 = 24 + 24 + 32 = 80</p><p>验证：参考:<a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/java/objectsize/ShallowSize.java" target="_blank" rel="noopener">github ShallowSize.java</a><br><a href="https://blog.csdn.net/scdn_cp/article/details/86491792" target="_blank" rel="noopener">Java对象结构与锁实现原理及MarkWord详解</a></p>]]></content>
    
    <summary type="html">
    
      Java对象模型，对象大小，对象头，数组对象，如何计算，怎么验证，(OOP)Ordinary Object Pointer
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 高级之synchronized</title>
    <link href="https://muxiaobai.github.io/2020/05/07/Thinking-in-java-%E9%AB%98%E7%BA%A7%E4%B9%8Bsynchronized/"/>
    <id>https://muxiaobai.github.io/2020/05/07/Thinking-in-java-高级之synchronized/</id>
    <published>2020-05-07T08:39:25.000Z</published>
    <updated>2020-06-12T07:30:19.712Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要</p><h3 id="先从内核态和用户态说起"><a href="#先从内核态和用户态说起" class="headerlink" title="先从内核态和用户态说起"></a>先从内核态和用户态说起</h3><p>0x80 软中断 频繁切换会耗时，切换到内核态，调用内核方法。</p><h3 id="从DCL到锁升级"><a href="#从DCL到锁升级" class="headerlink" title="从DCL到锁升级"></a>从DCL到锁升级</h3><p>Double Check Lock 单例<a href="https://github.com/muxiaobai/java-demo/blob/master/test-java-demo/src/main/java/io/github/muxiaobai/java/java/threadTest/Singleton.java" target="_blank" rel="noopener">参考Singleton.java</a></p><p>普通 偏向锁 轻量级锁 重量级锁</p><p>升级过程</p><h3 id="需要-markword信息-标记有哪一种锁"><a href="#需要-markword信息-标记有哪一种锁" class="headerlink" title="需要_markword信息 标记有哪一种锁"></a>需要_markword信息 标记有哪一种锁</h3><p><img src="/2020/05/07/Thinking-in-java-高级之synchronized/锁偏向.png" alt="java 对象大小"></p><h3 id="java字节码指令"><a href="#java字节码指令" class="headerlink" title="java字节码指令"></a>java字节码指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> private static sync classSync = new sync();</span><br><span class="line">public void doSth()&#123;</span><br><span class="line">       synchronized (sync.class)&#123;</span><br><span class="line">           System.out.println(&quot;test Synchronized 锁的是 class对象 因此this不会标记&quot; );</span><br><span class="line">           System.out.println(ClassLayout.parseInstance(this).toPrintable());</span><br><span class="line">       &#125;</span><br><span class="line">       synchronized (classSync)&#123;</span><br><span class="line">           System.out.println(&quot;test Synchronized 锁的是 private classSync对象 因此this会标记&quot; );</span><br><span class="line">           System.out.println(ClassLayout.parseInstance(this).toPrintable());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>sync锁对象，一个是锁class对象，一个是锁object对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;io/github/muxiaobai/java/java/threadTest/base/sync&gt;</span><br><span class="line"> 2 dup</span><br><span class="line"> 3 astore_1</span><br><span class="line"> 4 monitorenter   sync进入</span><br><span class="line"> 5 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line"> 8 ldc #12 &lt;test Synchronized 锁的是 class对象 因此this不会标记&gt;</span><br><span class="line">10 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">13 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">16 aload_0</span><br><span class="line">17 invokestatic #10 &lt;org/openjdk/jol/info/ClassLayout.parseInstance&gt;</span><br><span class="line">20 invokevirtual #11 &lt;org/openjdk/jol/info/ClassLayout.toPrintable&gt;</span><br><span class="line">23 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">26 aload_1</span><br><span class="line">27 monitorexit   sync退出</span><br><span class="line">28 goto 36 (+8)  异常退出 跳到36行，aload_0 继续往下执行，下一个sync</span><br><span class="line">31 astore_2</span><br><span class="line">32 aload_1</span><br><span class="line">33 monitorexit    sync退出</span><br><span class="line">34 aload_2</span><br><span class="line">35 athrow</span><br><span class="line">36 aload_0</span><br><span class="line">37 getfield #4 &lt;io/github/muxiaobai/java/java/threadTest/base/sync.classSync&gt;</span><br><span class="line">40 dup</span><br><span class="line">41 astore_1</span><br><span class="line">42 monitorenter  sync进入</span><br><span class="line">43 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">46 ldc #13 &lt;test Synchronized 锁的是 private classSync对象 因此this会标记&gt;</span><br><span class="line">48 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">51 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">54 aload_0</span><br><span class="line">55 invokestatic #10 &lt;org/openjdk/jol/info/ClassLayout.parseInstance&gt;</span><br><span class="line">58 invokevirtual #11 &lt;org/openjdk/jol/info/ClassLayout.toPrintable&gt;</span><br><span class="line">61 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">64 aload_1</span><br><span class="line">65 monitorexit   sync退出</span><br><span class="line">66 goto 74 (+8)  异常直接跳到 74行return</span><br><span class="line">69 astore_3</span><br><span class="line">70 aload_1</span><br><span class="line">71 monitorexit  sync退出</span><br><span class="line">72 aload_3</span><br><span class="line">73 athrow</span><br><span class="line">74 return</span><br></pre></td></tr></table></figure></p><p>注意 monitorenter 和monitorexit  ，每一个sync关键字，对应 一个enter和两个exit，正常退出和异常退出。</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>即时编译JIT只在代码段执行足够次数才会进行优化，在执行过程中不断收集各种数据，作为优化的决策; 什么代码会被即时编译 JIT，？</p><p><code>lock cmpxchg</code></p><p>方法上的锁调用方法的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void doSth1()&#123;</span><br><span class="line">       System.out.println(&quot;test Synchronized method，sync调用这个方法，方法上的，会锁this对象 ，也就是main方法中 new的sync&quot; );</span><br><span class="line">       System.out.println(ClassLayout.parseInstance(this).toPrintable());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>// access flags 0x21<br>public synchronized doSth1()V<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line"> 3 ldc #14 &lt;test Synchronized method，sync调用这个方法，方法上的，会锁this对象 ，也就是main方法中 new的sync&gt;</span><br><span class="line"> 5 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"> 8 getstatic #6 &lt;java/lang/System.out&gt;</span><br><span class="line">11 aload_0</span><br><span class="line">12 invokestatic #10 &lt;org/openjdk/jol/info/ClassLayout.parseInstance&gt;</span><br><span class="line">15 invokevirtual #11 &lt;org/openjdk/jol/info/ClassLayout.toPrintable&gt;</span><br><span class="line">18 invokevirtual #8 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">21 return</span><br></pre></td></tr></table></figure></p><p>### </p><ul><li><a href="https://juejin.im/post/5d5374076fb9a06ac76da894#heading-18" target="_blank" rel="noopener">Synchronized解析——如果你愿意一层一层剥开我的心</a></li><li><a href="https://www.cnblogs.com/charlesblc/p/5994162.html" target="_blank" rel="noopener">【转载】Java中的锁机制 synchronized &amp; 偏向锁 &amp; 轻量级锁 &amp; 重量级锁 &amp; 各自优缺点及场景 &amp; AtomicReference</a></li></ul>]]></content>
    
    <summary type="html">
    
      从synchronized到汇编,结合锁升级,探究背后的本质，
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java线上代码监控-linux分析线上问题</title>
    <link href="https://muxiaobai.github.io/2020/04/29/java%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81%E7%9B%91%E6%8E%A7-linux%E5%88%86%E6%9E%90%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    <id>https://muxiaobai.github.io/2020/04/29/java线上代码监控-linux分析线上问题/</id>
    <published>2020-04-29T08:41:41.000Z</published>
    <updated>2020-08-04T01:41:34.085Z</updated>
    
    <content type="html"><![CDATA[<p>jps(Java Virtual Machine Process Status Tool)<br>jstack(查看线程)、jmap(查看内存)和jstat(性能分析)</p><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>jps 找到对应的进程ID</p><p><code>jps -m -l</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure><p><code>ll /proc/[pid]/ | grep exe</code></p><p>可以查到时哪一个后台进程在执行</p><h2 id="未重启的话，分析现在的时候"><a href="#未重启的话，分析现在的时候" class="headerlink" title="未重启的话，分析现在的时候:"></a>未重启的话，分析现在的时候:</h2><h3 id="jstack-线程问题"><a href="#jstack-线程问题" class="headerlink" title="jstack 线程问题"></a>jstack 线程问题</h3><p>ps -mp [pid] -o THREAD,tid,time |sort -rn 打印CPU最高的线程<br>top -Hp [pid] </p><p>printf “%x\n” 22338 把线程ID转换成16进制<br>5742</p><p>jstack [pid] | grep 5742 -A 30 打印堆栈信息</p><p>-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况<br>-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</p><p>-F  to force a thread dump. Use when jstack <pid> does not respond (process is hung)<br>-m  to print both java and native frames (mixed mode)<br>-l  long listing. Prints additional information about locks<br>-h or -help to print this help message</pid></p><p><a href="https://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">jstack Dump 日志文件中的线程状态</a></p><p>线程死锁：<br>jstack –l pid | grep -i –E ‘BLOCKED | deadlock’</p><h3 id="jmap-堆问题"><a href="#jmap-堆问题" class="headerlink" title="jmap 堆问题"></a>jmap 堆问题</h3><p>jmap -heap [pid] 先查看堆栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./jmap -heap 22327</span><br><span class="line">Attaching to process ID 22327, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.201-b09</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 89128960 (85.0MB)</span><br><span class="line">   MaxNewSize               = 715653120 (682.5MB)</span><br><span class="line">   OldSize                  = 179306496 (171.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 671612928 (640.5MB)</span><br><span class="line">   used     = 349908376 (333.6986312866211MB)</span><br><span class="line">   free     = 321704552 (306.8013687133789MB)</span><br><span class="line">   52.0997082414709% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 12582912 (12.0MB)</span><br><span class="line">   used     = 12566640 (11.984481811523438MB)</span><br><span class="line">   free     = 16272 (0.0155181884765625MB)</span><br><span class="line">   99.87068176269531% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 22020096 (21.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 236978176 (226.0MB)</span><br><span class="line">   used     = 45630600 (43.51673126220703MB)</span><br><span class="line">   free     = 191347576 (182.48326873779297MB)</span><br><span class="line">   19.255190823985412% used</span><br><span class="line"></span><br><span class="line">38073 interned Strings occupying 3725472 bytes.</span><br></pre></td></tr></table></figure><p>查看对象</p><p>用jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象，如下：</p><p>数量和容量</p><p>实例数量前十的类：jmap -histo pid | sort -n -r -k 2 | head -10</p><p>实例容量前十的类：jmap -histo pid | sort -n -r -k 3 | head -10</p><h4 id="生成hprof文件（hprof（Heap-CPU-Profiling-Tool））"><a href="#生成hprof文件（hprof（Heap-CPU-Profiling-Tool））" class="headerlink" title="生成hprof文件（hprof（Heap/CPU Profiling Tool））"></a>生成hprof文件（hprof（Heap/CPU Profiling Tool））</h4><p><code>./jmap -dump:live,format=b,file=dump.dump [pid]</code></p><p>可以用：<code>./jhat -port 9998 dump.dump</code>  <code>./jhat -J-Xmx512m -port 9998 dump.dump</code><br>jhat -port 7401 -J -Xmx4G dump.dump</p><p>或者dump文件修改为dump.hprof,可以加到jprofiler</p><p>作用：主要分析内部当时的对象。</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat（JVM统计监测工具）</p><p>每隔250ms采集4次<code>./jstat -gc 30359 250 4</code><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>区容量（Capacity）和使用量（Used）<br>S0 S1 Survivor E O Eden Old M MetaspaceSize CCS CompressedClassSpaceSize  YG young gc FG  full gc T time FCT full gc time</p><p><code>./jstat -options</code> 参数 -gc  </p><p>250ms调用4次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./jstat -gc 22327  250 4</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU            MC     MU     CCSC   CCSU      YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br><span class="line">12288.0 21504.0 12272.1  0.0   655872.0 341707.4  231424.0   44561.1   87384.0 83940.7 11352.0 10729.1     18    0.238   3      0.254    0.492</span><br></pre></td></tr></table></figure><h2 id="准备重启复现的话："><a href="#准备重启复现的话：" class="headerlink" title="准备重启复现的话："></a>准备重启复现的话：</h2><p>第一步 加参数 ：</p><p>gc日志 配置Catalina.bat JAVA_OPTS</p><p><code>-Xloggc:./logs/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintTenuringDistribution -XX:+PrintHeapAtGC -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32  -XX:GCLogFileSize=64m -XX:+HeapDumpOnOutOfMemoryError</code></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247495546&amp;idx=1&amp;sn=f435f56c3b92802ef649cd14bb60711b&amp;chksm=e92ad275de5d5b63b9fc1e48463044ea1b234a4f28d0ad8d7964c42516f1cf7cae47c60162dc&amp;scene=0&amp;xtrack=1&amp;exportkey=AeNCSm6QS4EwNcRCTNfXDUs%3D&amp;pass_ticket=sHf4d8XsExleK1yRet7Gq5oJd6I%2FDOYRgopyFK8gH%2B81%2FhlGHzeiSrSlgR9oXDlk#rd" target="_blank" rel="noopener">步骤:线上问题定位，重启大法好！线上常见问题排查手册</a></li><li><a href="https://blog.csdn.net/muyimo/article/details/52837323?utm_source=distribute.pc_relevant.none-task-blog-baidujs-8" target="_blank" rel="noopener">VM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解</a></li></ul><p>一  线上常见问题定位</p><p>常见问题 1：CPU 利用率高</p><p>CPU 使用率是衡量系统繁忙程度的重要指标，一般情况下单纯的 CPU 高并没有问题，它代表系统正在不断的处理我们的任务，但是如果 CPU 过高，导致任务处理不过来，从而引起 load 高，这个是非常危险需要关注的。 CPU 使用率的安全值没有一个标准值，取决于你的系统是计算密集型还是 IO 密集型，一般计算密集型应用 CPU 使用率偏高 load 偏低，IO 密集型相反。</p><p>问题原因及定位：</p><p>1  频繁 FullGC/YongGC</p><p>2  代码消耗，如死循环，md5 等内存态操作</p><p>常见问题 2：load 高</p><p>load 指单位时间内活跃进程数，包含运行态（runnable 和 running）和不可中断态（ IO、内核态锁）。关键字是运行态和不可中断态，运行态可以联想到 Java 线程的 6 种状态，如下，线程 new 之后处于 NEW 状态，执行 start 进入 runnable 等待 CPU 调度，因此如果 CPU 很忙会导致 runnable 进程数增加；不可中断态主要包含网络 IO、磁盘 IO 以及内核态的锁，如 synchronized 等。</p><p>问题原因及定位：</p><p>1  CPU 利用率高，可运行态进程数多</p><p>2  iowait，等待 IO</p><p>3  等待内核态锁，如 synchronized</p><p>常见问题 3：持续 FullGC</p><p>问题原因及定位：</p><p>1  prommotion failed</p><p>从S区晋升的对象在老年代也放不下导致 FullGC（fgc 回收无效则抛 OOM）。</p><p>1）survivor 区太小，对象过早进入老年代。</p><p>2）大对象分配，没有足够的内存。</p><p>日志查找关键字 “allocating large”；</p><p>2  concurrent mode failed</p><p>在 CMS GC 过程中业务线程将对象放入老年代（并发收集的特点）内存不足。详细原因：</p><p>1）fgc 触发比例过大，导致老年代占用过多，并发收集时用户线程持续产生对象导致达到触发 FGC 比例。</p><p>jinfo  查看 CMSInitiatingOccupancyFraction 参数，一般 70~80 即可</p><p>2）老年代存在内存碎片。</p><p>jinfo  查看 UseCMSCompactAtFullCollection 参数，在 FullGC 后整理内存</p><p>常见问题 4：线程池满</p><p>Java 线程池以有界队列的线程池为例，当新任务提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求。如果正在运行的线程数等于 corePoolSize 时，则新任务被添加到队列中，直到队列满。当队列满了后，会继续开辟新线程来处理任务，但不超过 maximumPoolSize。当任务队列满了并且已开辟了最大线程数，此时又来了新任务，ThreadPoolExecutor 会拒绝服务。</p><p>问题原因及定位：</p><p>2  数据库慢 sql 或者数据库死锁</p><p>日志关键字 “Deadlock found when trying to get lock”</p><p>Jstack 或 zprofiler 查看阻塞态线程</p><p>3  Java 代码死锁</p><p>jstack –l pid | grep -i –E ‘BLOCKED | deadlock’</p>]]></content>
    
    <summary type="html">
    
      总结CPU怎么处理load 怎么处理
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年个人总结</title>
    <link href="https://muxiaobai.github.io/2020/01/13/2019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://muxiaobai.github.io/2020/01/13/2019年个人总结/</id>
    <published>2020-01-13T11:59:49.000Z</published>
    <updated>2020-08-04T10:01:42.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作-技能"><a href="#工作-技能" class="headerlink" title="工作 技能"></a>工作 技能</h2><h4 id="认清自己的位置"><a href="#认清自己的位置" class="headerlink" title="认清自己的位置"></a>认清自己的位置</h4><p>微服务可以落地，持续集成可以试验。这点和公司的形势有关，至少是自己愿意做的内容。</p><h4 id="找到和工作结合的内容"><a href="#找到和工作结合的内容" class="headerlink" title="找到和工作结合的内容"></a>找到和工作结合的内容</h4><p>去年写了今年的思维导图，今年的工作大概3个季度都是在做搜索，那就把这个东西，做好，附件搜，图片搜，优化，不断，提高。</p><h4 id="沉淀"><a href="#沉淀" class="headerlink" title="沉淀"></a>沉淀</h4><p>工作上处于沉淀状态，感觉前两年，已经把之前的优势全都散光了，让时间把我逐渐磨平，这两年又没有什么特别大的发展，一直是在缝缝补补，而且又没有专业性，也没有深入探索，还是流于表面，因<br>此现在再不向前，之后又该拿什么家底来败呢？已经一穷二白了。想想大学时候，基本上都是到十点，然后还有身体锻炼，还年少，真的都是财富，都是优势，现在反而不如以前了。</p><h4 id="大小公司"><a href="#大小公司" class="headerlink" title="大小公司"></a>大小公司</h4><p>小公司，人家都重视你，因为你是全栈，都会，人家都会问你，也看得起你，但你会有一种无力感，没什么可以请教的。大公司，虽然你都会，但你会的每一样公司都有比你更好的，你就显得普通，平庸，实际上本来就是平庸，因为你不够耀眼，你做的内容，不会一下子显现出来，需要用心做，用力深挖，潜心研究，才能有所作为。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>来到bilibili，真的是奇奇怪怪的知识点又增加了，有太多厉害的人物，UP主，只需潜心学习，</p><p>生产资料，和消费品，一定要分的清楚，比如网络，在你学习的时候就是生产资料，在你打游戏的时候，大可能是消费品，比如手机，该换就要早换，不能让这些影响到自己，人家都能在远程办公，咱自己还要去找，找电脑，找网络，找桌椅，这些设备，本应提前备好，以免在用的时候反而约束你。</p><h2 id="去过的地方"><a href="#去过的地方" class="headerlink" title="去过的地方"></a>去过的地方</h2><h4 id="渭南-华山"><a href="#渭南-华山" class="headerlink" title="渭南-华山"></a>渭南-华山</h4><p>太多可以写，认识彼此，冲突产生，今年看去哪里看一看，想去看大熊猫，不知可以不可以？</p><h4 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h4><p>第二次来北京看升国旗，上一次还是大学，顺带来北京看一下，就走了，还看了圆明园和颐和园，以及去了中关村，历史的痕迹和现代化的气息交融在这座城市，</p><p>故宫博物馆，有太多精美的物件，上层人的玩物，你是想都想不到的，镶金，珠光宝石。现在，也是，只不过换了物件而已，但你也是从未有所想象，只能是人家摆在你面前吗，你还在疑问，这是啥？好高级。</p><h4 id="郑州"><a href="#郑州" class="headerlink" title="郑州"></a>郑州</h4><p>虽然是来这里，但是观感不好，郑州大学还是河南的211学校，我虽然是河南的，但河南的高校太少了。<br>河南建业-广州富力，现场看足球，据说看建业的大都是情怀，河南建业足球是是赔钱的，但建业老板还是在支持，怎么说也是中超级别的俱乐部。</p><h4 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h4><p>工作，收入来源的重要性，停工停产，待岗降薪，有太多的不确定性。<br>身体，健康无比重要，活得久，也能说是一种幸福呢？<br>家人，有时候，陪伴在他们身边，也感觉没有那么多害怕，要说来工作的路上，还是有些心惊胆战，<br>意外，啥时候都不会也不可能全部如你所愿，做好准备，plan B，既是现在失去一切，也要有所打算，不要抱怨，不要忧虑，只需正视前方，勇往直前，无悔。</p><p>虽然晚来上班，不过还是按正常时间开工了，只不是换了一种方式而已，</p><p>今年的疫情，会让网课也来越来越普及，有自己喜欢的圈子，看自己感兴趣的直播，找到自己的生活方式。</p><h4 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h4><p>逐渐处于稳定状态，除了工作已经不愿走动，也无法走动，生活已经快将我禁锢到了这里。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><h4 id="2019年计划完成情况"><a href="#2019年计划完成情况" class="headerlink" title="2019年计划完成情况"></a>2019年计划完成情况</h4><ul><li>听讲座，参加技术，文化，社会论坛等，扩展知识广度。</li><li>心理学知识，受益匪浅，需要继续学习。</li><li>研究服务器性能、部署等问题，分析出自己的一套配置。</li></ul><p>通过去年的预习，复习，工作要求，找工作的知识补充，现在对高级知识总算有了一点了解，越来越感觉个人的能力提升到了瓶颈期，因为后面的知识，更加陡峭，而自己已经没有了当初的那股韧劲和毅力。要付出，才有可能有收获，既是这收获不及一二。否则只会后退，因为你的工作时间赶不上你的能力提升。</p><h4 id="2020年计划"><a href="#2020年计划" class="headerlink" title="2020年计划"></a>2020年计划</h4><ul><li></li><li>挣点小钱，现实需求。</li><li>今年既然有工作在做搜索，图像文件优化，那就索性将它做好一点吧，用上之前了解的知识。ヾ(◍°∇°◍)ﾉﾞ</li><li></li></ul><p>2020.03.20 慕小白 于陕西西安</p>]]></content>
    
    <summary type="html">
    
      2019年已经过去，总结一下。
    
    </summary>
    
      <category term="总结" scheme="https://muxiaobai.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2019" scheme="https://muxiaobai.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之https请求</title>
    <link href="https://muxiaobai.github.io/2020/01/02/SpringBoot%E4%B9%8Bhttps%E8%AF%B7%E6%B1%82/"/>
    <id>https://muxiaobai.github.io/2020/01/02/SpringBoot之https请求/</id>
    <published>2020-01-02T06:26:33.000Z</published>
    <updated>2020-07-01T02:00:54.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias spring -keypass 123456 -keyalg RSA -keysize 1024 -validity 365 -keystore E:/spring.keystore -storepass 123456</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-genkey      在用户主目录中创建一个默认文件&quot;.keystore&quot;,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书</span><br><span class="line">(在没有指定生成位置的情况下,keystore会存在用户系统默认目录，如：对于window xp系统，会生成在系统的C:/Documents and Settings/UserName/文件名为“.keystore”)</span><br><span class="line">-alias       产生别名</span><br><span class="line">-keystore    指定密钥库的名称(产生的各类信息将不在.keystore文件中)</span><br><span class="line">-keyalg      指定密钥的算法 (如 RSA  DSA（如果不指定默认采用DSA）)</span><br><span class="line">-validity    指定创建的证书有效期多少天</span><br><span class="line">-keysize     指定密钥长度</span><br><span class="line">-storepass   指定密钥库的密码(获取keystore信息所需的密码)</span><br><span class="line">-keypass     指定别名条目的密码(私钥的密码)</span><br><span class="line">-dname       指定证书拥有者信息 例如：  &quot;CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名称,ST=州或省份名称,C=单位的两字母国家代码&quot;</span><br><span class="line">-list        显示密钥库中的证书信息      keytool -list -v -keystore 指定keystore -storepass 密码</span><br><span class="line">-v           显示密钥库中的证书详细信息</span><br><span class="line">-export      将别名指定的证书导出到文件  keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码</span><br><span class="line">-file        参数指定导出到文件的文件名</span><br><span class="line">-delete      删除密钥库中某条目          keytool -delete -alias 指定需删除的别  -keystore 指定keystore  -storepass 密码</span><br><span class="line">-printcert   查看导出的证书信息          keytool -printcert -file yushan.crt</span><br><span class="line">-keypasswd   修改密钥库中指定条目口令    keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new  新密码  -storepass keystore密码  -keystore sage</span><br><span class="line">-storepasswd 修改keystore口令      keytool -storepasswd -keystore e:/yushan.keystore(需修改口令的keystore) -storepass 123456(原始密码) -new yushan(新密码)</span><br><span class="line">-import      将已签名数字证书导入密钥库  keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书</span><br></pre></td></tr></table></figure><p>默认参数：</p><p>下面是各选项的缺省值。<br>-alias “mykey”</p><p>-keyalg “DSA”</p><p>-keysize 1024</p><p>-validity 90</p><p>-keystore 用户宿主目录中名为 .keystore 的文件</p><p>-file 读时为标准输入，写时为标准输</p><h2 id="修改yaml配置文件"><a href="#修改yaml配置文件" class="headerlink" title="修改yaml配置文件"></a>修改yaml配置文件</h2><p>把E盘下的spring.keystore证书文件拷贝到项目中的resources目录中 , 然后在application.yml中配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  ssl:</span><br><span class="line">    key-alias: spring</span><br><span class="line">    key-password: 123456</span><br><span class="line">    key-store: classpath:spring.keystore</span><br></pre></td></tr></table></figure></p><p>和生成的证书的参数对应，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8443</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /</span><br><span class="line">  ssl:</span><br><span class="line">    key-store: classpath:spring.keystore</span><br><span class="line">    key-password: 123456</span><br><span class="line">    key-alias: spring</span><br><span class="line">    key-store-type:</span><br><span class="line">    key-store-password:</span><br><span class="line">    key-store-provider:</span><br><span class="line">http:</span><br><span class="line">  port: 8080</span><br></pre></td></tr></table></figure><h2 id="添加http和https同时监听"><a href="#添加http和https同时监听" class="headerlink" title="添加http和https同时监听"></a>添加http和https同时监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.catalina.Context;</span><br><span class="line">import org.apache.catalina.connector.Connector;</span><br><span class="line">import org.apache.tomcat.util.descriptor.web.SecurityCollection;</span><br><span class="line">import org.apache.tomcat.util.descriptor.web.SecurityConstraint;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @date 2020/1/2/002 13:52</span><br><span class="line"> * @TODO Http支持</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class TomcatConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    TomcatServletWebServerFactory tomcatServletWebServerFactory() &#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void postProcessContext(Context context) &#123;</span><br><span class="line">                SecurityConstraint constraint = new SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(&quot;CONFIDENTIAL&quot;);</span><br><span class="line">                SecurityCollection collection = new SecurityCollection();</span><br><span class="line">                collection.addPattern(&quot;/*&quot;);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">    private Connector createTomcatConnector() &#123;</span><br><span class="line">        // 默认协议为 TomcatServletWebServerFactory.DEFAULT_PROTOCOL=org.apache.coyote.http11.Http11NioProtocol</span><br><span class="line">        Connector connector = new</span><br><span class="line">                Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);</span><br><span class="line">        connector.setScheme(&quot;http&quot;);</span><br><span class="line">        connector.setPort(port);</span><br><span class="line">        connector.setSecure(false);</span><br><span class="line">        connector.setRedirectPort(httpsPort);//请求8080转到8443端口</span><br><span class="line">        return connector;</span><br><span class="line">    &#125;</span><br><span class="line">    //8080 请求8080转到8443端口</span><br><span class="line">    @Value(&quot;$&#123;http.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">    </span><br><span class="line">    //8443</span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private Integer httpsPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2020-01-02 14:17:43.303  INFO 10076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine local hostname</span><br><span class="line">2020-01-02 14:17:44.394  INFO 10076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine local hostname</span><br><span class="line">2020-01-02 14:17:44.629  INFO 10076 --- [           main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING</span><br><span class="line">2020-01-02 14:17:44.667  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka in region us-east-1</span><br><span class="line">2020-01-02 14:17:44.719  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON encoding codec LegacyJacksonJson</span><br><span class="line">2020-01-02 14:17:44.720  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON decoding codec LegacyJacksonJson</span><br><span class="line">2020-01-02 14:17:44.873  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML encoding codec XStreamXml</span><br><span class="line">2020-01-02 14:17:44.874  INFO 10076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML decoding codec XStreamXml</span><br><span class="line">2020-01-02 14:17:45.066  INFO 10076 --- [           main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2020-01-02 14:17:45.122  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Disable delta property : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : false</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : true</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: true</span><br><span class="line">2020-01-02 14:17:45.123  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br><span class="line">2020-01-02 14:17:45.316  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : The response status is 200</span><br><span class="line">2020-01-02 14:17:45.319  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 10</span><br><span class="line">2020-01-02 14:17:45.322  INFO 10076 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2020-01-02 14:17:45.327  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1577945865325 with initial instances count: 5</span><br><span class="line">2020-01-02 14:17:45.330  INFO 10076 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application APP-SEARCH with eureka with status UP</span><br><span class="line">2020-01-02 14:17:45.330  INFO 10076 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1577945865330, current=UP, previous=STARTING]</span><br><span class="line">2020-01-02 14:17:45.333  INFO 10076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APP-SEARCH/192.168.170.1:8443: registering service...</span><br><span class="line">2020-01-02 14:17:45.375  INFO 10076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APP-SEARCH/192.168.170.1:8443 - registration status: 204</span><br><span class="line">2020-01-02 14:17:45.398  INFO 10076 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8443 (https) 8080 (http) with context path &apos;&apos;</span><br></pre></td></tr></table></figure></p><p>最终日志启动监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-01-02 14:17:45.398  INFO 10076 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8443 (https) 8080 (http) with context path &apos;&apos;</span><br></pre></td></tr></table></figure></p><h3 id="免费证书-失效最多一年"><a href="#免费证书-失效最多一年" class="headerlink" title="免费证书 失效最多一年"></a>免费证书 失效最多一年</h3><p> <a href="https://freessl.cn/" target="_blank" rel="noopener">https://freessl.cn/</a></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/Smile__1/article/details/99848578" target="_blank" rel="noopener">证书生成</a></li><li><a href="https://blog.csdn.net/qq_36699423/article/details/93481187" target="_blank" rel="noopener">SpringBoot配置同时支持http和https</a></li><li><a href="https://segmentfault.com/a/1190000020052375" target="_blank" rel="noopener">SpringBoot支持https</a></li><li><a href="https://juejin.im/post/5efa9c9e6fb9a07e5a1c2705" target="_blank" rel="noopener">证书</a></li></ul>]]></content>
    
    <summary type="html">
    
      https和http，实际上和之前我们配置tomcat 的https一个道理
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>tools-需要开启自启动的应用配置</title>
    <link href="https://muxiaobai.github.io/2019/12/26/tools-%E9%9C%80%E8%A6%81%E5%BC%80%E5%90%AF%E8%87%AA%E5%90%AF%E5%8A%A8%E7%9A%84%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://muxiaobai.github.io/2019/12/26/tools-需要开启自启动的应用配置/</id>
    <published>2019-12-26T06:58:37.000Z</published>
    <updated>2020-12-03T09:24:22.715Z</updated>
    
    <content type="html"><![CDATA[<p><code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>每个人对应的目录可能不一致，<br>可以用 win +r  <code>shell:startup</code><br>把需要启动的bat文件创建快捷方式，到此文件夹下<br><img src="/2019/12/26/tools-需要开启自启动的应用配置/自启动目录.png" alt="自启动目录"></p><p>或者开机启动脚本</p><p>win+r  gpedit.msc</p><p>用户配置—-&gt; Windows设置—-&gt;脚本（登陆/注销）—-&gt; 登陆—-&gt;添加—-&gt;start.bat</p><p>一开机就启动必须的应用 IDEA VS Code  Chrome CloudMusic,自己写的脚本必须启动的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">echo start </span><br><span class="line"></span><br><span class="line">echo idea START</span><br><span class="line">start /d &quot;E:\Program Files\JetBrains\IntelliJ IDEA 2019.1.2\bin&quot; idea64.exe</span><br><span class="line"></span><br><span class="line">echo VS CODE START</span><br><span class="line">start /d &quot;E:\tools\Microsoft VS Code&quot; code.exe</span><br><span class="line"></span><br><span class="line">echo sublime START</span><br><span class="line">start /d &quot;E:\Program Files\Sublime Text 3&quot; sublime_text.exe</span><br><span class="line"></span><br><span class="line">echo Chrome START</span><br><span class="line">start /d &quot;C:\Program Files (x86)\Google\Chrome\Application&quot; chrome.exe</span><br><span class="line"></span><br><span class="line">echo cloudmusic START</span><br><span class="line">start /d &quot;E:\Program Files (x86)\Netease\CloudMusic&quot; cloudmusic.exe</span><br><span class="line"></span><br><span class="line">echo javaw START</span><br><span class="line">start /d  &quot;E:\workspace\idea\app-cloud\&quot; taskrunjavaw.bat</span><br><span class="line"></span><br><span class="line">echo nginx START</span><br><span class="line">start /d  &quot;E:\tools\nginx-1.14.2\&quot; nginx.exe  -c conf/nginx.conf</span><br><span class="line"></span><br><span class="line">echo dbeaver START</span><br><span class="line">start /d  &quot;E:\tools\dbeaver-ce-7.0.4-win32.win32.x86_64\dbeaver&quot; dbeaver.exe</span><br><span class="line"></span><br><span class="line">echo vmware START</span><br><span class="line">&quot;E:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe&quot; start &quot;E:\Users\Administrator\Documents\Virtual Machines\CentOS-192.168.160.75\CentOS-192.168.160.75.vmx&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem start /d &quot;E:\Program Files (x86)\VMware\VMware Workstation&quot;  vmware.exe</span><br><span class="line">rem &quot;E:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe&quot; stop &quot;E:\Users\Administrator\Documents\Virtual Machines\CentOS-192.168.160.75\CentOS-192.168.160.75.vmx&quot;</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>切换到对应目录然后执行exe</p><p>taskrunjavaw.bat 中是需要启动的平台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">start javaw -jar ./app-core/app-register/target/app-register-0.0.1.jar   &amp;</span><br><span class="line">ping -n 8 127.0.0.1 1&gt;null</span><br><span class="line">rem 等待8秒</span><br><span class="line">echo &quot;app-register&quot;</span><br><span class="line">start javaw -jar ./app-core/app-config/target/app-config-0.0.1.jar &amp;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p><p>对于一些不经常变动的，定式启动内容可以如此处理。</p>]]></content>
    
    <summary type="html">
    
      每一次开机都要开启很多软件，在这里就找到解决办法，晚上可以关机，早上可以开机，然后就可以去接开水喝了，静待启动。
    
    </summary>
    
      <category term="工具" scheme="https://muxiaobai.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>devops之jenkins持续集成</title>
    <link href="https://muxiaobai.github.io/2019/12/21/devops%E4%B9%8Bjenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://muxiaobai.github.io/2019/12/21/devops之jenkins持续集成/</id>
    <published>2019-12-21T05:28:29.000Z</published>
    <updated>2019-12-23T05:12:50.045Z</updated>
    
    <content type="html"><![CDATA[<p>分两步走，第一安装，第二配置</p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000 /root/jenkins_home</span><br><span class="line">chmod 777 /var/run/docker.sock</span><br></pre></td></tr></table></figure><h2 id="docker-创建jenkins工具持续集成"><a href="#docker-创建jenkins工具持续集成" class="headerlink" title="docker 创建jenkins工具持续集成"></a>docker 创建jenkins工具持续集成</h2><p>拉取镜像 <code>docker pulljenkins/jenkins</code></p><p>8080映射到16000 5000映射到16001端口<br>创建容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name jenkins -p 16000:8080 -p 16001:50000 \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v $(which docker):/bin/docker \</span><br><span class="line">    -v /root/jenkins_home:/var/jenkins_home \</span><br><span class="line">    -d jenkins/jenkins</span><br></pre></td></tr></table></figure><ul><li>/root/jenkins_home 为jenkins工作空间，包括插件maven，git工具等</li><li>需要在shell中使用宿主机的docker命令</li></ul><p>删除容器：<code>docker rm -f jenkins</code></p><p>下面的创建，添加了本地执行shell挂载卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -d -p 16000:8080 -p 16001:50000 \</span><br><span class="line">    -v /opt/demo/:/opt/demo \</span><br><span class="line">    -v /root/jenkins_home/:/var/jenkins_home \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v $(which docker):/usr/bin/docker \</span><br><span class="line">    -v $(which git):/usr/bin/git \</span><br><span class="line">    -v ~/.ssh:/var/jenkins_home/.ssh \</span><br><span class="line">    --name=jenkins jenkins/jenkins</span><br></pre></td></tr></table></figure><p>挂载：其中/opt/demo 为命令执行空间</p><p>访问 <a href="http://ip:16000" target="_blank" rel="noopener">http://ip:16000</a></p><p>以上 安装完成</p><p>参考<a href="https://www.cnblogs.com/stulzq/p/8627360.html" target="_blank" rel="noopener">jenkins安装</a></p><h2 id="构建集成配置"><a href="#构建集成配置" class="headerlink" title="构建集成配置"></a>构建集成配置</h2><p>需要以下工具     </p><ul><li>Git plugin 源码地址</li><li>Maven Integration plugin   构建工具</li><li>Publish Over SSH 远程发布</li></ul><p><code>/root/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation</code>在这个文件夹下会有maven工具支持构建</p><p>新建项目选择maven,需要安装maven 工具<br><img src="/2019/12/21/devops之jenkins持续集成/pom.png" alt="maven"></p><h3 id="配置源码仓库"><a href="#配置源码仓库" class="headerlink" title="配置源码仓库"></a>配置源码仓库</h3><p>配置git地址，分支<code>refs/heads/dev</code></p><p><img src="/2019/12/21/devops之jenkins持续集成/gitsource.png" alt="源码配置"></p><h3 id="配置触发器"><a href="#配置触发器" class="headerlink" title="配置触发器"></a>配置触发器</h3><h4 id="github-hook"><a href="#github-hook" class="headerlink" title="github hook"></a>github hook</h4><p><img src="/2019/12/21/devops之jenkins持续集成/githubhook.png" alt="github hook"><br>只用把github勾选<br><img src="/2019/12/21/devops之jenkins持续集成/配置触发器.png" alt="配置触发器"></p><h4 id="gitlab配置"><a href="#gitlab配置" class="headerlink" title="gitlab配置"></a>gitlab配置</h4><p>Accepted Merge Requests Events 接受合并分支时，触发<br><img src="/2019/12/21/devops之jenkins持续集成/webhook.png" alt="配置jenkins合并触发"><br>出现<code>Url is blocked: Requests to the local network are not allowed</code> 问题，需要在系统管理员处配置：<br><img src="/2019/12/21/devops之jenkins持续集成/gitlab配置1.png" alt="配置gitlabwebhook"><br>合并分支时候调用hook地址<br><img src="/2019/12/21/devops之jenkins持续集成/gitlab配置2.png" alt="配置gitlab"></p><h3 id="配置-Build"><a href="#配置-Build" class="headerlink" title="配置 Build"></a>配置 Build</h3><p>pom.xml<br>clean package<br><img src="/2019/12/21/devops之jenkins持续集成/bulid.png" alt="build"></p><h3 id="配置Post-Steps"><a href="#配置Post-Steps" class="headerlink" title="配置Post Steps"></a>配置Post Steps</h3><h4 id="本机发布执行shell"><a href="#本机发布执行shell" class="headerlink" title="本机发布执行shell"></a>本机发布执行shell</h4><p>shell脚本</p><p><img src="/2019/12/21/devops之jenkins持续集成/shell.png" alt="本地shell"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">WORK_DIR=/opt/demo/package</span><br><span class="line">PROJECT_NAME=app-demo</span><br><span class="line">PROJECT_VERSION=0.0.1</span><br><span class="line">echo `pwd`</span><br><span class="line">docker ps -a </span><br><span class="line">#  判断工作目录是否存在</span><br><span class="line">if [ ! -e $&#123;WORK_DIR&#125; ] &amp;&amp; [ ! -d $&#123;WORK_DIR&#125; ]; then</span><br><span class="line">    mkdir -p $&#123;WORK_DIR&#125;</span><br><span class="line">    echo &quot;Create Dir: $&#123;WORK_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Dockerfile存在 删除</span><br><span class="line">if [ -e $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile ]; then</span><br><span class="line">    rm -rf $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile</span><br><span class="line">    echo &quot;Remove File: $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/Dockerfile&quot;</span><br><span class="line">fi</span><br><span class="line"># 如果容器已经启动，移除</span><br><span class="line">if docker ps -a | grep $&#123;PROJECT_NAME&#125;; then</span><br><span class="line">    docker rm -f $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;</span><br><span class="line">    docker rmi -f $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;</span><br><span class="line">    echo &quot;Remove Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 拷贝jar包到工作目录 jar是通过maven pom.xml 生成的</span><br><span class="line">cp ./target/*.jar $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/ </span><br><span class="line"># 拷贝Dockerfile到工作目录 是提前编写在git项目内</span><br><span class="line">cp ./Dockerfile $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/</span><br><span class="line"></span><br><span class="line"># 开始构建镜像</span><br><span class="line"># 进入工作目录</span><br><span class="line">cd $&#123;WORK_DIR&#125;/$&#123;PROJECT_NAME&#125;/</span><br><span class="line"># 构建镜像 在个工作目录，依据当前目录创建镜像</span><br><span class="line"># docker build -t $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125; .</span><br><span class="line"># 推送镜像</span><br><span class="line"># docker push $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125;</span><br><span class="line"></span><br><span class="line">#  启动容器</span><br><span class="line"># docker run -d -p 18000:8761 --name $&#123;PROJECT_NAME&#125; $&#123;PROJECT_NAME&#125;:$&#123;PROJECT_VERSION&#125;</span><br><span class="line"></span><br><span class="line">#dockerstart.sh 为便捷构建容器启动容器脚本</span><br><span class="line">#cd $&#123;WORK_DIR&#125;</span><br><span class="line">#sh ../shell/dockerstart.sh $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; /opt/demo/package/ 18000</span><br><span class="line"></span><br><span class="line">#判断容器启动成功</span><br><span class="line">if docker ps  | grep $&#123;PROJECT_NAME&#125;; then</span><br><span class="line">    echo &quot;Start Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; Success&quot;</span><br><span class="line">else </span><br><span class="line">    echo &quot;Start Docker Container: $&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125; Error&quot;</span><br><span class="line">    return 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="远程发布SSH-Publishers"><a href="#远程发布SSH-Publishers" class="headerlink" title="远程发布SSH Publishers"></a>远程发布SSH Publishers</h4><p>配置插件如果要进行远程发布，需要插件</p><p>先在系统全局配置中配置以下ssh<br><img src="/2019/12/21/devops之jenkins持续集成/配置ssh.png" alt="配置"><br><img src="/2019/12/21/devops之jenkins持续集成/SSHpublisher.png" alt="远程发布"></p><p><a href="https://blog.csdn.net/Denny2333/article/details/88037413" target="_blank" rel="noopener">配置构建项目</a></p>]]></content>
    
    <summary type="html">
    
      通过docker安装jenkins，发布springboot项目
    
    </summary>
    
      <category term="devops" scheme="https://muxiaobai.github.io/categories/devops/"/>
    
    
      <category term="devops" scheme="https://muxiaobai.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之AQS和应用</title>
    <link href="https://muxiaobai.github.io/2019/10/31/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8BAQS%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <id>https://muxiaobai.github.io/2019/10/31/Thinking-in-java-基础之AQS和应用/</id>
    <published>2019-10-31T05:12:44.000Z</published>
    <updated>2019-11-07T01:48:20.595Z</updated>
    
    <content type="html"><![CDATA[<p>使用锁的时候我们直接<code>ReentrantLock lock = new ReentrantLock();lock.lock();</code>,这中间究竟有什么内容,<br>lock的时候，其它线程为什么不能执行，unlook()的时候其它的线程究竟从哪个线程能执行？本文主要分析lock的各种情况。</p><h2 id="j-u-c-locks-AbstractQueuedSynchronizer"><a href="#j-u-c-locks-AbstractQueuedSynchronizer" class="headerlink" title="j.u.c.locks.AbstractQueuedSynchronizer"></a>j.u.c.locks.AbstractQueuedSynchronizer</h2><p>有共享和独占两种状态，SHARE，EXCLUSIVE 这两个在AQS中对应两个Node节点{state:1,thread:Thread.CurrentThread()},节点里面的内容。<br>从名字里面就能知道，共享锁，每一个线程来都可以拿到锁，简单的来说，就是可以运行lock和unlock内的代码，独占锁，一个线程lock，其它线程必须等到unlock之后，再去抢占锁。</p><blockquote><p>排队接水喝，我的杯子放在这里，当前这个饮水机就我能用。其它人来了，不好意思，排队。</p></blockquote><p>至于怎么抢占，又分为公平锁，和非公平锁，公平锁：先来后到，非公平：随机获取。</p><blockquote><p>排队接水喝， 先后顺序，公平，来了个领导，他先接水，不公平，但合理。</p></blockquote><p>AbstractOwnableSynchronizer</p><p><img src="/2019/10/31/Thinking-in-java-基础之AQS和应用/state.png" alt="图"><br>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p><p>资源state使用volatile标识，保证所有的线程来的时候都是确定的值。详细查看<a href>volatile</a>，其它线程在队列里。</p><p>protected boolean tryAcquire(int arg) : 独占式获取同步状态，试着获取，成功返回true，反之为false<br>protected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；<br>protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；<br>protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为false<br>protected boolean isHeldExclusively() ： 是否在独占模式下被线程占用。</p><h2 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch 倒计时器"></a>CountDownLatch 倒计时器</h2><p>它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行</p><p>CountDownLatch，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h2><p>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. (CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源,可以指定多个线程同时访问某个资源</p><h2 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock 重入锁"></a>ReentrantLock 重入锁</h2><blockquote><p>排队接水喝，水杯太大，杯子放着接，我先干别的事，干完了回来，直接就能拿杯子，重入。</p></blockquote><p>ReentrantLock，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><h2 id="tomcat的-LimitLatch"><a href="#tomcat的-LimitLatch" class="headerlink" title="tomcat的 LimitLatch"></a>tomcat的 LimitLatch</h2><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">Java并发包基石-AQS详解</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md#41-countdownlatch-%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">JavaGuide</a></li></ul>]]></content>
    
    <summary type="html">
    
      jdk的juc中的AQS和应用，各种锁的比较
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
      <category term="Thread" scheme="https://muxiaobai.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之类加载顺序&amp;初始化</title>
    <link href="https://muxiaobai.github.io/2019/10/21/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://muxiaobai.github.io/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/</id>
    <published>2019-10-21T07:25:42.000Z</published>
    <updated>2019-10-22T02:06:04.356Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先来一个题"><a href="#先来一个题" class="headerlink" title="先来一个题"></a>先来一个题</h4><p>FatherClass:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class FatherClass &#123;</span><br><span class="line">    public  static  int F_NUM = 1111;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    FatherClass()&#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">        F_NUM = 5555;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SonClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SonClass  extends  FatherClass&#123;</span><br><span class="line">    public  static  int S_NUM = 2222;</span><br><span class="line">    static &#123;</span><br><span class="line">        F_NUM = 3333;</span><br><span class="line">        System.out.println(S_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        S_NUM = 4444;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里是一个大坑，没有无参的构造方法，所以newInstance的时候会报错</span><br><span class="line">    SonClass(int inNUM)&#123;</span><br><span class="line">        System.out.println(F_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LoaderOrder &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">//        testClassLoad();</span><br><span class="line">        testClassForName();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void testClassLoad() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class clazz =LoaderOrder.class.getClassLoader().loadClass(&quot;io.github.muxiaobai.spring_my_demo.loadClass.SonClass&quot;);</span><br><span class="line">        System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">        System.out.println(&quot;===========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void testClassForName() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class clazz =Class.forName(&quot;io.github.muxiaobai.spring_my_demo.loadClass.SonClass&quot;);</span><br><span class="line">        System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">        System.out.println(&quot;===========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ClassLoad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InstantiationException: io.github.muxiaobai.spring_my_demo.loadClass.SonClass</span><br><span class="line">at java.lang.Class.newInstance(Class.java:427)</span><br></pre></td></tr></table></figure></p><p>使用Class.forName();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">---------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InstantiationException: io.github.muxiaobai.spring_my_demo.loadClass.SonClass</span><br></pre></td></tr></table></figure><p>链接：static成员变量，附初始值。0,null,false,</p><p>初始化做了那些事情？显性的：static语句块，执行到实例化的时候没有无参的构造函数，因此父类和子类都没有实例化。</p><p>没有完成类的初始化，无法访问类成员</p><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/Class初始化.png" alt="初始化"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="java对象，获取"><a href="#java对象，获取" class="headerlink" title="java对象，获取"></a>java对象，获取</h5><ul><li>new </li><li>反射</li><li>反序列化</li><li>克隆</li></ul><h5 id="Class对象获取"><a href="#Class对象获取" class="headerlink" title="Class对象获取"></a>Class对象获取</h5><ul><li>类名.class</li><li>实例.getClass()</li><li>classloader.loadClass(“包.类”)</li><li>Class.forName(“包.类”);</li></ul><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/获取Class四种方式.PNG" alt="初始化"></p><p>jvm加载步骤：加载——链接（验证，准备，解析）———–初始化</p><p><img src="/2019/10/21/Thinking-in-java-基础之类加载顺序-初始化/Class初始化时机.png" alt="初始化"></p><p>两种，实际上是识别到字节码指令:new，putstatic,getstatic,invokestatic,<br>反射</p><p>根据Java虚拟机的规范，只有5中情况属于主动引用：</p><ul><li><p>遇到new（使用new 关键字实例化一个对象）、getstatic（读取一个类的静态字段）、putstatic或者invokestatic（设置一个类的静态字段）这4条指令的时候，如果累没有进行过初始化。则需要先触发其初始化。</p></li><li><p>使用反射进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果其父类没有初始化，则需要先触发其父类的初始化</p></li><li><p>程序启动需要触发main方法的时候，虚拟机会先触发这个类的初始化</p></li><li><p>当使用jdk1.7的动态语言支持的时候，如果一个java.lang.invoke.MethodHandler实例最后的解析结果为REF_getStatic、REF_pusStatic、REF_invokeStatic的方法句柄（句柄中包含了对象的实例数据和类型数据，句柄是访问对象的一种方法。句柄存储在堆中），并且句柄对应的类没有被初始化，那么需要先触发这个类的初始化。</p></li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><a href="https://www.cnblogs.com/shyroke/p/9161603.html" target="_blank" rel="noopener">类加载机制和类的加载、连接（验证、准备、解析）和初始化</a></li></ul>]]></content>
    
    <summary type="html">
    
      类加载过程
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 基础之HashMap</title>
    <link href="https://muxiaobai.github.io/2019/10/17/Thinking-in-java-%E5%9F%BA%E7%A1%80%E4%B9%8BHashMap/"/>
    <id>https://muxiaobai.github.io/2019/10/17/Thinking-in-java-基础之HashMap/</id>
    <published>2019-10-17T13:13:12.000Z</published>
    <updated>2019-10-18T06:08:58.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的put引发的惨案"><a href="#一个简单的put引发的惨案" class="headerlink" title="一个简单的put引发的惨案"></a>一个简单的put引发的惨案</h2><pre><code>版本 jdk1.8Map hashMap = new HashMap&lt;String,String&gt;();hashMap.put(&quot;abc&quot;,&quot;1&quot;);一个简单的put</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Associates the specified value with the specified key in this map.</span><br><span class="line"> * If the map previously contained a mapping for the key, the old</span><br><span class="line"> * value is replaced.</span><br><span class="line"> *</span><br><span class="line"> * @param key key with which the specified value is to be associated</span><br><span class="line"> * @param value value to be associated with the specified key</span><br><span class="line"> * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="line"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><br><span class="line"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><br><span class="line"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><br><span class="line"> */</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="怎么进行hash"><a href="#怎么进行hash" class="headerlink" title="怎么进行hash"></a>怎么进行hash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Computes key.hashCode() and spreads (XORs) higher bits of hash</span><br><span class="line">    * to lower.  Because the table uses power-of-two masking, sets of</span><br><span class="line">    * hashes that vary only in bits above the current mask will</span><br><span class="line">    * always collide. (Among known examples are sets of Float keys</span><br><span class="line">    * holding consecutive whole numbers in small tables.)  So we</span><br><span class="line">    * apply a transform that spreads the impact of higher bits</span><br><span class="line">    * downward. There is a tradeoff between speed, utility, and</span><br><span class="line">    * quality of bit-spreading. Because many common sets of hashes</span><br><span class="line">    * are already reasonably distributed (so don&apos;t benefit from</span><br><span class="line">    * spreading), and because we use trees to handle large sets of</span><br><span class="line">    * collisions in bins, we just XOR some shifted bits in the</span><br><span class="line">    * cheapest possible way to reduce systematic lossage, as well as</span><br><span class="line">    * to incorporate impact of the highest bits that would otherwise</span><br><span class="line">    * never be used in index calculations because of table bounds.</span><br><span class="line">    */</span><br><span class="line">   static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>key可以为null ，返回0，直接落在第一个坑位上。</p><blockquote><p>解释了key可以为null<br>Object.hashCode();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure></p></blockquote><p>以String举例<br>String.hashCode();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns a hash code for this string. The hash code for a</span><br><span class="line">    * &#123;@code String&#125; object is computed as</span><br><span class="line">    * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">    * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br><span class="line">    * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">    * using &#123;@code int&#125; arithmetic, where &#123;@code s[i]&#125; is the</span><br><span class="line">    * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;@code n&#125; is the length of</span><br><span class="line">    * the string, and &#123;@code ^&#125; indicates exponentiation.</span><br><span class="line">    * (The hash value of the empty string is zero.)</span><br><span class="line">    *</span><br><span class="line">    * @return  a hash code value for this object.</span><br><span class="line">    */</span><br><span class="line">   public int hashCode() &#123;</span><br><span class="line">       int h = hash;</span><br><span class="line">       if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">           char val[] = value;</span><br><span class="line"></span><br><span class="line">           for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">               h = 31 * h + val[i];</span><br><span class="line">           &#125;</span><br><span class="line">           hash = h;</span><br><span class="line">       &#125;</span><br><span class="line">       return h;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;abc&quot;.hashCode());//96354</span><br><span class="line">System.out.println(97*31*31 + 98*31+99);//96354</span><br></pre></td></tr></table></figure></p><blockquote><p>s[0]<em>31^(n-1) + s[1]</em>31^(n-2) + … + s[n-1]</p></blockquote><p>String的hash算法,那么HashMap中的hash(),<br><code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code><br>“abc”进行转hashCode()之后就是96354，然后变成二进制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h&gt;&gt;&gt;16   h^(h&gt;&gt;&gt;16)</span><br><span class="line">那么就是（前面补0）</span><br><span class="line">96354       0000 0000 0000 0001 0111 1000 0110 0010  低16位</span><br><span class="line">h&gt;&gt;&gt;16      0000 0000 0000 0000 0000 0000 0000 0001  高16位</span><br><span class="line">^--------------------------------------------------</span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011  </span><br><span class="line"></span><br><span class="line">最终得到96355</span><br></pre></td></tr></table></figure></p><p>高16位与低16位</p><p>结果验证<br><img src="/2019/10/17/Thinking-in-java-基础之HashMap/hash.png" alt="hash运行时"></p><p>然后下一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Implements Map.put and related methods</span><br><span class="line">     *</span><br><span class="line">     * @param hash hash for key</span><br><span class="line">     * @param key the key</span><br><span class="line">     * @param value the value to put</span><br><span class="line">     * @param onlyIfAbsent if true, don&apos;t change existing value</span><br><span class="line">     * @param evict if false, the table is in creation mode.</span><br><span class="line">     * @return previous value, or null if none</span><br><span class="line">     */</span><br><span class="line">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="没有数组"><a href="#没有数组" class="headerlink" title="没有数组"></a>没有数组</h4><p>看内部的如果table是空的创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">           n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></p><p>resize()把table创建好了，同时把tab.length赋给n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Initializes or doubles table size.  If null, allocates in</span><br><span class="line">   * accord with initial capacity target held in field threshold.</span><br><span class="line">   * Otherwise, because we are using power-of-two expansion, the</span><br><span class="line">   * elements from each bin must either stay at same index, or move</span><br><span class="line">   * with a power of two offset in the new table.</span><br><span class="line">   *</span><br><span class="line">   * @return the table</span><br><span class="line">   */</span><br><span class="line">  final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int oldThr = threshold;</span><br><span class="line">      int newCap, newThr = 0;</span><br><span class="line">      if (oldCap &gt; 0) &#123;</span><br><span class="line">          if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              return oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">      &#125;</span><br><span class="line">      else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      else &#123;               // zero initial threshold signifies using defaults 这里是初始化的时候，放容量Cap=16和最多放几个开始扩容负载因子Thr = 0.75*16 = 12，</span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (newThr == 0) &#123;</span><br><span class="line">          float ft = (float)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">      //创建一个newCap容量大小的数组，然后赋给table</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      //以下内容为把原来的Node放到新的Node中，先放一下，后面在扩容判定位置的时候再研究</span><br><span class="line">      if (oldTab != null) &#123;</span><br><span class="line">          ...</span><br><span class="line">          ...</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      return newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>先看新建的，不看扩容的。知道table是个newCap大小的数组</p><p><img src="/2019/10/17/Thinking-in-java-基础之HashMap/resize.png" alt="hash运行时"></p><h4 id="数组对应的位置为空"><a href="#数组对应的位置为空" class="headerlink" title="数组对应的位置为空"></a>数组对应的位置为空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">           tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure><p>有了数组，怎么计算放在哪一个数组上，<code>(n - 1) &amp; hash]</code>,这个位置上如果为空，那么tab的i上就放当前的Node&lt;K,V&gt;;当前的n就是tab.length = 16<br>算一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">刚才abc的hash值是96355</span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011   96355</span><br><span class="line">16-1        0000 0000 0000 0000 0000 0000 0000 1111   15</span><br><span class="line">&amp;-------------------------------------------------- 保证所有的值都落在tab之内</span><br><span class="line">(n-1)hash   0000 0000 0000 0000 0000 0000 0000 0011   3</span><br><span class="line"></span><br><span class="line">然后看tab[3]上是否为null,为空直接赋值在这里</span><br><span class="line">然后tab[3] =  Node&lt;&gt;(hash, key, value, next);//Node&lt;&gt;(96355，&quot;abc&quot;,&quot;1&quot;,null)</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/17/Thinking-in-java-基础之HashMap/tab[i].png" alt="hash运行时"></p><h4 id="数组对应的位置不为空，跟链表，超过TREEIFY-THRESHOLD时，当前hash对应的位置转为treeifyBin"><a href="#数组对应的位置不为空，跟链表，超过TREEIFY-THRESHOLD时，当前hash对应的位置转为treeifyBin" class="headerlink" title="数组对应的位置不为空，跟链表，超过TREEIFY_THRESHOLD时，当前hash对应的位置转为treeifyBin"></a>数组对应的位置不为空，跟链表，超过TREEIFY_THRESHOLD时，当前hash对应的位置转为treeifyBin</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line">if (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure><p>判断key是不是一样的，如果是一样的，直接替换前面的Node，</p><blockquote><p>解释了 为什么key可以为null，但key一样的话不能重复</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    //没有条件的一直循环，在内部break，</span><br><span class="line">    for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        if ((e = p.next) == null) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, null);</span><br><span class="line">            //当前容量大于8-1 = 7 的时候进行转为红黑树</span><br><span class="line">            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            break;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前hash对应的位置转TreeNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="line">     * table is too small, in which case resizes instead.</span><br><span class="line">     */</span><br><span class="line">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        //如果tab数组小于MIN_TREEIFY_CAPACITY=64重新调整大小</span><br><span class="line">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">                if (tl == null)</span><br><span class="line">                    hd = p;</span><br><span class="line">                else &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">            if ((tab[index] = hd) != null)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="数组对应的位置不为空，跟红黑树"><a href="#数组对应的位置不为空，跟红黑树" class="headerlink" title="数组对应的位置不为空，跟红黑树"></a>数组对应的位置不为空，跟红黑树</h4><p>直接调用TreeNode的putTreeVal()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></pre></td></tr></table></figure></p><p>里面对应的旋转啊，啥子的，一堆。</p><h4 id="超过最大值，要进行扩容"><a href="#超过最大值，要进行扩容" class="headerlink" title="超过最大值，要进行扩容"></a>超过最大值，要进行扩容</h4><p>当大小超过threshold=DEFAULT_LOAD_FACTOR <em> DEFAULT_INITIAL_CAPACITY= 0.75</em>16=12重新resize()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br></pre></td></tr></table></figure></p><p>resize(),扩容的时候MAXIMUM_CAPACITY=1&lt;&lt;30<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    threshold = Integer.MAX_VALUE;//最大值</span><br><span class="line">    return oldTab;</span><br><span class="line">&#125;</span><br><span class="line">//不到最大值，新的容量newCap为原来的左移一位 oldThr&lt;&lt;1, 两倍的容量</span><br><span class="line">else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">            oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    //newThr 为12&lt;&lt;1 为 24</span><br></pre></td></tr></table></figure></p><h4 id="扩容怎么判定原来的位置，怎么移动"><a href="#扩容怎么判定原来的位置，怎么移动" class="headerlink" title="扩容怎么判定原来的位置，怎么移动"></a>扩容怎么判定原来的位置，怎么移动</h4><p>上面扩容省略的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">            oldTab[j] = null;</span><br><span class="line">            //没有next 说明只有一个Node直接在table数组中直接移动</span><br><span class="line">            if (e.next == null)</span><br><span class="line">                newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">            //是树的情况</span><br><span class="line">            else if (e instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">            else &#123; // preserve order 顺序的模式链表</span><br><span class="line">                Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                do &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    //hash与oldCap容量如果等于0 则还在原来的坑位，</span><br><span class="line">                    if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                        if (loTail == null)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        else</span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //在新的坑位</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (hiTail == null)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        else</span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while ((e = next) != null);</span><br><span class="line">                if (loTail != null) &#123;</span><br><span class="line">                    loTail.next = null;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                if (hiTail != null) &#123;</span><br><span class="line">                    hiTail.next = null;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</code>中有一段，当小于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">    tab[index] = loHead.untreeify(map);</span><br><span class="line">else &#123;</span><br><span class="line">    tab[index] = loHead;</span><br><span class="line">    if (hiHead != null) // (else is already treeified)</span><br><span class="line">        loHead.treeify(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经把原来各个节点Node移动到新的数组中，当小于UNTREEIFY_THRESHOLD=6时，转为链表</p><p>链表的情况<code>(e.hash &amp; oldCap) == 0</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">刚才abc的hash值是96355</span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011   96355</span><br><span class="line">16=oldCap   0000 0000 0000 0000 0000 0000 0001 0000   16</span><br><span class="line">&amp;-------------------------------------------------- 保证所有的值都落在tab之内</span><br><span class="line">hash&amp;oldCap 0000 0000 0000 0000 0000 0000 0000 0000   0</span><br><span class="line"></span><br><span class="line">等于0 还在原来的位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h^(h&gt;&gt;&gt;16)  0000 0000 0000 0001 0111 1000 0110 0011</span><br><span class="line">16扩32      0000 0000 0000 0000 0000 0000 0001 1111</span><br><span class="line">&amp;-------------------------------------------------- 保证所有的值都落在tab之内</span><br><span class="line">hash&amp;oldCap 0000 0000 0000 0000 0000 0000 0000 0011   3</span><br><span class="line"></span><br><span class="line">如果不是0的话则在 16+3的位置</span><br></pre></td></tr></table></figure></p><p>线程不安全</p><h4 id="ConCurrentHashMap是怎么加锁的"><a href="#ConCurrentHashMap是怎么加锁的" class="headerlink" title="ConCurrentHashMap是怎么加锁的"></a>ConCurrentHashMap是怎么加锁的</h4><p>ConcurrentHashMap 中的key和value都不能为空，会抛出NullPointerException<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">           //初始化要考虑多线程</span><br><span class="line">               tab = initTable();</span><br><span class="line">               //tabAt,getObjectVolatile native线程安全</span><br><span class="line">           else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">               //使用cas，为空的时候U.compareAndSwapObject,比较交换，使用native 线程安全</span><br><span class="line">               if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                   break;                   // no lock when adding to empty bin</span><br><span class="line">           &#125;</span><br><span class="line">           else if ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           else &#123;</span><br><span class="line">               V oldVal = null;</span><br><span class="line">               //直接锁数组上的Node</span><br><span class="line">               //put数据的时候，在同一个数组下标下，锁，保证安全</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      ...</span><br><span class="line">                      ...</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (binCount != 0) &#123;</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   if (oldVal != null)</span><br><span class="line">                       return oldVal;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //扩容要考虑其它线程</span><br><span class="line">       addCount(1L, binCount);</span><br><span class="line">       return null;</span><br></pre></td></tr></table></figure></p><h4 id="对比HashTable直接在方法上进行加锁，锁this"><a href="#对比HashTable直接在方法上进行加锁，锁this" class="headerlink" title="对比HashTable直接在方法上进行加锁，锁this"></a>对比HashTable直接在方法上进行加锁，锁this</h4><p>Hashtable上的put<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null 不能为空</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">        // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();//不能为空</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br></pre></td></tr></table></figure></p><blockquote><p>Hashtable中的value不能为空，抛出异常NullPointerException；key不能为空，因为null不能获取hashcode();</p></blockquote><p>这种特性，在分析源码的时候就直接出来的，不用背的，不用背的。</p>]]></content>
    
    <summary type="html">
    
      从map.put()说起，所有的相关内容
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Thinking in java 高级之volatile</title>
    <link href="https://muxiaobai.github.io/2019/10/12/Thinking-in-java-%E9%AB%98%E7%BA%A7%E4%B9%8Bvolatile/"/>
    <id>https://muxiaobai.github.io/2019/10/12/Thinking-in-java-高级之volatile/</id>
    <published>2019-10-12T02:41:58.000Z</published>
    <updated>2020-05-26T06:46:46.556Z</updated>
    
    <content type="html"><![CDATA[<p>显性的作用就是： 这个变量在修改之后，可以及时更新到另外一个线程。</p><h3 id="两个代码"><a href="#两个代码" class="headerlink" title="两个代码"></a>两个代码</h3><p>无volatile<br><img src="/2019/10/12/Thinking-in-java-高级之volatile/1.png" alt="无volatile"></p><p>有volatile<br><img src="/2019/10/12/Thinking-in-java-高级之volatile/2.png" alt="有volatile"></p><p>看一下汇编是啥样子的</p><p><a href="https://sourceforge.net/projects/fcml/files/fcml-1.1.1/hsdis-1.1.1-win32-amd64.zip/download" target="_blank" rel="noopener">下载</a><br>hsdis-1.1.1-win32-amd64.zip放到${JAVA_HOME}\jdk1.8.0_171\jre\bin\server下,先<code>javac xxx.java</code> 编译成xxx.class<br><code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly  xxx.class &gt;a.txt</code><br>生成汇编文件</p><p><code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -version</code> 测试是否安装成功<br>给jvm添加参数<br><code>-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*Test.getInstance</code></p><p><img src="/2019/10/12/Thinking-in-java-高级之volatile/3.png" alt="汇编"></p><p>在修改有volatile修饰的属性，加有lock add第八行。这个有lock 会刷新缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static volatile boolean stop = false ;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(()-&gt;&#123;</span><br><span class="line">            int i=0;</span><br><span class="line">            while (!stop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(&quot;begin start thread&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p><img src="/2019/10/12/Thinking-in-java-高级之volatile/L0.png" alt="CPU三级缓存架构图"></p><p>因为CPU高速运转，直接读内存会很慢，又开辟一级二级三级缓存，多核CPU下每一个有独立的一级二级缓存；如果现在来了一个数据存在三级缓存中，第一个Thread读取之后，并修改了值，但没有同步到三级缓存中；这时候第二个线程要读值，他还是只从三级缓存中读取内容，；但有了内存屏障，在第三个读的时候，</p><p>volatile 会触发lock add ,触发刷新屏障，Cache</p><p>从.java———–&gt;.class编译完成，然后.class 在不同的平台上，对于volatile来说，JVM有不同的实现，一次编写，到处运行<code>Write once, run anywhere</code>,JVM屏蔽各种架构的指令集，例如x86 MMX，SSE等，在window系统上使用window指令，在linux上使用linux指令，最终Java实现了，程序员不用关系各个平台的差异。<br>但对于.net ，需要安装其他的中间件等，才能在非window系统运行。</p><p><img src="/2019/10/12/Thinking-in-java-高级之volatile/CPU.PNG" alt="总结适配器模式"></p><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p> 锁提供了原子性和可见性</p><p>因为某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。</p><p>而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。</p><p>volatile具有锁的可见性，</p><p>每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写会了，他其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。<br>volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。上面的JMM缓存刷新。</p><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。</p><p>指令重排序（本是为了优化代码，对最终的结果无影响）</p><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;              </span><br><span class="line">boolean flag = false;</span><br><span class="line">i = 1;                //语句1  </span><br><span class="line">flag = true;          //语句2</span><br></pre></td></tr></table></figure></p><p>从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序:"></a>指令重排序:</h2><p>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？靠的是数据依赖性：</p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><p>不管怎么重排序，单线程下的执行结果不能被改变。</p><p>编译器、runtime和处理器都必须遵守as-if-serial语义 ，最终一致。</p><p>volatile使用内存屏障保证最终一致。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。</p><p>内存屏障有两个作用：</p><ul><li>1.阻止屏障两侧的指令重排序；</li><li>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li></ul><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；<br>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。<br>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><p>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</p><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</li></ul><p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p><p><a href="https://mrbird.cc/Java-Memory-model.html#more" target="_blank" rel="noopener">参考Java 内存模型</a><br><a href="https://juejin.im/post/5ea913d35188256d4576d199?utm_source=gold_browser_extension" target="_blank" rel="noopener">volatile</a></p>]]></content>
    
    <summary type="html">
    
      从volatile到内存屏障
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java-常用代码2-future等</title>
    <link href="https://muxiaobai.github.io/2019/09/29/java-%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812-future%E7%AD%89/"/>
    <id>https://muxiaobai.github.io/2019/09/29/java-常用代码2-future等/</id>
    <published>2019-09-29T12:33:32.000Z</published>
    <updated>2019-09-30T05:44:46.600Z</updated>
    
    <content type="html"><![CDATA[<p>远程调用可以合并 10ms执行一次。阻塞队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class DemoMoreService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RemoteServiceCall remoteCall;</span><br><span class="line">    //阻塞队列</span><br><span class="line">    LinkedBlockingQueue&lt;Request&gt; queue = new LinkedBlockingQueue&lt;Request&gt;();</span><br><span class="line">    </span><br><span class="line">    public Map&lt;String, Object&gt; doRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">        </span><br><span class="line">        Request request = new Request();</span><br><span class="line">        request.orderCode = orderCode;</span><br><span class="line">        //jdk1.8</span><br><span class="line">        CompletableFuture&lt;Map&lt;String, Object&gt;&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class="line">        request.future = future;</span><br><span class="line">        //队列中</span><br><span class="line">        queue.add(request);</span><br><span class="line">        return future.get();//阻塞状态</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 定时任务 初始化执行</span><br><span class="line">     * init:(). servlet init方法之前调用这个注解的方法，只会被调用一次</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        //定时任务两个线程数</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService =Executors.newScheduledThreadPool(2);</span><br><span class="line">       </span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">           </span><br><span class="line">            //run</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            if(size == 0)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //弹出Request</span><br><span class="line">            List&lt;Request&gt; requests = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=0; i&lt;size;i++)&#123;</span><br><span class="line">                Request request = queue.poll();//出队列</span><br><span class="line">                requests.add(request);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            System.out.println(&quot;10ms 取到的本地请求数：&quot;+size);</span><br><span class="line">            </span><br><span class="line">            //循环requests分离orderCode和future</span><br><span class="line">            List&lt;String&gt; orderCodes = new ArrayList&lt;&gt;();</span><br><span class="line">            for(Request request :requests)&#123;</span><br><span class="line">                orderCodes.add(request.orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //查询返回结果</span><br><span class="line">            List&lt;Map&lt;String,Object&gt;&gt; responses=remoteCall.getMore(orderCodes);</span><br><span class="line">            System.out.println(responses);</span><br><span class="line">            //分离返回内容</span><br><span class="line">            Map&lt;String,Map&lt;String,Object&gt;&gt;  responseMap = new HashMap&lt;&gt;(); </span><br><span class="line">            for(Map&lt;String,Object&gt; response:responses)&#123;</span><br><span class="line">                String orderCode = response.get(&quot;orderCode&quot;).toString();</span><br><span class="line">                responseMap.put(orderCode, response);</span><br><span class="line">            &#125;</span><br><span class="line">            //结果转发到request</span><br><span class="line">            for(Request request:requests)&#123;</span><br><span class="line">                Map&lt;String, Object&gt; result = responseMap.get(request.orderCode);</span><br><span class="line">                request.future.complete(result);//转发到对应的线程</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;, 0, 10, TimeUnit.MILLISECONDS); //10ms执行</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class Request&#123;</span><br><span class="line">        String orderCode;</span><br><span class="line">        CompletableFuture&lt;Map&lt;String, Object&gt;&gt; future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Project Name:spring-boot</span><br><span class="line"> * File Name:remoteServiceCall.java</span><br><span class="line"> * Package Name:io.github.muxiaobai.spring_boot.remoteService</span><br><span class="line"> * Date:2019年3月22日上午10:37:05</span><br><span class="line"> * Copyright (c) 2019, All Rights Reserved.</span><br><span class="line"> *</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package io.github.muxiaobai.spring_boot.remoteService;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ClassName:remoteServiceCall </span><br><span class="line"> * Function: TODO </span><br><span class="line"> * Reason: TODO </span><br><span class="line"> * Date:     2019年3月22日 上午10:37:05 </span><br><span class="line"> * @author   Mu Xiaobai</span><br><span class="line"> * @version  </span><br><span class="line"> * @since    JDK 1.8 </span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class RemoteServiceCall &#123;</span><br><span class="line">    public Map&lt;String,Object&gt; getOne(String orderCode)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        map.put(&quot;orderCode&quot;, orderCode);</span><br><span class="line">        map.put(&quot;hello&quot;, &quot;hello&quot;);</span><br><span class="line">        return map ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public Map&lt;String,Object&gt; getTwo(String orderCode)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        map.put(&quot;orderCode2&quot;, orderCode);</span><br><span class="line">        map.put(&quot;hello2&quot;, &quot;hello2&quot;);</span><br><span class="line">        return map ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Map&lt;String,Object&gt;&gt; getMore(List&lt;String&gt; orderCodes)&#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line">        for(String orderCode: orderCodes)&#123;</span><br><span class="line">            Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            map.put(&quot;code&quot;, orderCode);</span><br><span class="line">            map.put(&quot;hello&quot;, &quot;hello&quot;);</span><br><span class="line">            list.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        return list ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多线程-串行，并行futuretask-线程池并行"><a href="#多线程-串行，并行futuretask-线程池并行" class="headerlink" title="多线程  串行，并行futuretask  线程池并行"></a>多线程  串行，并行futuretask  线程池并行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Project Name:spring-boot</span><br><span class="line"> * File Name:DemoService.java</span><br><span class="line"> * Package Name:io.github.muxiaobai.spring_boot.service</span><br><span class="line"> * Date:2019年3月21日下午7:31:58</span><br><span class="line"> * Copyright (c) 2019, All Rights Reserved.</span><br><span class="line"> *</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package io.github.muxiaobai.spring_boot.service;</span><br><span class="line"></span><br><span class="line">import io.github.muxiaobai.spring_boot.remoteService.RemoteServiceCall;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Propagation;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ClassName:DemoService </span><br><span class="line"> * Function: TODO </span><br><span class="line"> * Reason: TODO </span><br><span class="line"> * Date:     2019年3月21日 下午7:31:58 </span><br><span class="line"> * @author   Mu Xiaobai</span><br><span class="line"> * @version  </span><br><span class="line"> * @since    JDK 1.8 </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class DemoMoreThreadService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RemoteServiceCall remoteCall;</span><br><span class="line">    </span><br><span class="line">    protected static ExecutorService threads = Executors.newFixedThreadPool(10);</span><br><span class="line">    /**</span><br><span class="line">     * 使用线程池并行</span><br><span class="line">     * doExecPoolRemote:().</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @param orderCode</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public Map&lt;String, Object&gt; doExecPoolRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">        System.out.println(&quot;sssss&quot;);</span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getOne(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">      </span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable1 =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getTwo(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask = new FutureTask&lt;&gt;(callable);</span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask1 = new FutureTask&lt;&gt;(callable1);</span><br><span class="line">        </span><br><span class="line">        threads.submit(futureTask);</span><br><span class="line">        threads.submit(futureTask1);</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.putAll(futureTask.get());</span><br><span class="line">        result.putAll(futureTask1.get());</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br><span class="line">    /**</span><br><span class="line">     * 使用线程并行</span><br><span class="line">     * doThreadRemote:().</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @param orderCode</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, Object&gt; doThreadRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">        </span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getOne(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        </span><br><span class="line">        Callable&lt;Map&lt;String, Object&gt;&gt; callable1 =  new Callable&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Map&lt;String, Object&gt; call() throws Exception &#123;</span><br><span class="line">                return remoteCall.getTwo(orderCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask = new FutureTask&lt;&gt;(callable);</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        FutureTask&lt;Map&lt;String, Object&gt;&gt; futureTask1 = new FutureTask&lt;&gt;(callable1);</span><br><span class="line">        new Thread(futureTask1).start();</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.putAll(futureTask.get());</span><br><span class="line">        result.putAll(futureTask1.get());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 串行</span><br><span class="line">     * doEachRemote:().</span><br><span class="line">     * @author Mu Xiaobai</span><br><span class="line">     * @param orderCode</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @since JDK 1.8</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, Object&gt; doEachRemote(String orderCode) throws InterruptedException, ExecutionException&#123;</span><br><span class="line">       </span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.putAll(remoteCall.getOne(orderCode));</span><br><span class="line">        result.putAll(remoteCall.getTwo(orderCode));</span><br><span class="line">       </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      java常用代码汇总，读futuretask,callable,使用
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java线上代码监控-工具-jprofiler</title>
    <link href="https://muxiaobai.github.io/2019/09/26/java%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81%E7%9B%91%E6%8E%A7-%E5%B7%A5%E5%85%B7-jprofiler/"/>
    <id>https://muxiaobai.github.io/2019/09/26/java线上代码监控-工具-jprofiler/</id>
    <published>2019-09-26T01:45:43.000Z</published>
    <updated>2020-05-06T05:58:29.711Z</updated>
    
    <content type="html"><![CDATA[<p>启动一个jvm进程</p><p>java -jar xxx.0.0.1.jar</p><p>服务器解压<a href="https://download-gcdn.ej-technologies.com/jprofiler/jprofiler_linux_11_0_2.tar.gz" target="_blank" rel="noopener">服务器端</a><br><a href="https://download-gcdn.ej-technologies.com/jprofiler/jprofiler_windows-x64_11_0_2.zip" target="_blank" rel="noopener">window客户端</a></p><p>服务器</p><ul><li>解压服务器</li><li>启动./jprofiler11.0.2/bin.jpenable</li><li>选择要监控功能的jvm</li><li>选择使用远程GUI监控</li><li>设置端口</li></ul><p>客户端</p><p>新建一个remote Session</p><h3 id="分析-dump—-gt-hprof"><a href="#分析-dump—-gt-hprof" class="headerlink" title="分析 dump—-&gt;hprof"></a>分析 dump—-&gt;hprof</h3><p><img src="/2019/09/26/java线上代码监控-工具-jprofiler/filter.png" alt><br><img src="/2019/09/26/java线上代码监控-工具-jprofiler/java.util.png" alt><br><img src="/2019/09/26/java线上代码监控-工具-jprofiler/class.png" alt></p><p>主要筛选自 java.util集合包中或者java.lang或者自己写的包.类</p><p>class 按类寻找，Biggest Objects 大对象</p><p>1、打开hprof文件:进入classes视图，根据（instance count和Size）基本可以确定哪个类的对象出现问题。比如(java.util.LinkedList$Entry类有2731062个实例)。<br>2、根据常识，应该java.util.LinkedList类有个对象的Size应该很大。<br>3、查看java.util.LinkedList，右键 use Selected Instance<br>4、选择Outgoing reference 视图(可以查看对象拥有的其他对象句柄,也就是对象属性)。看Retained size列（或者size属性）（有的时候Retained size不灵光），看大小就能确定是哪个对象内存溢出了。<br>5、找到对应的对象，右键use Selected Instance<br>6、选择Incoming refrences视图（该视图显示哪些对象拥有本对象的句柄），在这个视图下有个show Paths To GC Root的按钮，点击，基本能确定我们哪开代码有问题了。</p><p>最终找到大对象的或者多对象的类，优化类的代码</p>]]></content>
    
    <summary type="html">
    
      代码线上检测,快速查找bug
    
    </summary>
    
      <category term="java" scheme="https://muxiaobai.github.io/categories/java/"/>
    
    
  </entry>
  
</feed>
